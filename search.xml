<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux基础（三）-权限管理</title>
      <link href="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ACL-权限"><a href="#1-ACL-权限" class="headerlink" title="1 ACL 权限"></a>1 ACL 权限</h2><h3 id="1-1-ACL-概述"><a href="#1-1-ACL-概述" class="headerlink" title="1.1 ACL 概述"></a>1.1 ACL 概述</h3><p>ACL 是用于解决用户对文件身份不足的问题的<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/1.png"></p><h3 id="1-2-ACL命令"><a href="#1-2-ACL命令" class="headerlink" title="1.2 ACL命令"></a>1.2 ACL命令</h3><h4 id="1-2-1-给用户设定ACL权限"><a href="#1-2-1-给用户设定ACL权限" class="headerlink" title="1.2.1 给用户设定ACL权限"></a>1.2.1 给用户设定ACL权限</h4><pre class=" language-bash"><code class="language-bash">setfacl -m u:用户名:权限 文件名</code></pre><p><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/7.png"><br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/8.png"></p><h4 id="1-2-2-给用户组设置ACL权限"><a href="#1-2-2-给用户组设置ACL权限" class="headerlink" title="1.2.2 给用户组设置ACL权限"></a>1.2.2 给用户组设置ACL权限</h4><pre class=" language-bash"><code class="language-bash">setfacl -m g:组名：权限 文件名</code></pre><p><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/9.png"><br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/10.png"></p><h4 id="1-2-3-给目录赋予ACL权限"><a href="#1-2-3-给目录赋予ACL权限" class="headerlink" title="1.2.3 给目录赋予ACL权限"></a>1.2.3 给目录赋予ACL权限</h4><pre class=" language-bash"><code class="language-bash">setfacl -m u:cc:rx -R soft/   -R递归setfacl -m d:u:aa:rwx -R /test  d:设置默认权限</code></pre><p><font color="red">注意：</font>如果给目录赋予 acl 权限，两条命令都要输入<br>递归与默认的区别：<br>setfacl -m u:cc:rx -R soft/ 只对已经存在的文件生效<br>setfacl -m d:u:aa:rwx -R /test 只对以后新建的文件生效</p><h4 id="1-2-4-删除ACL权限"><a href="#1-2-4-删除ACL权限" class="headerlink" title="1.2.4 删除ACL权限"></a>1.2.4 删除ACL权限</h4><pre class=" language-bash"><code class="language-bash"> setfacl -x u:st /project/    <span class="token comment" spellcheck="true">#删除指定用户和用户组的 ACL 权限</span> setfacl -b project/        <span class="token comment" spellcheck="true">#会删除文件的所有的 ACL 权限 </span></code></pre><h4 id="1-2-5-设置最大有效权限-mask"><a href="#1-2-5-设置最大有效权限-mask" class="headerlink" title="1.2.5 设置最大有效权限 mask"></a>1.2.5 设置最大有效权限 mask</h4><pre class=" language-bash"><code class="language-bash">setfacl -m m:权限 project/</code></pre><p><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/11.png"></p><h2 id="2-sudo-授权"><a href="#2-sudo-授权" class="headerlink" title="2 sudo 授权"></a>2 sudo 授权</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>给普通用户赋予部分管理员权限<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/2.png"></p><ol><li>用户名/组名：代表 root 给哪个用户或用户组赋予命令，注意组名前加“%”</li><li>用户可以用指定的命令管理指定 IP 地址的服务器。如果写 ALL，代表可以管理任何主机，如果写固定 IP，代表用户可以管理指定的服务器。</li><li>可使用身份：就是把来源用户切换成什么身份使用，（ALL）代表可以切换成任意身份。这个字段可以省略</li><li>授权命令：代表 root 把什么命令授权给普通用户。</li></ol><h3 id="2-2-范列"><a href="#2-2-范列" class="headerlink" title="2.2 范列"></a>2.2 范列</h3><ol><li>visudo进入添加权限命令配置页面<br> <img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/3.png"></li><li>添加授权信息<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/4.png"></li><li>sudo -l查看可以执行的命令<br> <img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/5.png"></li><li>sudo 命令   执行命令<br> <img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/6.png"></li></ol><h2 id="3-文件特殊权限"><a href="#3-文件特殊权限" class="headerlink" title="3 文件特殊权限"></a>3 文件特殊权限</h2><h3 id="3-1-SetUID"><a href="#3-1-SetUID" class="headerlink" title="3.1 SetUID"></a>3.1 SetUID</h3><ol><li>只有可以执行的二进制程序才能设定 SUID 权限</li><li>命令执行者要对该程序拥有 x（执行）权限</li><li>命令执行者在执行该程序时获得该程序文件属主的身份（</li><li>SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/12.png"><br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/13.png"></li></ol><h3 id="3-2-SetGID"><a href="#3-2-SetGID" class="headerlink" title="3.2 SetGID"></a>3.2 SetGID</h3><h4 id="3-2-1-针对文件"><a href="#3-2-1-针对文件" class="headerlink" title="3.2.1 针对文件"></a>3.2.1 针对文件</h4><ol><li>只有可执行的二进制程序才能设置 SGID 权限</li><li>命令执行者要对该程序拥有 x（执行）权限</li><li>命令执行在执行程序的时候，组身份升级为该程序文件的属组</li><li>SetGID 权限只在该程序执行过程中有效，组身份改变只在程序执行过程中有效<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/14.png"><br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/15.png"></li></ol><h4 id="3-2-2-针对目录"><a href="#3-2-2-针对目录" class="headerlink" title="3.2.2 针对目录"></a>3.2.2 针对目录</h4><ol><li>普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录</li><li>普通用户在此目录中的有效组会变成此目录的属组</li><li>若普通用户对此目录拥有 w 权限时，新建的文件的默认属组是这个目录的属组<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/16.png"><br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/17.png"></li></ol><h3 id="3-3-Sticky-BIT"><a href="#3-3-Sticky-BIT" class="headerlink" title="3.3 Sticky BIT"></a>3.3 Sticky BIT</h3><ol><li>粘着位目前只对目录有效</li><li>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录拥有写入权限</li><li>一但赋予了粘着位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，不能删除其他用户建立的文件。<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/18.png"><br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/19.png"></li></ol><h2 id="4-文件系统属性-chattr-权限"><a href="#4-文件系统属性-chattr-权限" class="headerlink" title="4 文件系统属性 chattr 权限"></a>4 文件系统属性 chattr 权限</h2><h3 id="4-1-命令格式"><a href="#4-1-命令格式" class="headerlink" title="4.1 命令格式"></a>4.1 命令格式</h3><p><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/20.png"><br>4.2 查看文件系统属性 lsattr<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/21.png"></p><h3 id="4-3-示列"><a href="#4-3-示列" class="headerlink" title="4.3 示列"></a>4.3 示列</h3><p>给文件赋予i属性<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/22.png"><br>给目录赋予 i 属性<br><img src="/2022/02/10/Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/23.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium</title>
      <link href="/2022/01/19/selenium/"/>
      <url>/2022/01/19/selenium/</url>
      
        <content type="html"><![CDATA[<h2 id="1-python-selenium自动化测试环境搭建"><a href="#1-python-selenium自动化测试环境搭建" class="headerlink" title="1 python+selenium自动化测试环境搭建"></a>1 python+selenium自动化测试环境搭建</h2><h3 id="1-1-安装Python"><a href="#1-1-安装Python" class="headerlink" title="1.1 安装Python"></a>1.1 安装Python</h3><p>python下载地址：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a><br>python安装教程：<a href="http://c.biancheng.net/view/4161.html">http://c.biancheng.net/view/4161.html</a></p><h3 id="1-2-安装Pycharm"><a href="#1-2-安装Pycharm" class="headerlink" title="1.2 安装Pycharm"></a>1.2 安装Pycharm</h3><p>pycharm下载地址：<a href="https://download.jetbrains.com/python/pycharm-community-2017.3.2.exe">https://download.jetbrains.com/python/pycharm-community-2017.3.2.exe</a></p><h3 id="1-3-安装Selenium"><a href="#1-3-安装Selenium" class="headerlink" title="1.3 安装Selenium"></a>1.3 安装Selenium</h3><p>cmd下执行</p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> selenium<span class="token operator">==</span>3.14.1 -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><h3 id="1-4-浏览器"><a href="#1-4-浏览器" class="headerlink" title="1.4 浏览器"></a>1.4 浏览器</h3><h4 id="1-4-1-Firefox"><a href="#1-4-1-Firefox" class="headerlink" title="1.4.1 Firefox"></a>1.4.1 Firefox</h4><p>Firefox下载地址：<a href="https://ftp.mozilla.org/pub/firefox/releases/">https://ftp.mozilla.org/pub/firefox/releases/</a><br>geckodriver下载地址：<a href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases  </a><br>下载geckodriver后需要把geckodriver.exe放到python的可安装路径下或者把geckodriver.exe路径添加到环境变量path中。</p><h4 id="1-4-2-Chrome"><a href="#1-4-2-Chrome" class="headerlink" title="1.4.2 Chrome"></a>1.4.2 Chrome</h4><p>chromeriver下载地址：<a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></p><h2 id="3-seleniumAPI"><a href="#3-seleniumAPI" class="headerlink" title="3 seleniumAPI"></a>3 seleniumAPI</h2><h3 id="3-1-8大定位方式"><a href="#3-1-8大定位方式" class="headerlink" title="3.1 8大定位方式"></a>3.1 8大定位方式</h3><h4 id="3-1-1-id"><a href="#3-1-1-id" class="headerlink" title="3.1.1 id"></a>3.1.1 id</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##百度官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.baidu.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“百度一下”</span>su <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_id<span class="token punctuation">(</span><span class="token string">"su"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="3-1-2-className"><a href="#3-1-2-className" class="headerlink" title="3.1.2 className"></a>3.1.2 className</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#百度官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.baidu.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“百度一下”</span>self_btn <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_class_name<span class="token punctuation">(</span><span class="token string">"self-btn"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="3-1-3-TagName"><a href="#3-1-3-TagName" class="headerlink" title="3.1.3 TagName"></a>3.1.3 TagName</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“搜索输入框”</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_tag_name<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#默认取第一个input标签</span>elements <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_elements_by_tag_name<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#取所有的input标签</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="3-1-4-link-text"><a href="#3-1-4-link-text" class="headerlink" title="3.1.4 link_text"></a>3.1.4 link_text</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“新人福利”</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_link_text<span class="token punctuation">(</span><span class="token string">"新人福利"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="3-1-5-partial-link-text"><a href="#3-1-5-partial-link-text" class="headerlink" title="3.1.5 partial_link_text"></a>3.1.5 partial_link_text</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“新人福利”</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_partial_link_text<span class="token punctuation">(</span><span class="token string">"福利"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="3-1-6-name"><a href="#3-1-6-name" class="headerlink" title="3.1.6 name"></a>3.1.6 name</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#百度官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.baidu.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“搜索输入框”</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_name<span class="token punctuation">(</span><span class="token string">"wd"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="3-1-7-xpath"><a href="#3-1-7-xpath" class="headerlink" title="3.1.7 xpath"></a>3.1.7 xpath</h4><p><strong>1. 绝对路径：</strong><br><img src="/2022/01/19/selenium/1.png"></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“搜索输入框”</span><span class="token comment" spellcheck="true">#/html/body/div/div/div/div[2]/div/div[2]/input等价</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_xpath<span class="token punctuation">(</span><span class="token string">"/html/body/div/div/div/div/div/div/input"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>2. 相对路径：</strong></p><p>通过属性</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“搜索输入框”</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_xpath<span class="token punctuation">(</span><span class="token string">'//input[@aria-label="搜索" and @id="key"]'</span><span class="token punctuation">)</span>element1 <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_xpath<span class="token punctuation">(</span><span class="token string">'//span[text()="四川"]'</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>通过文字<br><img src="/2022/01/19/selenium/2.png"><br>模糊查询<br><img src="/2022/01/19/selenium/3.png"><br>通过父元素找子元素<br><img src="/2022/01/19/selenium/4.png"><br>通过子元素找父元素<br><img src="/2022/01/19/selenium/5.png"></p><h4 id="3-1-8-css"><a href="#3-1-8-css" class="headerlink" title="3.1.8 css"></a>3.1.8 css</h4><p><strong>1. 绝对路径</strong><br><img src="/2022/01/19/selenium/6.png"></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“搜索输入框”</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_css_selector<span class="token punctuation">(</span><span class="token string">"html>body>div>div>div>div>div>div>input"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>2. 相对路径</strong><br>通过id属性<br><img src="/2022/01/19/selenium/7.png"><br>通过class属性<br><img src="/2022/01/19/selenium/8.png"><br>其他属性<br><img src="/2022/01/19/selenium/9.png"><br>多个属性<br><img src="/2022/01/19/selenium/10.png"><br>父元素找子元素<br><img src="/2022/01/19/selenium/11.png"><br>nth-child(number)<br><img src="/2022/01/19/selenium/12.png"></p><h3 id="3-2-浏览器操作"><a href="#3-2-浏览器操作" class="headerlink" title="3.2 浏览器操作"></a>3.2 浏览器操作</h3><p>获取title信息，当前url信息</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取“搜索输入框”</span>title <span class="token operator">=</span> driver<span class="token punctuation">.</span>title<span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>url <span class="token operator">=</span> driver<span class="token punctuation">.</span>current_url<span class="token keyword">print</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>浏览器的刷新，后退，前进</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取搜索按钮</span>search_button <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_class_name<span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#点击搜索按钮</span>search_button<span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>refresh<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#刷新页面</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#后退</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#前进</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>设置窗体尺寸</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#窗体最大化</span>driver<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#设置窗体到指定的值</span>driver<span class="token punctuation">.</span>set_window_size<span class="token punctuation">(</span><span class="token number">1200</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-3-常用的元素操作方法"><a href="#3-3-常用的元素操作方法" class="headerlink" title="3.3 常用的元素操作方法"></a>3.3 常用的元素操作方法</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取文本信息</span>text <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_class_name<span class="token punctuation">(</span><span class="token string">"link-login"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text<span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取搜索输入框元素</span>inputEle <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_css_selector<span class="token punctuation">(</span><span class="token string">"#key"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取输入框的尺寸</span>size <span class="token operator">=</span> inputEle<span class="token punctuation">.</span>size<span class="token keyword">print</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#判断输入框控件是否可见</span>display <span class="token operator">=</span> inputEle<span class="token punctuation">.</span>is_displayed<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>display<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#在输入框输入“手机”</span>inputEle<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"手机"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取输入框中的type属性是啥</span>text <span class="token operator">=</span> inputEle<span class="token punctuation">.</span>get_attribute<span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取搜索按钮</span>search <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_class_name<span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#点击搜索按钮</span>search<span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-4-鼠标事件"><a href="#3-4-鼠标事件" class="headerlink" title="3.4 鼠标事件"></a>3.4 鼠标事件</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>action_chains <span class="token keyword">import</span> ActionChains<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取左侧菜单“家用电器”</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_xpath<span class="token punctuation">(</span><span class="token string">'//*[@id="J_cate"]/ul/li[1]/a'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取左侧菜单母婴控件</span>element1 <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_xpath<span class="token punctuation">(</span><span class="token string">'//*[@id="J_cate"]/ul/li[10]/a[1]'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#鼠标移动到家用电器</span>ActionChains<span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">.</span>move_to_element<span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span>perform<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#鼠标从家用电器移动到母婴</span>ActionChains<span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">.</span>drag_and_drop<span class="token punctuation">(</span>element<span class="token punctuation">,</span> element1<span class="token punctuation">)</span><span class="token punctuation">.</span>perform<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># #鼠标右击“家用电器”</span>ActionChains<span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">.</span>context_click<span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span>perform<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#鼠标双击“家用电器”</span>ActionChains<span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">.</span>double_click<span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span>perform<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#移动滑块</span><span class="token comment" spellcheck="true"># ActionChains(driver).drag_and_drop_by_offset(ele,100,0).perform</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-5-键盘事件"><a href="#3-5-键盘事件" class="headerlink" title="3.5 键盘事件"></a>3.5 键盘事件</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> time<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>keys <span class="token keyword">import</span> Keysdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取搜索输入框元素</span>inputEle <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_css_selector<span class="token punctuation">(</span><span class="token string">"#key"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输入框输入手机</span>inputEle<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"手机"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取输入的值</span>text <span class="token operator">=</span> inputEle<span class="token punctuation">.</span>get_attribute<span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#复制输入框的内容</span>inputEle<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>Keys<span class="token punctuation">.</span>CONTROL<span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span>inputEle<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>Keys<span class="token punctuation">.</span>CONTROL<span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#情况输入框内容</span>inputEle<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#粘贴内容到输入框</span>inputEle<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>Keys<span class="token punctuation">.</span>CONTROL<span class="token punctuation">,</span> <span class="token string">"V"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#点击回车进行搜索</span>inputEle<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>Keys<span class="token punctuation">.</span>ENTER<span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-6-select空间操作"><a href="#3-6-select空间操作" class="headerlink" title="3.6 select空间操作"></a>3.6 select空间操作</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support<span class="token punctuation">.</span>select <span class="token keyword">import</span> Select<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#携程官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.ctrip.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取国内酒店，酒店级别</span>element <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_id<span class="token punctuation">(</span><span class="token string">"J_roomCountList"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过下表选择酒店级别</span>Select<span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span>select_by_index<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#下标从0开始</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过value属性获取</span>Select<span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span>select_by_value<span class="token punctuation">(</span><span class="token string">"7"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过可见文字</span>Select<span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span>select_by_visible_text<span class="token punctuation">(</span><span class="token string">"4间"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-7-alert弹窗处理"><a href="#3-7-alert弹窗处理" class="headerlink" title="3.7 alert弹窗处理"></a>3.7 alert弹窗处理</h3><p><strong>弹出层的三种形态</strong><br><img src="/2022/01/19/selenium/13.png" alt="第1种"><br><img src="/2022/01/19/selenium/14.png" alt="第2种"><br><img src="/2022/01/19/selenium/15.png" alt="第3种"></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"File:///F:\\testAlert.html"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span><span class="token string">"prom()"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>switch_to_alert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"AAAAA"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#未提交输入提示框的内容</span><span class="token keyword">print</span><span class="token punctuation">(</span>driver<span class="token punctuation">.</span>switch_to_alert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#已提交，输入展示后内容</span>driver<span class="token punctuation">.</span>switch_to_alert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>driver<span class="token punctuation">.</span>switch_to_alert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#取消</span>driver<span class="token punctuation">.</span>switch_to_alert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>dismiss<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-8-iframe操作"><a href="#3-8-iframe操作" class="headerlink" title="3.8 iframe操作"></a>3.8 iframe操作</h3><p>如之前定位元素定位如下</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#网易邮箱官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://mail.163.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取邮箱账号元素</span>email <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_name<span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">)</span>email<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"1789546"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>报错如下<br> <img src="/2022/01/19/selenium/16.png"><br>原因：</p><ol><li>等待时间不够，需要的控件未加载完</li><li>定位方式错误</li><li>浏览器开启多窗体，未切换至自己需要定位的窗体</li><li>所需控件在iframe中，但是未切换至iframe<br><img src="/2022/01/19/selenium/17.png"><br>iframe大致如上所示，所以直接在html页面定位邮箱是定位不到的，需要切换至iframe才能定位到邮箱</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#网易邮箱官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://mail.163.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#定位到账号所在iframe</span><span class="token comment" spellcheck="true">#1.第一种方式</span><span class="token comment" spellcheck="true">#通过id，class定位，但是iframe的id，class可能会动态变化。可以使用包含</span><span class="token comment" spellcheck="true">#2.第二种方式</span><span class="token comment" spellcheck="true">#通过xpath定位</span>ele <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_xpath<span class="token punctuation">(</span><span class="token string">'//*[@id="loginDiv"]/iframe'</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>switch_to_frame<span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取邮箱账号元素</span>email <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_name<span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">)</span>email<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"1789546"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#切回父级iframe</span><span class="token comment" spellcheck="true"># driver.switch_to.parent_frame()</span><span class="token comment" spellcheck="true">#切回主文档，最开始的html</span><span class="token comment" spellcheck="true"># driver.switch_to.default_content()</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-9-等待时间"><a href="#3-9-等待时间" class="headerlink" title="3.9 等待时间"></a>3.9 等待时间</h3><p><strong>1. time.sleep()</strong><br>   强制等待时间，sleep后程序会停止等待时间后继续运行下面的程序。即使定位的控件加载出来也会继续等待。执行效率慢，稳定性高。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#网易邮箱官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://mail.163.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#等待2s关闭</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>2. 隐式等待时间</strong></p><ul><li>最大的超时时间，若设置10s，但是页面所有控件加载完成只需2s，则只等待了2s</li><li>若到了等待的最大时间，页面还未加载完成，则会报错，找不到控件</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#网易邮箱官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://mail.163.com/"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>implicitly_wait<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>email <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_name<span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>3. 显式等待时间</strong><br> 最大等待5s，每隔0.5s检查一次，直到某一个控件加载完就不再等待了</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> By<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support <span class="token keyword">import</span> expected_conditions <span class="token keyword">as</span> EC<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support<span class="token punctuation">.</span>ui <span class="token keyword">import</span> WebDriverWaitdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取搜索输入框元素</span>ele <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>presence_of_element_located<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>CSS_SELECTOR<span class="token punctuation">,</span> <span class="token string">"#key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>如何选择等待时间</strong><br>对于页面加载不稳定的就用sleep，若只等待某一个控件就用显示等待时间，若要等待加载页面相对稳定就用隐式等待时间</p><h3 id="3-10-截图操作"><a href="#3-10-截图操作" class="headerlink" title="3.10 截图操作"></a>3.10 截图操作</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get_screenshot_as_file<span class="token punctuation">(</span>r<span class="token string">'C:\Users\Helene\Desktop\1.png'</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-11-多窗口处理"><a href="#3-11-多窗口处理" class="headerlink" title="3.11 多窗口处理"></a>3.11 多窗口处理</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#京东官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com//"</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取新人福利</span>ele <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_link_text<span class="token punctuation">(</span><span class="token string">"PLUS会员"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#点击新人福利</span>ele<span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">###默认窗口是第一个</span><span class="token comment" spellcheck="true">#获取所有窗体句柄信息</span>handles <span class="token operator">=</span> driver<span class="token punctuation">.</span>window_handles<span class="token keyword">print</span><span class="token punctuation">(</span>handles<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取当前窗体</span>current_win <span class="token operator">=</span> driver<span class="token punctuation">.</span>current_window_handle<span class="token keyword">print</span><span class="token punctuation">(</span>current_win<span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#切换至第二个窗体</span>driver<span class="token punctuation">.</span>switch_to<span class="token punctuation">.</span>window<span class="token punctuation">(</span>handles<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取当前窗体</span>current_win <span class="token operator">=</span> driver<span class="token punctuation">.</span>current_window_handle<span class="token keyword">print</span><span class="token punctuation">(</span>current_win<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#关闭当前窗体所在窗口额句柄</span><span class="token comment" spellcheck="true">#driver.close()</span><span class="token comment" spellcheck="true">#关闭当前会话。所有窗体都会关闭</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="3-12-时间控件"><a href="#3-12-时间控件" class="headerlink" title="3.12 时间控件"></a>3.12 时间控件</h4><p> <img src="/2022/01/19/selenium/18.png"></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#携程官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.ctrip.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取国内酒店入住日期</span>checkIn <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_id<span class="token punctuation">(</span><span class="token string">"HD_CheckIn"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#清空原来的日志</span>checkIn<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#设置日期</span>checkIn<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"2019-04-04"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#若控件有readonly属性，则是不能直接输入的，需要去掉readonly属性，才能输入</span><span class="token comment" spellcheck="true">#去除方法如下所示</span><span class="token comment" spellcheck="true"># js = "document.getElementById('XX').removeAttribute('readonly')"</span><span class="token comment" spellcheck="true"># js = "document.getElementsByName('XX')[0].removeAttribute('readonly')"</span><span class="token comment" spellcheck="true"># js = "document.getElementByTagName('XX')[3].removeAttribute('readonly')"</span><span class="token comment" spellcheck="true"># driver.execute_script(js)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-13-滚动条"><a href="#3-13-滚动条" class="headerlink" title="3.13 滚动条"></a>3.13 滚动条</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#携程官网</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.ctrip.com/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#移动到页面的底部</span>js <span class="token operator">=</span> <span class="token string">"var q=document.documentElement.scrollTop=10000"</span>driver<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span>js<span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#移动到页面的顶部</span>js <span class="token operator">=</span> <span class="token string">"var q=document.documentElement.scrollTop=0"</span>driver<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span>js<span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#移动到页面的中间</span>driver<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span><span class="token string">"window.scrollTo(0,document.body.scrollHeight*0.5)"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#移动到绝对坐标</span>driver<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span><span class="token string">"window.scrollTo(0,200)"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#移动到相对坐标</span>driver<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span><span class="token string">"window.scrollBy(0,200)"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-14-文件上传"><a href="#3-14-文件上传" class="headerlink" title="3.14 文件上传"></a>3.14 文件上传</h3><p><strong>1. input标签文件上传</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>find_element_by_name<span class="token punctuation">(</span><span class="token string">'file'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>r<span class="token string">'C:\Users\Helene\Desktop\1.png'</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit</code></pre><p><strong>2. 非input标签AutoIt上传文件</strong></p>]]></content>
      
      
      <categories>
          
          <category> selenium </category>
          
          <category> UI自动化测试 </category>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> selenium </tag>
            
            <tag> UI自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell（二）shell编程</title>
      <link href="/2022/01/14/shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/14/shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1 正则表达式"></a>1 正则表达式</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>grep、awk、sed 等命令可以支持正则表达式<br>ls、find、cp 这些命令不支持正则表达式，所以只能使用 shell 自己的通配符来进行匹配。</p><h3 id="1-2-基础正则表达式"><a href="#1-2-基础正则表达式" class="headerlink" title="1.2 基础正则表达式"></a>1.2 基础正则表达式</h3><table><thead><tr><th>元字符</th><th>作 用</th></tr></thead><tbody><tr><td>*</td><td>前一个字符匹配 0 次或任意多次。</td></tr><tr><td>.</td><td>匹配除了换行符外任意一个字符。</td></tr><tr><td>^</td><td>匹配行首</td></tr><tr><td>$</td><td>匹配行尾</td></tr><tr><td>[]</td><td>匹配中括号中指定的任意一个字符，只匹配一个字符。</td></tr><tr><td>[^]</td><td>匹配除中括号的字符以外的任意一个字符</td></tr><tr><td>\</td><td>转义符</td></tr><tr><td>{n}</td><td>表示其前面的字符恰好出现 n 次。[1][3-8][0-9]{9} 匹配手机号码。</td></tr><tr><td>{n,}</td><td>表示其前面的字符出现不小于 n 次。</td></tr><tr><td>{n,m}</td><td>表示其前面的字符至少出现n次，最多出现m次。</td></tr></tbody></table><h3 id="1-2-1-“-”"><a href="#1-2-1-“-”" class="headerlink" title="1.2.1 “*”"></a>1.2.1 “*”</h3><p>前一个字符匹配 0 次，或任意多次<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/1.png"></p><h4 id="1-2-2-“-”"><a href="#1-2-2-“-”" class="headerlink" title="1.2.2 “.”"></a>1.2.2 “.”</h4><p>匹配除了换行符外任意一个字符</p><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/2.png"></p><h4 id="1-2-3-“-”"><a href="#1-2-3-“-”" class="headerlink" title="1.2.3 “^”"></a>1.2.3 “^”</h4><p>匹配行首<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/3.png"></p><h4 id="1-2-4-“-”"><a href="#1-2-4-“-”" class="headerlink" title="1.2.4 “$”"></a>1.2.4 “$”</h4><p>匹配行尾<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/4.png"><br>匹配空白行<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/5.png"></p><h4 id="1-2-5-“-”"><a href="#1-2-5-“-”" class="headerlink" title="1.2.5 “[]”"></a>1.2.5 “[]”</h4><p>匹配中括号中指定的任意一个字符，只匹配一个字符<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/6.png"></p><h4 id="1-2-6-“-”"><a href="#1-2-6-“-”" class="headerlink" title="1.2.6 “[^]”"></a>1.2.6 “[^]”</h4><p>匹配除中括号的字符以外的任意一个字符<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/7.png"></p><h4 id="1-2-7-“-”"><a href="#1-2-7-“-”" class="headerlink" title="1.2.7 “\”"></a>1.2.7 “\”</h4><p>转义符<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/8.png"></p><h4 id="1-2-8-“-n-”"><a href="#1-2-8-“-n-”" class="headerlink" title="1.2.8 “{n}”"></a>1.2.8 “{n}”</h4><p>表示其前面的字符恰好出现 n 次<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/9.png"></p><h4 id="1-2-9-“-n-”"><a href="#1-2-9-“-n-”" class="headerlink" title="1.2.9 “{n,}”"></a>1.2.9 “{n,}”</h4><p>表示其前面的字符出现不小于 n 次<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/10.png"></p><h4 id="1-2-10-“-n-m-”"><a href="#1-2-10-“-n-m-”" class="headerlink" title="1.2.10 “{n,m}”"></a>1.2.10 “{n,m}”</h4><p>匹配其前面的字符至少出现 n 次，最多出现 m 次<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/11.png"></p><h3 id="1-3-扩展正则表达式"><a href="#1-3-扩展正则表达式" class="headerlink" title="1.3 扩展正则表达式"></a>1.3 扩展正则表达式</h3><p>必须使用 egrep 命令或 grep -E 选项来支持下方的元字符</p><table><thead><tr><th>扩展元字符</th><th>作 用</th></tr></thead><tbody><tr><td>+</td><td>前一个字符匹配 1 次或任意多次。如“go+gle”会配“gogle”、“google”或“gooogle”，当然如果“o”有更多个，也能匹配。</td></tr><tr><td>？</td><td>前一个字符匹配 0 次或 1 次。如“colou?r”可以匹配“colour”或“color”。</td></tr><tr><td>|</td><td>匹配两个或多个分支选择。如“was</td></tr><tr><td>（）</td><td>匹配其整体为一个字符，即模式单元。可以理解为由多个单个字符组成的大字符如“(dog)+”会匹配“dog”、“dogdog”、“dogdogdog”等，因为被（）包含的字符会当成一个整体但“hello （world</td></tr></tbody></table><h2 id="2-字符截取和替换命令"><a href="#2-字符截取和替换命令" class="headerlink" title="2 字符截取和替换命令"></a>2 字符截取和替换命令</h2><h3 id="2-1-cut-列提取命令"><a href="#2-1-cut-列提取命令" class="headerlink" title="2.1 cut 列提取命令"></a>2.1 cut 列提取命令</h3><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/12.png"><br>提取第二列内容<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/19.png"><br>提取第八个字符开始到行尾<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/20.png"><br>以“：”作为分隔符，提取第一列和第三列<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/21.png"></p><h3 id="2-2-awk-编程"><a href="#2-2-awk-编程" class="headerlink" title="2.2 awk 编程"></a>2.2 awk 编程</h3><h4 id="2-2-1-printf-格式化输出"><a href="#2-2-1-printf-格式化输出" class="headerlink" title="2.2.1 printf 格式化输出"></a>2.2.1 printf 格式化输出</h4><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/13.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/22.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/23.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/24.png"></p><h4 id="2-2-2-awk-基本使用"><a href="#2-2-2-awk-基本使用" class="headerlink" title="2.2.2 awk 基本使用"></a>2.2.2 awk 基本使用</h4><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/14.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/25.png"></p><h4 id="2-2-3-awk-的条件"><a href="#2-2-3-awk-的条件" class="headerlink" title="2.2.3 awk 的条件"></a>2.2.3 awk 的条件</h4><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/15.png"></p><ol><li>BEGIN<br>BEGIN 的执行时机是“在 awk 程序一开始时，尚未读取任何数据之前执行”。一旦 BEGIN 后的动作执行一次，当 awk 开始从文件中读入数据，BEGIN的条件就不再成立，所以 BEGIN 定义的动作只能被执行一次。<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/26.png"></li><li>END<br>END 是在 awk 程序处理完所有数据，即将结束时执行。END 后的动作只在程序结束时执行一次。<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/27.png"></li><li>关系运算符<br>成绩大于等于 87 分的人是谁<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/28.png"><br>虽然 awk 是列提取命令，但是也要按行来读入的。这个命令的执行过程是这样的：<ul><li>如果有 BEGIN 条件，则先执行 BEGIN 定义的动作</li><li>如果没有 BEGIN 条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2 等变量。其中$0代表此行的整体数据，$1 代表第一字段，$2 代表第二字段。</li><li>依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。</li><li>读入下一行数据，重复执行以上步骤。</li></ul></li><li>正则表达式<br>如果要想让 awk 识别字符串，必须使用“//”包含<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/29.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/30.png"></li></ol><h4 id="2-2-4-awk-内置变量"><a href="#2-2-4-awk-内置变量" class="headerlink" title="2.2.4 awk 内置变量"></a>2.2.4 awk 内置变量</h4><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/16.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/31.png"></p><h4 id="2-2-5-awk-流程控制"><a href="#2-2-5-awk-流程控制" class="headerlink" title="2.2.5 awk 流程控制"></a>2.2.5 awk 流程控制</h4><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/32.png"><br>在 awk 编程中，因为命令语句非常长，在输入格式时需要注意以下内容：</p><ol><li>多个条件{动作}可以用空格分割，也可以用回车分割。</li><li>在一个动作中，如果需要执行多个命令，需要用“；”分割，或用回车分割。</li><li>在 awk 中，变量的赋值与调用都不需要加入“$”符。</li><li>条件中判断两个值是否相同，请使用“==”，以便和变量赋值进行区分。<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/33.png"></li></ol><h4 id="2-2-6-awk-函数"><a href="#2-2-6-awk-函数" class="headerlink" title="2.2.6 awk 函数"></a>2.2.6 awk 函数</h4><p>语法：<br>function 函数名（参数列表）{<br>      函数体<br>}<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/34.png"></p><h4 id="2-2-7-awk-中调用脚本"><a href="#2-2-7-awk-中调用脚本" class="headerlink" title="2.2.7 awk 中调用脚本"></a>2.2.7 awk 中调用脚本</h4><p>小的单行程序来说，将脚本作为命令行自变量传递给 awk 是很合适的<br>当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用 awk 的-f 选项，使其读入脚本并且执行。<br>pass.awk<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/36.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/35.png"></p><h4 id="2-3-3-sed-命令"><a href="#2-3-3-sed-命令" class="headerlink" title="2.3 3 sed 命令"></a>2.3 3 sed 命令</h4><p>sed 主要是用来将数据进行选取、替换、删除、新增的命令<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/17.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/18.png"><br><strong>行数据操作</strong><br>一般 sed 命令会把所有数据都输出到屏幕，要加入选项n才会只输出经过sed命令处理的行<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/37.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/42.png"><br>删除文件的数据（只删除输出到屏幕的数据，源文件未删除）<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/38.png"><br>追加行数据（同上）<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/39.png"><br>插入行数据（同上）<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/40.png"><br>替换文件内容（-i会替换源文件的内容，源文件改变）<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/41.png"><br><strong>字符串替换</strong><br>语法：sed ‘s/旧字串/新字串/g’ 文件名<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/43.png"><br>将第4行注释<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/44.png"><br>sed 中“-e”选项可以同时执行多个 sed 动作。多个动作之间要用“；”号或回车分割，sed只能操作指定行范围，但是可以通过-e选项操作不相邻的2行<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/45.png"></p><h2 id="3-字符处理命令"><a href="#3-字符处理命令" class="headerlink" title="3 字符处理命令"></a>3 字符处理命令</h2><h3 id="3-1-排序命令-sort"><a href="#3-1-排序命令-sort" class="headerlink" title="3.1 排序命令 sort"></a>3.1 排序命令 sort</h3><p>默认使用字符串排序，源文件不变<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/46.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/47.png"><br>排序默认是用每行开头第一个字符来进行排序的<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/48.png"><br>反向排序<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/49.png"></p><p>指定排序的字段，使用“-t”选项指定分隔符，使用“-k”选项指定字段号。加入我想要按照 UID 字段排序</p><p>指定分隔符是“：”，用第三字段开头，第三字段结尾排序，就是只用第三字段排序<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/50.png"></p><h3 id="3-2-取消重复行uniq"><a href="#3-2-取消重复行uniq" class="headerlink" title="3.2 取消重复行uniq"></a>3.2 取消重复行uniq</h3><p>和“sort -u”选项是一样的<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/51.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/52.png"><br>3.3 统计命令 wc<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/53.png"></p><h2 id="4-条件判断"><a href="#4-条件判断" class="headerlink" title="4 条件判断"></a>4 条件判断</h2><h3 id="4-1-按照文件类型进行判断"><a href="#4-1-按照文件类型进行判断" class="headerlink" title="4.1 按照文件类型进行判断"></a>4.1 按照文件类型进行判断</h3><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/54.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/55.png"><br>示列<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/56.png"><br><a href="https://helenedhl.github.io/2022/01/13/shell%E5%9F%BA%E7%A1%80/">预定义变量</a></p><h3 id="4-2-按照文件权限进行判断"><a href="#4-2-按照文件权限进行判断" class="headerlink" title="4.2 按照文件权限进行判断"></a>4.2 按照文件权限进行判断</h3><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/57.png"><br>示列<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/58.png"></p><h3 id="4-3-两个文件之间进行比较"><a href="#4-3-两个文件之间进行比较" class="headerlink" title="4.3 两个文件之间进行比较"></a>4.3 两个文件之间进行比较</h3><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/59.png"><br>示列<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/60.png"></p><h3 id="4-4-两个整数之间比较"><a href="#4-4-两个整数之间比较" class="headerlink" title="4.4 两个整数之间比较"></a>4.4 两个整数之间比较</h3><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/61.png"><br>示列<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/62.png"></p><h3 id="4-5-字符串的判断"><a href="#4-5-字符串的判断" class="headerlink" title="4.5 字符串的判断"></a>4.5 字符串的判断</h3><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/63.png"><br>示列<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/64.png"></p><h3 id="4-6-多重条件判断"><a href="#4-6-多重条件判断" class="headerlink" title="4.6 多重条件判断"></a>4.6 多重条件判断</h3><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/65.png"><br>示列<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/66.png"><br>“！”和“-n”之间必须加入空格，否则会报错的</p><h2 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5 流程控制"></a>5 流程控制</h2><h3 id="5-1-if-条件判断"><a href="#5-1-if-条件判断" class="headerlink" title="5.1 if 条件判断"></a>5.1 if 条件判断</h3><h4 id="5-1-1-单分支-if-条件语句"><a href="#5-1-1-单分支-if-条件语句" class="headerlink" title="5.1.1 单分支 if 条件语句"></a>5.1.1 单分支 if 条件语句</h4><p>语法：<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/67.png"></p><ol><li>if 语句使用 fi 结尾，和一般语言使用大括号结尾不同</li><li>[ 条件判断式 ]就是使用 test 命令判断，所以中括号和条件判断式之间必须有空格</li><li>then 后面跟符合条件之后执行的程序，可以放在[]之后，用“；”分割。也可以换行写入，就不需要“；”了，比如单分支 if 语句还可以这样写：<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/68.png"></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token comment" spellcheck="true">#统计根分区使用率</span>rate<span class="token operator">=</span><span class="token punctuation">$(</span>df -h <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"/dev/sda5"</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&amp;#123;print <span class="token variable">$5</span>&amp;#125;'</span> <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">"%"</span> -f 1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#把根分区使用率作为变量值赋予变量 rate</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$rate</span> -ge 20 <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#判断 rate 的值如果大于等于 20，则执行 then 程序</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"Warning! /dev/sda3 is full!!"</span>#打印警告信息。在实际工作中，也可以向管理员发送邮件。<span class="token keyword">fi</span></code></pre><h4 id="5-1-2-双分支-if-条件语句"><a href="#5-1-2-双分支-if-条件语句" class="headerlink" title="5.1.2 双分支 if 条件语句"></a>5.1.2 双分支 if 条件语句</h4><p>语法：<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/69.png"></p><h4 id="5-1-3-多分支-if-条件语句"><a href="#5-1-3-多分支-if-条件语句" class="headerlink" title="5.1.3 多分支 if 条件语句"></a>5.1.3 多分支 if 条件语句</h4><p>语法：<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/70.png"><br>示列</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#判断用户输入的是什么文件</span><span class="token function">read</span> -p <span class="token string">"Please input a filename: "</span> <span class="token function">file</span>  <span class="token comment" spellcheck="true">#接收键盘的输入，并赋予变量 file</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#判断 file 变量是否为空</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"Error,please input a filename"</span> <span class="token comment" spellcheck="true">#如果为空，执行程序 1，也就是输出报错信息</span> <span class="token keyword">exit</span> 1 <span class="token comment" spellcheck="true">#退出程序，并返回值为 1（把返回值赋予变量$?）</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -e <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#判断 file 的值是否存在</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"Your input is not a file!"</span> <span class="token comment" spellcheck="true">#如果不存在，则执行程序 2</span> <span class="token keyword">exit</span> 2 <span class="token comment" spellcheck="true">#退出程序，把并定义返回值为 2</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> -f <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#判断 file 的值是否为普通文件</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$file</span> is a regulare file!"</span> <span class="token comment" spellcheck="true">#如果是普通文件，则执行程序 3</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> -d <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#判断 file 的值是否为目录文件</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$file</span> is a directory!"</span> <span class="token comment" spellcheck="true">#如果是目录文件，则执行程序 4</span><span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$file</span> is an other file!"</span> <span class="token comment" spellcheck="true">#如果以上判断都不是，则执行程序 5</span><span class="token keyword">fi</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/71.png"></p><h3 id="5-2-多分支-case-条件语句"><a href="#5-2-多分支-case-条件语句" class="headerlink" title="5.2 多分支 case 条件语句"></a>5.2 多分支 case 条件语句</h3><p>语法<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/72.png"><br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/73.png"><br>这个语句需要注意以下内容：</p><ol><li>case 语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应<br>的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行“<em>）”（“</em>”<br>代表所有其他值）中的程序。</li><li>case 语句以“case”开头，以“esac”结尾。</li><li>每一个分支程序之后要通过“;;”双分号结尾，代表该程序段结束</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token function">read</span> -p <span class="token string">"Please choose yes/no: "</span> -t 30 cho  <span class="token comment" spellcheck="true">#在屏幕上输出“请选择 yes/no”，然后把用户选择赋予变量 cho</span><span class="token keyword">case</span> <span class="token variable">$cho</span> <span class="token keyword">in</span> <span class="token comment" spellcheck="true">#判断变量 cho 的值</span> <span class="token string">"yes"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#如果是 yes</span>        <span class="token keyword">echo</span> <span class="token string">"Your choose is yes!"</span>        <span class="token comment" spellcheck="true">#执行程序 1</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token string">"no"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#如果是 no</span>         <span class="token keyword">echo</span> <span class="token string">"Your choose is no!"</span>        <span class="token comment" spellcheck="true">#执行程序 2</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> *<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#如果既不是 yes，也不是 no</span>        <span class="token keyword">echo</span> <span class="token string">"Your choose is error!"</span>        <span class="token comment" spellcheck="true">#则执行此程序</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>esac</code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/74.png"></p><h3 id="5-3-for-循环"><a href="#5-3-for-循环" class="headerlink" title="5.3 for 循环"></a>5.3 for 循环</h3><p>语法<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/75.png"><br>这种语法中 for 循环的次数，取决于 in 后面值的个数（空格分隔），有几个值就循环几次，并<br>且每次循环都把值赋予变量。<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/76.png"><br>需要注意：</p><ol><li>初始值：在循环开始时，需要给某个变量赋予初始值，如 i=1；</li><li>循环控制条件：用于指定变量循环的次数，如 i&lt;=100，则只要 i 的值小于等于 100，循环就会继续；</li><li>变量变化：每次循环之后，变量该如何变化，如 i=i+1。代表每次循环之后，变量 i 的值都加 1。</li></ol><p>示列</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">for</span> <span class="token function">time</span> <span class="token keyword">in</span> morning noon afternoon evening <span class="token keyword">do</span>        <span class="token keyword">echo</span> <span class="token string">"This time is <span class="token variable">$time!</span>"</span><span class="token keyword">done</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/77.png"></p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#从 1 加到 100</span>s<span class="token operator">=</span>0<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">))</span></span> <span class="token comment" spellcheck="true">#定义循环 100 次</span> <span class="token keyword">do</span>         s<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $s<span class="token operator">+</span>$i <span class="token variable">))</span></span> <span class="token comment" spellcheck="true">#每次循环给变量 s 赋值</span> <span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token string">"The sum of 1+2+...+100 is : <span class="token variable">$s</span>"</span> <span class="token comment" spellcheck="true">#输出 1 加到 100 的和</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/78.png"></p><h3 id="5-4-while-循环"><a href="#5-4-while-循环" class="headerlink" title="5.4 while 循环"></a>5.4 while 循环</h3><p>语法<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/79.png"><br>示列</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#从 1 加到 100</span>i<span class="token operator">=</span>1s<span class="token operator">=</span>0 <span class="token comment" spellcheck="true">#给变量 i 和变量 s 赋值</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -le 100 <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#如果变量 i 的值小于等于 100，则执行循环</span> <span class="token keyword">do</span>         s<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $s<span class="token operator">+</span>$i <span class="token variable">))</span></span>         i<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $i<span class="token operator">+</span><span class="token number">1</span> <span class="token variable">))</span></span> <span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token string">"The sum is: <span class="token variable">$s</span>"</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/80.png"></p><h3 id="5-5-until-循环"><a href="#5-5-until-循环" class="headerlink" title="5.5 until 循环"></a>5.5 until 循环</h3><p>语法<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/81.png"><br>示列</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#从 1 加到 100</span>i<span class="token operator">=</span>1s<span class="token operator">=</span>0 <span class="token comment" spellcheck="true">#给变量 i 和变量 s 赋值</span><span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -gt 100 <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#循环直到变量 i 的值大于 100，就停止循环</span> <span class="token keyword">do</span>         s<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $s<span class="token operator">+</span>$i <span class="token variable">))</span></span>         i<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $i<span class="token operator">+</span><span class="token number">1</span> <span class="token variable">))</span></span> <span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token string">"The sum is: <span class="token variable">$s</span>"</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/82.png"></p><h3 id="5-6-函数"><a href="#5-6-函数" class="headerlink" title="5.6 函数"></a>5.6 函数</h3><p>语法<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/83.png"><br>示列</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token comment" spellcheck="true">#接收用户输入的数字，然后从 1 加到这个数字</span><span class="token keyword">function</span> <span class="token function">sum</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; #定义函数 sum</span> s<span class="token operator">=</span>0 <span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>$<span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">))</span></span> <span class="token comment" spellcheck="true">#循环直到 i 大于$1 为止。$1 是函数 sum 的第一个参数</span>                           <span class="token comment" spellcheck="true">#在函数中也可以使用位置参数变量，不过这里的$1 指的是函数的第一个参数</span>        <span class="token keyword">do</span>                s<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span> $i<span class="token operator">+</span>$s <span class="token variable">))</span></span>        <span class="token keyword">done</span> <span class="token keyword">echo</span> <span class="token string">"The sum of 1+2+3...+<span class="token variable">$1</span> is : <span class="token variable">$s</span>"</span> <span class="token comment" spellcheck="true">#输出 1 加到$1 的和</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token function">read</span> -p <span class="token string">"Please input a number: "</span> -t 30 num  <span class="token comment" spellcheck="true">#接收用户输入的数字，并把值赋予变量 num</span>y<span class="token operator">=</span><span class="token punctuation">$(</span>echo <span class="token variable">$num</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/[0-9]//g'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#把变量 num 的值替换为空，并赋予变量 y</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$y</span>"</span> <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#判断变量 y 是否为空，以确定变量 num 中是否为数字</span> <span class="token keyword">then</span>        <span class="token function">sum</span> <span class="token variable">$num</span> <span class="token comment" spellcheck="true">#调用 sum 函数，并把变量 num 的值作为第一个参数传递给 sum 函数</span> <span class="token keyword">else</span>        <span class="token keyword">echo</span> <span class="token string">"Error!! Please input a number!"</span> <span class="token comment" spellcheck="true">#如果变量 num 的值不是数字，则输出报错信息</span><span class="token keyword">fi</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/84.png"></p><h3 id="5-7-特殊流程控制语句"><a href="#5-7-特殊流程控制语句" class="headerlink" title="5.7 特殊流程控制语句"></a>5.7 特殊流程控制语句</h3><h4 id="5-7-1-exit-语句"><a href="#5-7-1-exit-语句" class="headerlink" title="5.7.1 exit 语句"></a>5.7.1 exit 语句</h4><p>语法<br><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/85.png"><br>系统exit 命令，用于退出当前用户的登录状态。<br>Shell 脚本中，exit 语句是用来退出当前脚本的。也就是说，在 Shell 脚本中，只要碰到了 exit 语句，后续的程序就不再执行，而直接退出脚本。</p><p>如果 exit 命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。<br>可以通过查询$?这个变量，来查看返回值。如果 exit 之后没有定义返回值，脚本执行之后的返回值<br>是执行 exit 语句之前，最后执行的一条命令的返回值。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token comment" spellcheck="true">#演示 exit 的作用</span><span class="token function">read</span> -p <span class="token string">"Please input a number: "</span> -t 30 num  <span class="token comment" spellcheck="true">#接收用户的输入，并把输入赋予变量 num</span>y<span class="token operator">=</span><span class="token punctuation">$(</span>echo <span class="token variable">$num</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/[0-9]//g'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#如果变量 num 的值是数字，则把 num 的值替换为空，否则不替换</span><span class="token comment" spellcheck="true">#把替换之后的值赋予变量 y</span><span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$y</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"Error! Please input a number!"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span> 18 <span class="token comment" spellcheck="true">#判断变量 y 的值如果不为空，输出报错信息，退出脚本，退出返回值为 18</span><span class="token keyword">echo</span> <span class="token string">"The number is: <span class="token variable">$num</span>"</span> <span class="token comment" spellcheck="true">#如果没有退出，则打印变量 num 中的数字</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/86.png"></p><h4 id="5-7-2-break-语句"><a href="#5-7-2-break-语句" class="headerlink" title="5.7.2 break 语句"></a>5.7.2 break 语句</h4><p>当程序执行到 break 语句时，会结束整个当前循环</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#演示 break 跳出循环</span><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">))</span></span> <span class="token comment" spellcheck="true">#循环十次</span> <span class="token keyword">do</span>        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$i</span>"</span> -eq 4 <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#如果变量 i 的值等于 4</span>           <span class="token keyword">then</span>                <span class="token keyword">break</span> <span class="token comment" spellcheck="true">#退出整个循环</span>        <span class="token keyword">fi</span> <span class="token keyword">echo</span> <span class="token variable">$i</span> <span class="token comment" spellcheck="true">#输出变量 i 的值</span><span class="token keyword">done</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/87.png"></p><h4 id="5-7-3-continue-语句"><a href="#5-7-3-continue-语句" class="headerlink" title="5.7.3 continue 语句"></a>5.7.3 continue 语句</h4><p>continue 语句只会结束单次当前循环</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#演示 continue 语句</span><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">))</span></span> <span class="token keyword">do</span>   <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$i</span>"</span> -eq 4 <span class="token punctuation">]</span>     <span class="token keyword">then</span>       <span class="token keyword">continue</span> <span class="token comment" spellcheck="true">#退出语句换成 continue</span>   <span class="token keyword">fi</span> <span class="token keyword">echo</span> <span class="token variable">$i</span><span class="token keyword">done</span></code></pre><p><img src="/2022/01/14/shell%E7%BC%96%E7%A8%8B/88.png"></p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell（一）shell基础</title>
      <link href="/2022/01/13/shell%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/13/shell%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-shell脚本的执行方式"><a href="#1-shell脚本的执行方式" class="headerlink" title="1 shell脚本的执行方式"></a>1 shell脚本的执行方式</h2><h3 id="1-1-赋予执行权限，直接运行"><a href="#1-1-赋予执行权限，直接运行" class="headerlink" title="1.1 赋予执行权限，直接运行"></a>1.1 赋予执行权限，直接运行</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/1.png"></p><h3 id="1-2-通过-Bash-调用执行脚本"><a href="#1-2-通过-Bash-调用执行脚本" class="headerlink" title="1.2 通过 Bash 调用执行脚本"></a>1.2 通过 Bash 调用执行脚本</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/2.png"></p><h3 id="1-3-sh脚本放在PATH变量中的任意路径下（临时生效）"><a href="#1-3-sh脚本放在PATH变量中的任意路径下（临时生效）" class="headerlink" title="1.3 sh脚本放在PATH变量中的任意路径下（临时生效）"></a>1.3 sh脚本放在PATH变量中的任意路径下（临时生效）</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/23.png"></p><h3 id="1-4-通过以修改-PATH-变量的值（临时生效）"><a href="#1-4-通过以修改-PATH-变量的值（临时生效）" class="headerlink" title="1.4 通过以修改 PATH 变量的值（临时生效）"></a>1.4 通过以修改 PATH 变量的值（临时生效）</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/24.png"></p><h3 id="1-5-在家目录下新建bin目录，将脚本放入bin目录里面"><a href="#1-5-在家目录下新建bin目录，将脚本放入bin目录里面" class="headerlink" title="1.5 在家目录下新建bin目录，将脚本放入bin目录里面"></a>1.5 在家目录下新建bin目录，将脚本放入bin目录里面</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/41.png"></p><h2 id="2-Bash-的基本功能"><a href="#2-Bash-的基本功能" class="headerlink" title="2 Bash 的基本功能"></a>2 Bash 的基本功能</h2><h3 id="2-1-历史命令"><a href="#2-1-历史命令" class="headerlink" title="2.1 历史命令"></a>2.1 历史命令</h3><p>如果在退出前未使用history -w则此次登录的使用的命令没有写入文件<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/3.png"><br>历史命令保存的最大数目<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/4.png"></p><h3 id="2-2-命令别名"><a href="#2-2-命令别名" class="headerlink" title="2.2 命令别名"></a>2.2 命令别名</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/5.png"><br>本次登录有效，重启服务器失效<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/6.png"><br>别名的优先级比命令高，那么命令执行时具体的顺序如下：</p><ol><li>第一顺位执行用绝对路径或相对路径执行的命令。</li><li>第二顺位执行别名。</li><li>第三顺位执行 Bash 的内部命令。</li><li>第四顺位执行按照$PATH 环境变量定义的目录查找顺序找到的第一个命令。<br>为了让这个别名永久生效，可以把别名写入环境变量配置文件<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/7.png"></li></ol><h3 id="2-3-Bash-常用快捷键"><a href="#2-3-Bash-常用快捷键" class="headerlink" title="2.3 Bash 常用快捷键"></a>2.3 Bash 常用快捷键</h3><table><thead><tr><th>快捷键</th><th>作 用</th></tr></thead><tbody><tr><td>ctrl+A</td><td>把光标移动到命令行开头。</td></tr><tr><td>ctrl+E</td><td>把光标移动到命令行结尾。</td></tr><tr><td>ctrl+C</td><td>强制终止当前的命令。</td></tr><tr><td>ctrl+L</td><td>清屏，相当于 clear 命令。</td></tr><tr><td>ctrl+U</td><td>删除或剪切光标之前的命令。我</td></tr><tr><td>ctrl+K</td><td>删除或剪切光标之后的内容。</td></tr><tr><td>ctrl+Y</td><td>粘贴 ctrl+U 或 ctrl+K 剪切的内容。</td></tr><tr><td>ctrl+R</td><td>在历史命令中搜索，按下 ctrl+R 之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索。</td></tr><tr><td>ctrl+D</td><td>退出当前终端。</td></tr><tr><td>ctrl+Z</td><td>暂停，并放入后台。</td></tr><tr><td>ctrl+S</td><td>暂停屏幕输出。</td></tr><tr><td>ctrl+Q</td><td>恢复屏幕输出。</td></tr></tbody></table><h3 id="2-4-输入输出重定向"><a href="#2-4-输入输出重定向" class="headerlink" title="2.4 输入输出重定向"></a>2.4 输入输出重定向</h3><h4 id="2-4-1-Bash-的标准输入输出"><a href="#2-4-1-Bash-的标准输入输出" class="headerlink" title="2.4.1 Bash 的标准输入输出"></a>2.4.1 Bash 的标准输入输出</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/8.png"></p><h4 id="2-4-2-输出重定向"><a href="#2-4-2-输出重定向" class="headerlink" title="2.4.2 输出重定向"></a>2.4.2 输出重定向</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/9.png"></p><h3 id="2-5-统计字数"><a href="#2-5-统计字数" class="headerlink" title="2.5 统计字数"></a>2.5 统计字数</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/10.png"></p><h3 id="2-6-多命令顺序执行"><a href="#2-6-多命令顺序执行" class="headerlink" title="2.6 多命令顺序执行"></a>2.6 多命令顺序执行</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/11.png"></p><h3 id="2-7-管道符"><a href="#2-7-管道符" class="headerlink" title="2.7 管道符"></a>2.7 管道符</h3><p>| 前的命令的结果作为 |后的命令操作的内容<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/12.png"><br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/13.png"></p><h3 id="2-8-Bash-中其他特殊符号"><a href="#2-8-Bash-中其他特殊符号" class="headerlink" title="2.8 Bash 中其他特殊符号"></a>2.8 Bash 中其他特殊符号</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/14.png"><br><strong>小括号和大括号的主要区别在于：</strong></p><ol><li>()执行一串命令时，需要重新开一个子 shell 进行执行</li><li>{}执行一串命令时，是在当前 shell 执行；</li><li>()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开；</li><li>()最后一个命令可以不用分号；</li><li>{}最后一个命令要用分号；</li><li>{}的第一个命令和左括号之间必须要有一个空格；</li><li>()里的各命令不必和括号有空格；</li><li>()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令。</li></ol><h2 id="3-Bash-的变量和运算符"><a href="#3-Bash-的变量和运算符" class="headerlink" title="3 Bash 的变量和运算符"></a>3 Bash 的变量和运算符</h2><h3 id="3-1-什么是变量"><a href="#3-1-什么是变量" class="headerlink" title="3.1 什么是变量"></a>3.1 什么是变量</h3><ol><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头</li><li>在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。</li><li>变量用等号连接值，等号左右两侧不能有空格。</li><li>变量的值如果有空格，需要使用单引号或双引号包括。</li><li>在变量的值中，可以使用“\”转义符。</li><li>如果需要增加变量的值，那么可以进行变量值的叠加。</li><li>如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。</li><li>环境变量名建议大写，便于区分。</li></ol><h3 id="3-2-变量的分类"><a href="#3-2-变量的分类" class="headerlink" title="3.2 变量的分类"></a>3.2 变量的分类</h3><ol><li>用户自定义变量：这种变量是最常见的变量，由用户自由定义变量名和变量的值。</li><li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据，比如当前登录用户，用户的家目录，命令的提示符等。环境变量的变量名可以自由定义，但是一般对系统起作用的环境变量的变量名是系统预先设定好的。</li><li>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</li><li>预定义变量：是 Bash 中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li></ol><h3 id="3-3-用户自定义变量"><a href="#3-3-用户自定义变量" class="headerlink" title="3.3 用户自定义变量"></a>3.3 用户自定义变量</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/15.png"></p><h4 id="3-3-1-变量调用"><a href="#3-3-1-变量调用" class="headerlink" title="3.3.1 变量调用"></a>3.3.1 变量调用</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/16.png"></p><h4 id="3-3-2-变量查看"><a href="#3-3-2-变量查看" class="headerlink" title="3.3.2 变量查看"></a>3.3.2 变量查看</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/17.png"><br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/18.png"><br>set +x/u可以取消set -x/u的功能<br>set查看系统中的所有变量<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/19.png"></p><h4 id="3-3-3-变量删除"><a href="#3-3-3-变量删除" class="headerlink" title="3.3.3 变量删除"></a>3.3.3 变量删除</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/20.png"></p><h3 id="3-4-环境变量"><a href="#3-4-环境变量" class="headerlink" title="3.4 环境变量"></a>3.4 环境变量</h3><h4 id="3-4-1-环境变量设置"><a href="#3-4-1-环境变量设置" class="headerlink" title="3.4.1 环境变量设置"></a>3.4.1 环境变量设置</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/42.png"></p><h4 id="3-4-2-环境变量查询和删除"><a href="#3-4-2-环境变量查询和删除" class="headerlink" title="3.4.2 环境变量查询和删除"></a>3.4.2 环境变量查询和删除</h4><p>env 命令和 set 命令的区别是，set 命令可以查看所有变量，而 env 命令只能查看环境变量。<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/22.png"></p><h3 id="3-5-位置参数变量"><a href="#3-5-位置参数变量" class="headerlink" title="3.5 位置参数变量"></a>3.5 位置参数变量</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/25.png"></p><pre class=" language-shell"><code class="language-shell">#!/bin/bashnum1=$1 #给 num1 变量赋值是第一个参数num2=$2 #给 num2 变量赋值是第二个参数sum=$(( $num1 + $num2)) #变量 sum 的和是 num1 加 num2echo $sum #打印变量 sum 的值echo "A total of $# parameters"  #使用$#代表所有参数的个数echo "The parameters is: $*"  #使用$*代表所有的参数echo "The parameters is: $@"  #使用$@也代表所有参数</code></pre><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/26.png"></p><p>$*和$@的区别<br>$*会把接收的所有参数当成一个整体对待<br>$@会区分对待接收到的所有参数</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashfor i in "$*" do echo "The parameters is: $i" donex=1for y in "$@" do echo "The parameter$x is: $y" x=$(( $x +1 )) done       </code></pre><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/27.png"></p><h3 id="3-6-预定义变量"><a href="#3-6-预定义变量" class="headerlink" title="3.6 预定义变量"></a>3.6 预定义变量</h3><table><thead><tr><th>预定义变量</th><th>作 用</th></tr></thead><tbody><tr><td>$？</td><td>最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。</td></tr><tr><td>$$</td><td>当前进程的进程号（PID）</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的进程号（PID）</td></tr></tbody></table><h3 id="3-7-接收键盘输入"><a href="#3-7-接收键盘输入" class="headerlink" title="3.7 接收键盘输入"></a>3.7 接收键盘输入</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/28.png"><br>变量名：<br>变量名可以自定义，如果不指定变量名，会把输入保存入默认变量 REPLY<br>如果只提供了一个变量名，则整个输入行赋予该变量<br>如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字</p><h3 id="3-8-Shell-的运算符"><a href="#3-8-Shell-的运算符" class="headerlink" title="3.8 Shell 的运算符"></a>3.8 Shell 的运算符</h3><h4 id="3-8-1-数值运算的方法"><a href="#3-8-1-数值运算的方法" class="headerlink" title="3.8.1 数值运算的方法"></a>3.8.1 数值运算的方法</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/29.png"></p><h4 id="3-8-2-使用-expr-或-let-数值运算工具"><a href="#3-8-2-使用-expr-或-let-数值运算工具" class="headerlink" title="3.8.2 使用 expr 或 let 数值运算工具"></a>3.8.2 使用 expr 或 let 数值运算工具</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/30.png"></p><h4 id="3-8-3-使用“-运算式-”或“-运算式-”方式运算"><a href="#3-8-3-使用“-运算式-”或“-运算式-”方式运算" class="headerlink" title="3.8.3 使用“$((运算式))”或“$[运算式]”方式运算"></a>3.8.3 使用“$((运算式))”或“$[运算式]”方式运算</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/31.png"></p><h3 id="3-9-变量的测试与内容置换"><a href="#3-9-变量的测试与内容置换" class="headerlink" title="3.9 变量的测试与内容置换"></a>3.9 变量的测试与内容置换</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/32.png"></p><h2 id="4-环境变量配置文件"><a href="#4-环境变量配置文件" class="headerlink" title="4 环境变量配置文件"></a>4 环境变量配置文件</h2><h3 id="4-1-source-命令"><a href="#4-1-source-命令" class="headerlink" title="4.1 source 命令"></a>4.1 source 命令</h3><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/33.png"></p><h3 id="4-2-环境变量配置文件"><a href="#4-2-环境变量配置文件" class="headerlink" title="4.2 环境变量配置文件"></a>4.2 环境变量配置文件</h3><h4 id="4-2-1-登录时主要生效的环境变量配置文件"><a href="#4-2-1-登录时主要生效的环境变量配置文件" class="headerlink" title="4.2.1 登录时主要生效的环境变量配置文件"></a>4.2.1 登录时主要生效的环境变量配置文件</h4><ol><li>/etc/profile</li><li>/etc/profile.d/*.sh</li><li>~/.bash_profile</li><li>~/.bashrc</li><li>/etc/bashrc</li></ol><p><strong>环境变量配置文件调用过程</strong><br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/34.png"></p><p><strong>用户登录过程先调用/etc/profile文件，在这个环境变量配置文件中会定义如下默认环境变量：</strong></p><ol><li>USER 变量：根据登录的用户，给这个变量赋值（就是让 USER 变量的值是当前用户）。</li><li>LOGNAME 变量：根据 USER 变量的值，给这个变量赋值。</li><li>MAIL 变量：根据登录的用户，定义用户的邮箱为/var/spool/mail/用户名。</li><li>PATH 变量：根据登录用户的 UID 是否为 0，判断 PATH 变量是否包含/sbin、/usr/sbi和/usr/local/sbin 这三个系统命令目录。</li><li>HOSTNAME 变量：更加主机名，给这个变量赋值。</li><li>HISTSIZE 变量：定义历史命令的保存条数。</li><li>umask：定义 umask 默认权限。注意/etc/profile 文件中的 umask 权限是在“有用户登录过程（也就是输入了用户名和密码）”时才会生效。</li><li>调用/etc/profile.d/*.sh 文件，也就是调用/etc/profile.d/目录下所有以.sh 结尾的文件。</li></ol><p><strong>由/etc/profile 文件调用/etc/profile.d/*.sh 文件</strong></p><ol><li>这个目录中所有以.sh 结尾的文件都会被/etc/profile 文件调用，这里最常用的就是 lang.sh 文</li><li>件，而这个文件又会调用/etc/sysconfig/i18n 文件。（默认语系配置文件）</li></ol><p><strong>由/etc/profile 文件调用~/.bash_profile 文件</strong><br>~/.bash_profile 主要实现了两个功能：</p><ol><li>调用了~/.bashrc 文件。</li><li>在 PATH 变量后面加入了“:$HOME/bin”这个目录。那也就是说，如果我们在自己的家目录中建立 bin 目录，然后把自己的脚本放入“~/bin”目录，就可以直接执行脚本，而不用通过目录执行了。</li></ol><p><strong>由<del>/.bash_profile 文件调用</del>/.bashrc 文件</strong><br>在~/.bashrc 文件中主要实现了：</p><ol><li>定义默认别名。</li><li>调用/etc/bashrc</li></ol><p><strong>由~/.bashrc 调用了/etc/bashrc 文件</strong><br>在/etc/bashrc 文件中主要定义了这些内容：</p><ol><li>PS1 变量：也就是用户的提示符，如果我们想要永久修改提示符，就要在这个文件中修改</li><li>umask：定义 umask 默认权限。这个文件中定义的 umask 是针对“没有登录过程（也就是不需要输入用户名和密码时，比如从一个终端切换到另一个终端，或进入子 Shell）”时生效的。如果是“有用户登录过程”，则是/etc/profile 文件中的 umask 生效。</li><li>PATH 变量：会给 PATH 变量追加值，当然也是在“没有登录过程”时才生效。</li><li>调用/etc/profile.d/<em>.sh 文件，这也是在“没有用户登录过程”是才调用。在“有用户登录过  程”时，/etc/profile.d/</em>.sh 文件已经被/etc/profile 文件调用过了。  </li></ol><p>如果修改的配置是打算对所有用户生效的，那么可以放入/etc/profile 环境变量配置文件；如果修改只是给自己使用的，那么可以放入<del>/.bash_profile 或</del>/.bashrc 这两个配置文件中的任一个。<br>可是如果我们误删除了这些环境变量，比如删除了/etc/bashrc 文件，或删除了<del>/.bashrc 文件，那么这些文件中配置就会失效（</del>/.bashrc 文件会调用/etc/bashrc 文件）。</p><h4 id="4-2-2-注销时生效的环境变量配置文件"><a href="#4-2-2-注销时生效的环境变量配置文件" class="headerlink" title="4.2.2 注销时生效的环境变量配置文件"></a>4.2.2 注销时生效的环境变量配置文件</h4><p>在用户退出登录时，只会调用~/.bash_logout环境变量配置文件，这个文件默认没有写入任何内容，可是如果我们希望再退出登录时执行一些操作，比如清除历史命令，备份某些数据，就可以把命令写入这个文件。</p><h3 id="4-3-Shell-登录信息"><a href="#4-3-Shell-登录信息" class="headerlink" title="4.3 Shell 登录信息"></a>4.3 Shell 登录信息</h3><h4 id="4-3-1-etc-issue"><a href="#4-3-1-etc-issue" class="headerlink" title="4.3.1 /etc/issue"></a>4.3.1 /etc/issue</h4><p>我们在登录 tty1-tty6 这六个本地终端时，会有几行的欢迎界面。这些欢迎信息是保存/etc/issue<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/35.png"></p><h4 id="4-3-2-etc-issue-net"><a href="#4-3-2-etc-issue-net" class="headerlink" title="4.3.2 /etc/issue.net"></a>4.3.2 /etc/issue.net</h4><p>远程登录（如 ssh 远程登录，或 telnet远程登录）需要显示欢迎信息，则需要配置/etc/issue.net 这个文件了。<br>如果我们需要 ssh 远程登录可以查看/etc/issue.net 的欢迎信息，那么首先需要修改 ssh 的配置文件/etc/ssh/sshd_config，加入如下内容：<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/36.png"><br>修改前（重启才生效）<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/39.png"><br>修改后<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/37.png"></p><h4 id="4-3-3-etc-motd"><a href="#4-3-3-etc-motd" class="headerlink" title="4.3.3 /etc/motd"></a>4.3.3 /etc/motd</h4><p>在用户输入用户名和密码，正确登录之后显示欢迎信息。在/etc/motd 文件中的欢迎信息，不论是本地登录，还是远程登录都可以显示。</p><h4 id="4-4-4-定义-Bash-快捷键"><a href="#4-4-4-定义-Bash-快捷键" class="headerlink" title="4.4 4 定义 Bash 快捷键"></a>4.4 4 定义 Bash 快捷键</h4><p><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/38.png"><br>更改快捷键<br><img src="/2022/01/13/shell%E5%9F%BA%E7%A1%80/40.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索式测试</title>
      <link href="/2022/01/11/%E6%8E%A2%E7%B4%A2%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/01/11/%E6%8E%A2%E7%B4%A2%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是探索式测试（ET-Exploratory-Testing）"><a href="#1-什么是探索式测试（ET-Exploratory-Testing）" class="headerlink" title="1 什么是探索式测试（ET Exploratory Testing）"></a>1 什么是探索式测试（ET Exploratory Testing）</h2><ol><li>探索式测试一种软件测试风格，而不是一种具体的软件测试技术（如等价类划分、边界值分析、组合测试等）</li><li>探索式测试强调依据当前待测项目实际情况，选择合适的测试技术，而不局限于特定的测试技术</li></ol><h2 id="2-探索式测试的核心思想"><a href="#2-探索式测试的核心思想" class="headerlink" title="2 探索式测试的核心思想"></a>2 探索式测试的核心思想</h2><ol><li>探索式测试强调独立测试人员的自由和责任。测试人员应该为个人和团队负责，调动所有能量，发挥人的灵活性，在整体上持续优化个人和团队的产出</li><li>探索式测试建议在整个项目过程中，将测试相关学习、测试设计、测试执行和测试结果分析作为相互支持的活动，并行地执行。实际上。人脑难以并行地执行多项任务。探索式测试旨在将测试学习、测试设计、测试执行和测试结果分析作为一个循环快速地迭代，以不断收集反馈、调整测试、优化价值。</li></ol><h2 id="3-什么样的项目适合做探索测试"><a href="#3-什么样的项目适合做探索测试" class="headerlink" title="3 什么样的项目适合做探索测试"></a>3 什么样的项目适合做探索测试</h2><ol><li>SRS（software requirements specification）不完善，时间紧迫，没有测试用例的情况下，以ET快速完成版本新功能的测试<br><strong>作用：</strong>更快设计、更快执行、更低成本</li><li>系统测试之后，时间允许的情况下，以ET作为补充，尝试系统测试覆盖不到的场景（测试计划估计时间不准会导致项目延迟上线，不可取）<br><strong>作用：</strong>减少漏测，提高覆盖</li></ol><p><strong>前提：</strong><br>团队对产品功能比较熟悉<br>已经可以允许的待测软件（一般是项目迭代）</p><h2 id="4-探索式测试在项目中如何落地"><a href="#4-探索式测试在项目中如何落地" class="headerlink" title="4 探索式测试在项目中如何落地"></a>4 探索式测试在项目中如何落地</h2><ol><li>快速学习需求：基于对软件版本的熟悉，对新版本功能快速学习，提出问题并进行澄清</li><li>作出计划：时间，范围，团队分工等<br><img src="/2022/01/11/%E6%8E%A2%E7%B4%A2%E5%BC%8F%E6%B5%8B%E8%AF%95/1.png"></li><li>利用脑图，列出哪些模块，覆盖哪些场景，每个场景的注意事项然后进行评审</li><li>探索：按照脑图，执行探索的过程中，跟进情况，逐步深挖（也是边执行边学习的过程）每条path，甘心并记录执行探索过程中走过的path（带着反思去执行测试）</li><li>提交缺陷：把探索式过程中发现的缺陷提交到缺陷管理系统中，修复后回归</li><li>提交报告总结：已简单的表格，对bug的分布，数量，级别，进行统计和报告<br><img src="/2022/01/11/%E6%8E%A2%E7%B4%A2%E5%BC%8F%E6%B5%8B%E8%AF%95/2.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 探索式测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础（二）用户管理</title>
      <link href="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-用户相关文件"><a href="#1-用户相关文件" class="headerlink" title="1 用户相关文件"></a>1 用户相关文件</h2><h3 id="1-1-etc-passwd-用户信息文件"><a href="#1-1-etc-passwd-用户信息文件" class="headerlink" title="1.1 /etc/passwd 用户信息文件"></a>1.1 /etc/passwd 用户信息文件</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/1.png"></p><ul><li>第一列： 用户名</li><li>第二列： 密码位</li><li>第三列： 用户 ID <ul><li>0 超级用户 UID。如果用户 UID 为 0，代表这个账号是管理员账号。<br>如何把普通用户升级成为管理员呢？就是把其他用户的 UID 修改为 0 就可以了。</li><li>1-499 系统用户（伪用户）UID。这些 UID 账号是系统保留给系统用户的 UID，UID 是 1-499 范围内的用户是不能登录系统的，而是用来运行系统或服务的。其中<br> 1-99 是系统保留的账号，系统自动创建。<br> 100-499是预留给用户创建系统账号的。<br> 500-60000 普通用户 UID。建立的普通用户 UID 从 500 开始，最大到 60000。这些用<br> 户足够使用了，但是如果不够也不用害怕，2.6.x 内核以后的 Linux 系统用户 UID 已经<br>可以支持 2的32次方这么多了。</li></ul></li><li>第四列：组 ID GID 添加用户时，如果不指定用户所属的初始组，那么会建立和用户名相<br>同的组</li><li>第五列： 用户说明</li><li>第六列： 用户家目录 ~</li><li>第七列： 登录 shell /bin/bash</li></ul><h3 id="1-2-etc-shadow-影子文件"><a href="#1-2-etc-shadow-影子文件" class="headerlink" title="1.2 /etc/shadow 影子文件"></a>1.2 /etc/shadow 影子文件</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/2.png"></p><ul><li>第一列： 用户名</li><li>第二列： 加密密码<br>我们也可以在密码前人为的加入“！”或“<em>”改变加密值让密码暂时失效，使这个用<br>户无法登陆，达到暂时禁止用户登录的效果。注意所有伪用户的密码都是“！！”或“</em>”，代表没有密码是不能登录的。当然我新创建的用户如果不设定密码，它的密码项也是“！！”，代表这个用户没有密码，不能登录</li><li>第三列： 密码最近更改时间, 1970 年 1 月 1 日作为标准时间</li><li>第四列： 两次密码的修改间隔时间（和第 3 字段相比）</li><li>第五例： 密码有效期（和第 3 字段相比）</li><li>第六列： 密码修改到期前的警告天数（和第 5 字段相比）</li><li>第七列： 密码过期后的宽限天数（和第 5 字段相比）</li><li>第八列： 密码失效时间<br>  如果超过了失效时间，就算密码没有过期，用户也就失效无法使用了</li><li>第九列： 保留</li></ul><h3 id="1-3-etc-group-组信息文件"><a href="#1-3-etc-group-组信息文件" class="headerlink" title="1.3 /etc/group 组信息文件"></a>1.3 /etc/group 组信息文件</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/3.png"></p><ul><li>第一列： 组名</li><li>第二列： 组密码位</li><li>第三列： GID</li><li>第四列： 此组中支持的其他用户.附加组是此组的用户<br>初始组：每个用户初始组只能有一个，初始组只能有一个，一般都是和用户名相同的组作为初始组<br>附加组：每个用户可以属于多个附加组。要把用户加入组，都是加入附加组</li></ul><h3 id="1-4-etc-gshadow-组密码文件"><a href="#1-4-etc-gshadow-组密码文件" class="headerlink" title="1.4 /etc/gshadow 组密码文件"></a>1.4 /etc/gshadow 组密码文件</h3><p>如果我给用户组设定了组管理员，并给该用户组设定了组密码，组密码就保存在这个文件当中。<br>组管理员就可以利用这个密码管理这个用户组了。</p><h3 id="1-5-用户的家目录"><a href="#1-5-用户的家目录" class="headerlink" title="1.5 用户的家目录"></a>1.5 用户的家目录</h3><p>超级用户/root<br>普通用户/home/用户名</p><h3 id="1-6-var-spool-mail-用户邮箱目录"><a href="#1-6-var-spool-mail-用户邮箱目录" class="headerlink" title="1.6 /var/spool/mail 用户邮箱目录"></a>1.6 /var/spool/mail 用户邮箱目录</h3><p>例如 user1 用户的邮箱就是/var/spool/mail/user1 文<br><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/4.png"></p><h3 id="1-7-用户模板目录-etc-skel"><a href="#1-7-用户模板目录-etc-skel" class="headerlink" title="1.7 用户模板目录  /etc/skel/"></a>1.7 用户模板目录  /etc/skel/</h3><p>用户的模板目录的位置，/etc/skel/目录中的文件都会复制到新建用户的家目录当中。<br><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/20.png"><br><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/21.png"></p><h2 id="2-用户管理命令"><a href="#2-用户管理命令" class="headerlink" title="2 用户管理命令"></a>2 用户管理命令</h2><h3 id="2-1-添加用户"><a href="#2-1-添加用户" class="headerlink" title="2.1 添加用户"></a>2.1 添加用户</h3><ol><li><p>手工删除用户<br> 手工删除用户试验：手工删除，如果可以正常建立用户，证明用户删除干净。<br> /etc/passwd<br> /etc/shadow<br> /etc/group<br> /etc/gshadow<br> /home/user1<br> /var/spool/mail/user1 </p></li><li><p>useradd 命令<br> useradd 选项 用户名<br> 选项：<br> -u 550 指定 UID<br> -g 组名 指定初始组 不要手工指定<br> -G 组名 指定附加组，把用户加入组，使用附加组<br> -c 说明 添加说明<br> -d 目录 手工指定家目录，目录不需要事先建立<br> -s shell /bin/bash.</p><p> 先手工添加 lamp1 用户组，因为我一会要把 lamp1 用户的初始组指定过来，如果不事先建立，会报错用户组不存在</p><pre class=" language-bash"><code class="language-bash"><span class="token function">groupadd</span> lamp1</code></pre><p> 建立用户 lamp1 的同时指定了 UID（550），初始组（lamp1），附加组（root），家目录（/home/lamp1），用户说明(test user)和用户登录 shell（/bin/bash）</p><pre class=" language-bash"><code class="language-bash"><span class="token function">useradd</span> -u 550 -g lamp1 -G root -d /home/lamp1 -c <span class="token string">"test user"</span> -s /bin/bash lamp1</code></pre><p> 同时查看三个文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"lamp1"</span> /etc/passwd /etc/shadow /etc/group</code></pre><p> <img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/5.png"></p><p> 查看家目录</p><pre class=" language-bash"><code class="language-bash">ll -d /home/lamp1/</code></pre><p> <img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/6.png"></p></li></ol><ol start="3"><li>useradd 默认值<br> useradd 添加用户时参考的默认值文件主要有两个 ， 分别是 /etc/default/useradd 和/etc/login.defs<ul><li>/etc/default/useradd<br>  <img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/7.png"><ul><li>GROUP=100<br>这个选项是建立用户的默认组，也就是说添加每个用户时，用户的初始组就是 GID 为 100 的这个<br>用户组。目前我们采用的机制私有用户组机制。</li><li>HOME=/home<br>这个选项是用户的家目录的默认位置，所以所有的新建用户的家目录默认都在/home/下。</li><li>INACTIVE=-1<br>这个选项就是密码过期后的宽限天数，也就是/etc/shadow 文件的第七个字段。如果是天数，比<br>如10 代表密码过期后10 天后失效；如果是 0，代表密码过期后立即失效；如果是-1，则代表密码永<br>远不会失效。这里默认值是-1，所以所有新建立的用户密码都不会失效。</li><li>EXPIRE=<br>这个选项是密码失效时间，也就是/etc/shadow 文件的第八个字段。也就说用户到达这个日期后<br>就会直接失效。当然这里也是使用时间戳来表示日期的。默认值是空，所以所有新建用户没有失效时<br>间，永久有效。</li><li>SHELL=/bin/bash<br>这个选项是用户的默认shell 的。/bin/bash 是 Linux 的标志 shell，所以所有新建立的用户默<br>认都具备 shell 赋予的权限。</li><li>SKEL=/etc/skel<br>这个选项就是定义用户的模板目录的位置，/etc/skel/目录中的文件都会复制到新建用户的家目<br>录当中。</li><li>CREATE_MAIL_SPOOL=yes<br>这个选项定义是否给新建用户建立邮箱，默认是创建，也就是说所有的新建用户系统都会新建一<br>个邮箱，放在/var/spool/mail/下和用户名相同。</li></ul></li><li>/etc/login.defs<br><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/8.png"><ul><li>MAIL_DIR /var/spool/mail<br> 这行指定了新建用户的默认邮箱位置。比如 user1 用户的邮箱是就是/var/spool/mail/user1。</li><li>PASS_MAX_DAYS 99999<br>这行指定的是密码的有效期，也就是/etc/shadow 文件的第五字段。代表多少天之后必须修改密<br>码，默认值是 99999。</li><li>PASS_MIN_DAYS 0<br>这行指定的是两次密码的修改间隔时间，也就是/etc/shadow 文件的第四字段。代表第一次修改<br>密码之后，几天后才能再次修改密码。默认值是 0。</li><li>PASS_MIN_LEN 5<br>这行代表密码的最小长度，默认不小于 5 位。但是我们现在用户登录时验证已经被 PAM 模块取代，<br>所以这个选项并不生效。</li><li>PASS_WARN_AGE 7<br>这行代表密码修改到期前的警告天数，也就是/etc/shadow 文件的第六字段。代表密码到底有效<br>期前多少天开始进行警告提醒，默认值是 7 天。</li><li>UID_MIN 500</li><li>UID_MAX 60000<br>这两行代表创建用户时，最小 UID 和最大的 UID 的范围。如果我手工指定了一个用户的UID 是 550，那么下一个创建的用户的 UID 就会从 551 开始，哪怕 500-549 之间的 UID 没有使用（小于 500 的 UID 是给伪用户预留的）。</li><li>GID_MIN 500</li><li>GID_MAX 60000<br>这两行指定了 GID 的最小值和最大值之间的范围。</li><li>CREATE_HOME yes<br>这行指定建立用户时是否自动建立用户的家目录，默认是建立</li><li>UMASK 077<br>这行指定的是建立的用户家目录的默认权限，因为 umask 值是 077，所以新建的用户家目录的权<br>限是 700。</li><li>USERGROUPS_ENAB yes<br>这行指定的是使用命令 userdel 删除用户时，是否删除用户的初始组，默认是删除。</li><li>ENCRYPT_METHOD SHA512<br>这行指定 Linux 用户的密码使用 SHA512 散列模式加密，这是新的密码加密模式，原先的 Linux<br>只能用 DES 或 MD5 方式加密</li></ul></li></ul></li></ol><h3 id="2-2-设定密码"><a href="#2-2-设定密码" class="headerlink" title="2.2 设定密码"></a>2.2 设定密码</h3><p>  <img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/9.png"><br>  使用字符串作为密码<br>  <img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/10.png"><br>  把密码修改日期归零（shadow 第 3 字段）.这样用户一登陆就要修改密码<br>  <img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/11.png"></p><h3 id="2-3-用户信息修改"><a href="#2-3-用户信息修改" class="headerlink" title="2.3 用户信息修改"></a>2.3 用户信息修改</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/12.png"><br>修改用户名，但是不建议。建议删除后在新建。因为用户太多自己会分不清楚<br><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/13.png"></p><h3 id="2-4-删除用户"><a href="#2-4-删除用户" class="headerlink" title="2.4 删除用户"></a>2.4 删除用户</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/14.png"></p><h3 id="2-5-切换用户身份"><a href="#2-5-切换用户身份" class="headerlink" title="2.5 切换用户身份"></a>2.5 切换用户身份</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/15.png"></p><h2 id="3-组管理命令"><a href="#3-组管理命令" class="headerlink" title="3 组管理命令"></a>3 组管理命令</h2><h3 id="3-1-添加用户组：groupadd"><a href="#3-1-添加用户组：groupadd" class="headerlink" title="3.1 添加用户组：groupadd"></a>3.1 添加用户组：groupadd</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/16.png"></p><h3 id="3-2-删除用户组：groupdel"><a href="#3-2-删除用户组：groupdel" class="headerlink" title="3.2 删除用户组：groupdel"></a>3.2 删除用户组：groupdel</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/17.png"></p><h3 id="3-3-把用户添加进组或从组中删除：gpasswd"><a href="#3-3-把用户添加进组或从组中删除：gpasswd" class="headerlink" title="3.3 把用户添加进组或从组中删除：gpasswd"></a>3.3 把用户添加进组或从组中删除：gpasswd</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/18.png"><br>“usermod -G grouptest user1”，把用户名作为参数放在最后<br>“gpasswd -a user1 grouptest，把组名作为参数放在最后。</p><h3 id="3-4-改变有效组：newgrp"><a href="#3-4-改变有效组：newgrp" class="headerlink" title="3.4 改变有效组：newgrp"></a>3.4 改变有效组：newgrp</h3><p><img src="/2022/01/11/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/19.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础（一）常用命令</title>
      <link href="/2022/01/07/Linux/"/>
      <url>/2022/01/07/Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="1-目录操作命令"><a href="#1-目录操作命令" class="headerlink" title="1. 目录操作命令"></a>1. 目录操作命令</h2><h3 id="1-1-ls"><a href="#1-1-ls" class="headerlink" title="1.1 ls"></a>1.1 ls</h3><p>显示目录下的内容。<br><img src="/2022/01/07/Linux/1.png"><br><img src="/2022/01/07/Linux/2.png"></p><ul><li>第一列：权限。</li><li>第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</li><li>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户</li><li>第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li><li> 第五列：大小。默认单位是字节。</li><li>第六列：文件修改时间。文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li><li>第七列：文件名。</li></ul><h3 id="1-2-cd"><a href="#1-2-cd" class="headerlink" title="1.2 cd"></a>1.2 cd</h3><p>切换所在目录的命令<br><img src="/2022/01/07/Linux/3.png"></p><h3 id="1-3-pwd"><a href="#1-3-pwd" class="headerlink" title="1.3 pwd"></a>1.3 pwd</h3><p>查询所在目录的命令</p><h3 id="1-4-mkdir"><a href="#1-4-mkdir" class="headerlink" title="1.4 mkdir"></a>1.4 mkdir</h3><p>创建目录的命令<br><img src="/2022/01/07/Linux/4.png"></p><h3 id="1-5-rmdir"><a href="#1-5-rmdir" class="headerlink" title="1.5 rmdir"></a>1.5 rmdir</h3><p>删除空目录的命令<br> <img src="/2022/01/07/Linux/5.png"></p><h2 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2. 文件操作命令"></a>2. 文件操作命令</h2><h3 id="2-1-touch"><a href="#2-1-touch" class="headerlink" title="2.1 touch"></a>2.1 touch</h3><p>创建空文件或修改文件时间</p><h3 id="2-2-stat"><a href="#2-2-stat" class="headerlink" title="2.2 stat"></a>2.2 stat</h3><p>查看文件详细信息<br><img src="/2022/01/07/Linux/6.png"></p><h3 id="2-3-cat"><a href="#2-3-cat" class="headerlink" title="2.3 cat"></a>2.3 cat</h3><p>查看文件内容<br><img src="/2022/01/07/Linux/7.png"></p><h3 id="2-4-more"><a href="#2-4-more" class="headerlink" title="2.4 more"></a>2.4 more</h3><p>分屏显示文件</p><ul><li>空格键：向下翻页。</li><li>b：向上翻页。</li><li>回车键：向下滚动一行。</li><li>/字符串：搜索指定的字符串。</li><li>q：退出。</li></ul><h3 id="2-5-less"><a href="#2-5-less" class="headerlink" title="2.5 less"></a>2.5 less</h3><p>分行显示文件</p><h3 id="2-6-head"><a href="#2-6-head" class="headerlink" title="2.6 head"></a>2.6 head</h3><p>显示文件开头<br><img src="/2022/01/07/Linux/8.png"></p><h3 id="2-7-tail"><a href="#2-7-tail" class="headerlink" title="2.7 tail"></a>2.7 tail</h3><p>显示文件结尾<br><img src="/2022/01/07/Linux/9.png"></p><h3 id="2-8-ln"><a href="#2-8-ln" class="headerlink" title="2.8 ln"></a>2.8 ln</h3><p>在文件之间建立链接<br><img src="/2022/01/07/Linux/10.png"><br>创建硬链接</p><ul><li>源文件和硬链接文件拥有相同的 Inode 和 Block</li><li>修改任意一个文件，另一个都改变</li><li>删除任意一个文件，另一个都能使用</li><li>硬链接标记不清，很难确认硬链接文件位置，不建议使用</li><li>硬链接不能链接目录</li><li>硬链接不能跨分区<br><img src="/2022/01/07/Linux/11.png"><br>创建软链接</li><li>软链接和源文件拥有不同的 Inode 和 Block</li><li>两个文件修改任意一个，另一个都改变</li><li>删除软链接，源文件不受影响；删除源文件，软链接不能使用</li><li>软链接没有实际数据，只保存源文件的 Inode，不论源文件多大，软链接大小不变</li><li>软链接的权限是最大权限 lrwxrwxrwx.，但是由于没有实际数据，最终访问时需要参考源文件权限</li><li>软链接可以链接目录</li><li>软链接可以跨分区</li><li>软链接特征明显，建议使用软连接<br><img src="/2022/01/07/Linux/12.png"></li></ul><h2 id="3-目录和文件都能操作的命令"><a href="#3-目录和文件都能操作的命令" class="headerlink" title="3. 目录和文件都能操作的命令"></a>3. 目录和文件都能操作的命令</h2><h3 id="3-1-rm"><a href="#3-1-rm" class="headerlink" title="3.1 rm"></a>3.1 rm</h3><p>删除文件或目录<br><img src="/2022/01/07/Linux/13.png"></p><h3 id="3-2-cp"><a href="#3-2-cp" class="headerlink" title="3.2 cp"></a>3.2 cp</h3><p>复制文件和目录<br><img src="/2022/01/07/Linux/14.png"></p><h3 id="3-3-mv"><a href="#3-3-mv" class="headerlink" title="3.3 mv"></a>3.3 mv</h3><p>移动文件或改名<br><img src="/2022/01/07/Linux/15.png"></p><h2 id="4-基本权限管理"><a href="#4-基本权限管理" class="headerlink" title="4. 基本权限管理"></a>4. 基本权限管理</h2><h3 id="4-1-权限的介绍"><a href="#4-1-权限的介绍" class="headerlink" title="4.1 权限的介绍"></a>4.1 权限的介绍</h3><p><img src="/2022/01/07/Linux/16.png"></p><ul><li>第 1 位代表文件类型<ul><li>“-”：普通文件。</li><li>“b”：块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件/dev/sda1就是这种文件。</li><li>“c”：字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等。</li><li>“d”：目录文件。Linux 中一切皆文件，所以目录也是文件的一种。</li><li>“l”：软链接文件。</li><li>“p”：管道符文件。这是一种非常少见的特殊设备文件。</li><li>“s”：套接字文件。这也是一种特殊设备文件，一些服务支持 Socket 访问，就会产生这样的文件。</li></ul></li><li>第 2～4 位代表文件所有者的权限。<ul><li>r：代表 read，是读取权限。</li><li>w：代表 write，是写权限。</li><li>x：代表 execute，是执行权限。<br>如果有字母，则代表拥有对应的权限；如果是“-”，则代表没有对应的权限。</li></ul></li><li>第 5～7 位代表文件所属组的权限，同样拥有“rwx”权限。</li><li>第 8～10 位代表其他人的权限，同样拥有“rwx”权限。</li></ul><h3 id="4-2-基本权限命令"><a href="#4-2-基本权限命令" class="headerlink" title="4.2 基本权限命令"></a>4.2 基本权限命令</h3><h4 id="4-2-1-chmod"><a href="#4-2-1-chmod" class="headerlink" title="4.2.1 chmod"></a>4.2.1 chmod</h4><p>修改文件的权限模式<br><img src="/2022/01/07/Linux/17.png"></p><h3 id="4-3-所有者和所属组"><a href="#4-3-所有者和所属组" class="headerlink" title="4.3 所有者和所属组"></a>4.3 所有者和所属组</h3><h4 id="4-3-1-chown"><a href="#4-3-1-chown" class="headerlink" title="4.3.1 chown"></a>4.3.1 chown</h4><p>修改文件和目录的所有者和所属组</p><p> <img src="/2022/01/07/Linux/19.png"></p><h4 id="4-3-2-chgrp"><a href="#4-3-2-chgrp" class="headerlink" title="4.3.2 chgrp"></a>4.3.2 chgrp</h4><p>修改文件和目录的所属组</p><h3 id="4-4-umask-默认权限"><a href="#4-4-umask-默认权限" class="headerlink" title="4.4 umask 默认权限"></a>4.4 umask 默认权限</h3><h4 id="4-4-1-查看系统的-umask-权限"><a href="#4-4-1-查看系统的-umask-权限" class="headerlink" title="4.4.1 查看系统的 umask 权限"></a>4.4.1 查看系统的 umask 权限</h4><p><img src="/2022/01/07/Linux/20.png"><br><img src="/2022/01/07/Linux/21.png"></p><h2 id="5-帮助命令"><a href="#5-帮助命令" class="headerlink" title="5 帮助命令"></a>5 帮助命令</h2><h3 id="5-1-man"><a href="#5-1-man" class="headerlink" title="5.1 man"></a>5.1 man</h3><p><img src="/2022/01/07/Linux/22.png"></p><h3 id="5-2-info"><a href="#5-2-info" class="headerlink" title="5.2 info"></a>5.2 info</h3><p>帮助信息是一套完整的资料</p><h3 id="5-3-help"><a href="#5-3-help" class="headerlink" title="5.3 help"></a>5.3 help</h3><p>只能获取 Shell 内置命令的帮助。可以使用 type 命令来区分内置命令与外部命令</p><ul><li>所在路径：Shell 内置命令。</li></ul><h3 id="5-4-–help"><a href="#5-4-–help" class="headerlink" title="5.4 –help"></a>5.4 –help</h3><p><img src="/2022/01/07/Linux/23.png"></p><h2 id="6-搜索命令"><a href="#6-搜索命令" class="headerlink" title="6. 搜索命令"></a>6. 搜索命令</h2><h3 id="6-1-whereis"><a href="#6-1-whereis" class="headerlink" title="6.1 whereis"></a>6.1 whereis</h3><p>搜索系统命令的命令</p><h3 id="6-2-which"><a href="#6-2-which" class="headerlink" title="6.2 which"></a>6.2 which</h3><p>列出命令的所在路径</p><h3 id="6-3-locate"><a href="#6-3-locate" class="headerlink" title="6.3 locate"></a>6.3 locate</h3><p>按照文件名搜索文件<br><img src="/2022/01/07/Linux/24.png"></p><h3 id="6-4-find"><a href="#6-4-find" class="headerlink" title="6.4 find"></a>6.4 find</h3><p>在目录中搜索文件</p><h4 id="6-4-1-按照文件名搜索"><a href="#6-4-1-按照文件名搜索" class="headerlink" title="6.4.1 按照文件名搜索"></a>6.4.1 按照文件名搜索</h4><p><img src="/2022/01/07/Linux/25.png"></p><h4 id="6-4-2-按照文件大小搜索"><a href="#6-4-2-按照文件大小搜索" class="headerlink" title="6.4.2 按照文件大小搜索"></a>6.4.2 按照文件大小搜索</h4><p><img src="/2022/01/07/Linux/26.png"></p><h4 id="6-4-3-按照修改时间搜索"><a href="#6-4-3-按照修改时间搜索" class="headerlink" title="6.4.3 按照修改时间搜索"></a>6.4.3 按照修改时间搜索</h4><p><img src="/2022/01/07/Linux/27.png"><br><img src="/2022/01/07/Linux/28.png"></p><h4 id="6-4-4-按照权限搜索"><a href="#6-4-4-按照权限搜索" class="headerlink" title="6.4.4 按照权限搜索"></a>6.4.4 按照权限搜索</h4><p><img src="/2022/01/07/Linux/29.png"></p><h4 id="6-4-5-按照所有者和所属组搜索"><a href="#6-4-5-按照所有者和所属组搜索" class="headerlink" title="6.4.5 按照所有者和所属组搜索"></a>6.4.5 按照所有者和所属组搜索</h4><p><img src="/2022/01/07/Linux/30.png"></p><h4 id="6-4-6-按照文件类型搜索"><a href="#6-4-6-按照文件类型搜索" class="headerlink" title="6.4.6 按照文件类型搜索"></a>6.4.6 按照文件类型搜索</h4><p><img src="/2022/01/07/Linux/31.png"></p><h4 id="6-4-7-逻辑运算符"><a href="#6-4-7-逻辑运算符" class="headerlink" title="6.4.7 逻辑运算符"></a>6.4.7 逻辑运算符</h4><p><img src="/2022/01/07/Linux/32.png"><br><img src="/2022/01/07/Linux/33.png"><br><img src="/2022/01/07/Linux/34.png"></p><h4 id="6-4-8-其他选项"><a href="#6-4-8-其他选项" class="headerlink" title="6.4.8 其他选项"></a>6.4.8 其他选项</h4><p><img src="/2022/01/07/Linux/35.png"></p><h3 id="6-5-grep"><a href="#6-5-grep" class="headerlink" title="6.5 grep"></a>6.5 grep</h3><p>在文件中提取和匹配符合条件的字符串行<br><img src="/2022/01/07/Linux/36.png"><br><img src="/2022/01/07/Linux/37.png"><br>find 命令和 grep 命令的区别：</p><ol><li>find<br> find 命令用于在系统中搜索符合条件的文件名，如果需要模糊查询，则使用通配符进行匹配，通配符是完全匹配（find 命令可以通过-regex 选项，把匹配规则转为正则表达式规则，但是不建议如此）。</li><li>grep<br>grep 命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式进行匹配，正则表达式是包含匹配。<br><img src="/2022/01/07/Linux/38.png"><br><img src="/2022/01/07/Linux/39.png"></li></ol><p><strong>示例：</strong><br><strong>查找包含”123”</strong><br><img src="/2022/01/07/Linux/83.png"><br><strong>显示在源文件中的行号</strong><br><img src="/2022/01/07/Linux/84.png"><br><strong>显示不包含”123”的</strong><br><img src="/2022/01/07/Linux/85.png"><br><strong>匹配a0次货任意多次</strong><br><img src="/2022/01/07/Linux/86.png"><br><strong>?的使用，shell认为？是扩展正则，所以必须使用egrep命令</strong><br>无效果<br><img src="/2022/01/07/Linux/87.png"><br>有效果（包含匹配）<br><img src="/2022/01/07/Linux/88.png"><br><img src="/2022/01/07/Linux/89.png"><br><strong>以数字结尾</strong><br><img src="/2022/01/07/Linux/90.png"></p><h2 id="7-管道符"><a href="#7-管道符" class="headerlink" title="7 管道符"></a>7 管道符</h2><p><img src="/2022/01/07/Linux/40.png"><br><img src="/2022/01/07/Linux/41.png"></p><h2 id="8-命令的别名"><a href="#8-命令的别名" class="headerlink" title="8 命令的别名"></a>8 命令的别名</h2><p><img src="/2022/01/07/Linux/42.png"></p><h2 id="9-常用快捷键"><a href="#9-常用快捷键" class="headerlink" title="9. 常用快捷键"></a>9. 常用快捷键</h2><p><img src="/2022/01/07/Linux/43.png"></p><h2 id="10-压缩和解压缩命令"><a href="#10-压缩和解压缩命令" class="headerlink" title="10 压缩和解压缩命令"></a>10 压缩和解压缩命令</h2><h3 id="10-1-“-zip”格式"><a href="#10-1-“-zip”格式" class="headerlink" title="10.1 “.zip”格式"></a>10.1 “.zip”格式</h3><p>压缩文件或目录<br><img src="/2022/01/07/Linux/44.png"><br>列表、测试和提取压缩文件中的文件<br><img src="/2022/01/07/Linux/45.png"></p><h3 id="10-2-“-gz”格式（不会打包）"><a href="#10-2-“-gz”格式（不会打包）" class="headerlink" title="10.2 “.gz”格式（不会打包）"></a>10.2 “.gz”格式（不会打包）</h3><p>压缩文件或目录<br><img src="/2022/01/07/Linux/46.png"><br><img src="/2022/01/07/Linux/47.png"><br>解压缩文件或目录<br><img src="/2022/01/07/Linux/48.png"></p><h3 id="10-3-“-bz2”格式（不能压缩目录）"><a href="#10-3-“-bz2”格式（不能压缩目录）" class="headerlink" title="10.3 “.bz2”格式（不能压缩目录）"></a>10.3 “.bz2”格式（不能压缩目录）</h3><p>.bz2 格式的压缩<br><img src="/2022/01/07/Linux/49.png"><br>.bz2 格式的解压缩<br><img src="/2022/01/07/Linux/50.png"></p><h3 id="10-4-tar（打包不会压缩）"><a href="#10-4-tar（打包不会压缩）" class="headerlink" title="10.4 tar（打包不会压缩）"></a>10.4 tar（打包不会压缩）</h3><p>打包<br><img src="/2022/01/07/Linux/51.png"><br>解打包<br><img src="/2022/01/07/Linux/52.png"><br><img src="/2022/01/07/Linux/53.png"></p><h3 id="10-5-“-tar-gz”和“-tar-bz2”格式"><a href="#10-5-“-tar-gz”和“-tar-bz2”格式" class="headerlink" title="10.5 “.tar.gz”和“.tar.bz2”格式"></a>10.5 “.tar.gz”和“.tar.bz2”格式</h3><p>tar 命令直接打包压缩<br><img src="/2022/01/07/Linux/54.png"></p><h2 id="11-关机和重启命令"><a href="#11-关机和重启命令" class="headerlink" title="11 关机和重启命令"></a>11 关机和重启命令</h2><h3 id="11-1-sync-数据同步"><a href="#11-1-sync-数据同步" class="headerlink" title="11.1 sync 数据同步"></a>11.1 sync 数据同步</h3><p>刷新文件系统缓冲区。</p><h3 id="11-2-shutdown-命令"><a href="#11-2-shutdown-命令" class="headerlink" title="11.2 shutdown 命令"></a>11.2 shutdown 命令</h3><p>关机和重启<br><img src="/2022/01/07/Linux/55.png"></p><h3 id="11-3-reboot-命令"><a href="#11-3-reboot-命令" class="headerlink" title="11.3 reboot 命令"></a>11.3 reboot 命令</h3><p>reboot 命令是安全的<br><img src="/2022/01/07/Linux/56.png"></p><h3 id="11-4-halt，poweroff"><a href="#11-4-halt，poweroff" class="headerlink" title="11.4 halt，poweroff"></a>11.4 halt，poweroff</h3><p>关机命令，直接执行即可。这两个命令不会完整关闭和保存系统的服务，不建议使用。<br><img src="/2022/01/07/Linux/57.png"></p><h3 id="11-5-init"><a href="#11-5-init" class="headerlink" title="11.5 init"></a>11.5 init</h3><p>init 是修改 Linux 运行级别的命令，也可以用于关机和重启。这个命令并不安全，不建议使用<br><img src="/2022/01/07/Linux/58.png"><br><img src="/2022/01/07/Linux/59.png"></p><h2 id="12-常用网络命令"><a href="#12-常用网络命令" class="headerlink" title="12 常用网络命令"></a>12 常用网络命令</h2><h3 id="12-1-配置-IP-地址"><a href="#12-1-配置-IP-地址" class="headerlink" title="12.1 配置 IP 地址"></a>12.1 配置 IP 地址</h3><ol><li>配置 IP 地址有两种方法：</li></ol><ul><li>setup 工具</li><li>vi /etc/sysconfig/network-scripts/ifcfg-eth0</li></ul><ol start="2"><li>重启网络服务<br><img src="/2022/01/07/Linux/60.png">  </li><li>虚拟机需要桥接到有线网卡，并重启网络服务</li><li>复制镜像有可能需要重置 UUID（唯一识别符）<br> <img src="/2022/01/07/Linux/61.png">  </li></ol><h3 id="12-2-ifconfig"><a href="#12-2-ifconfig" class="headerlink" title="12.2 ifconfig"></a>12.2 ifconfig</h3><p>配置网络接口，最主要的作用就是查看 IP 地址的信息<br>执行权限：超级用户<br><img src="/2022/01/07/Linux/62.png">  </p><h3 id="12-3-ping"><a href="#12-3-ping" class="headerlink" title="12.3 ping"></a>12.3 ping</h3><p>向网络主机发送 ICMP 请求<br><img src="/2022/01/07/Linux/63.png">  </p><h3 id="12-4-netstat"><a href="#12-4-netstat" class="headerlink" title="12.4 netstat"></a>12.4 netstat</h3><p>输出网络连接、路由表、接口统计、伪装连接和组播成员<br><img src="/2022/01/07/Linux/64.png">  </p><h3 id="12-5-write"><a href="#12-5-write" class="headerlink" title="12.5 write"></a>12.5 write</h3><p>向其他用户发送信息<br><img src="/2022/01/07/Linux/65.png">  </p><h3 id="12-6-wall"><a href="#12-6-wall" class="headerlink" title="12.6 wall"></a>12.6 wall</h3><p>给指定用户发送信息<br><img src="/2022/01/07/Linux/66.png">  </p><h3 id="12-7-mail"><a href="#12-7-mail" class="headerlink" title="12.7 mail"></a>12.7 mail</h3><p>发送和接收电子邮件<br>发送邮件<br><img src="/2022/01/07/Linux/67.png"><br><img src="/2022/01/07/Linux/68.png"><br>接收邮件<br><img src="/2022/01/07/Linux/69.png">  </p><ul><li>headers：列出邮件标题列表，直接输入“h”命令即可。 </li><li>delete：删除指定邮件。比如想要删除第二封邮件，可以输入“d 2”。 </li><li>save：保存邮件。可以把指定邮件保存成文件，如“s 2 /tmp/test.mail”。 </li><li>quit：退出，并把已经操作过的邮件进行保存。比如移除已删除邮件、保存已阅读邮件等。</li><li>exit：退出，但是不保存任何操作</li></ul><h2 id="13-系统痕迹命令"><a href="#13-系统痕迹命令" class="headerlink" title="13 系统痕迹命令"></a>13 系统痕迹命令</h2><h3 id="13-1-w"><a href="#13-1-w" class="headerlink" title="13.1 w"></a>13.1 w</h3><p>显示正在登陆的用户，和他正在做什么。这个命令查看的痕迹日志是/var/run/utmp<br><img src="/2022/01/07/Linux/70.png"><br>第一行信息：</p><table><thead><tr><th>内容</th><th></th></tr></thead><tbody><tr><td>12:26:46</td><td>系统当前时间</td></tr><tr><td>up 1 day, 13:32</td><td>系统的运行时间，本机已经运行 1 天 13 小时 32 分钟</td></tr><tr><td>2 users</td><td>当前登录了两个用户</td></tr><tr><td>load average: 0.00, 0.00, 0.00</td><td>系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值</td></tr><tr><td>超过 1 就是高负载；如果 CPU 是四核的，则这个数值超过 4 就是高负载</td><td></td></tr><tr><td>（这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU</td><td></td></tr><tr><td>的核数）</td><td></td></tr></tbody></table><p>第二行信息：</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>USER</td><td>当前登陆的用户</td></tr><tr><td>TTY</td><td>登陆的终端：</td></tr><tr><td>tty1-6：本地字符终端（alt+F1-6 切换）</td><td></td></tr><tr><td>tty7：本地图形终端（ctrl+alt+F7 切换，必须安装启动图形界面）</td><td></td></tr><tr><td>pts/0-255:远程终端</td><td></td></tr><tr><td>FROM</td><td>登陆的 IP 地址，如果是本地终端，则是空</td></tr><tr><td>LOGIN@</td><td>登陆时间</td></tr><tr><td>IDLE</td><td>用户闲置时间</td></tr><tr><td>JCPU</td><td>所有的进程占用的 CPU 时间</td></tr><tr><td>PCPU</td><td>当前进程占用的 CPU 时间</td></tr><tr><td>WHAT</td><td>用户正在进行的操作</td></tr></tbody></table><h3 id="13-2-who"><a href="#13-2-who" class="headerlink" title="13.2 who"></a>13.2 who</h3><p>查看正在登陆的用户，但是显示的内容更加简单，也是查看<br>/var/run/utmp 日志。<br><img src="/2022/01/07/Linux/71.png"> </p><h3 id="13-3-last"><a href="#13-3-last" class="headerlink" title="13.3 last"></a>13.3 last</h3><p>查看系统所有登陆过的用户信息的，包括正在登陆的用户和之前登陆的用户。这个命令查看的是/var/log/wtmp 痕迹日志文件<br><img src="/2022/01/07/Linux/72.png"> </p><h3 id="13-4-lastlog"><a href="#13-4-lastlog" class="headerlink" title="13.4 lastlog"></a>13.4 lastlog</h3><p>查看系统中所有用户最后一次的登陆时间的命令，他查看的日志是/var/log/lastlog<br>文件<br><img src="/2022/01/07/Linux/73.png"> </p><h3 id="13-5-lastb"><a href="#13-5-lastb" class="headerlink" title="13.5 lastb"></a>13.5 lastb</h3><p>查看错误登陆的信息的，查看的是/var/log/btmp 痕迹日志<br><img src="/2022/01/07/Linux/74.png"> </p><h2 id="14-挂载命令"><a href="#14-挂载命令" class="headerlink" title="14 挂载命令"></a>14 挂载命令</h2><h3 id="14-1-mount"><a href="#14-1-mount" class="headerlink" title="14.1 mount"></a>14.1 mount</h3><p><img src="/2022/01/07/Linux/75.png"> </p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>atime/noatime</td><td>更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时</td></tr><tr><td>间，默认为更新</td><td></td></tr><tr><td>async/sync</td><td>异步/同步，默认为异步</td></tr><tr><td>defaults</td><td>定义默认值，相当于 rw,suid,dev,exec,auto,nouser,async 这七个选项</td></tr><tr><td>exec/noexec</td><td>执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是 exec</td></tr><tr><td>允许</td><td></td></tr><tr><td>remount</td><td>重新挂载已经挂载的文件系统，一般用于指定修改特殊权限</td></tr><tr><td>rw/ro</td><td>读写/只读，文件系统挂载时，是否具有读写权限，默认是 rw</td></tr><tr><td>suid/nosuid</td><td>具有/不具有 SUID 权限，设定文件系统是否具有 SUID 和 SGID 的权限，默</td></tr><tr><td>认是具有</td><td></td></tr><tr><td>user/nouser</td><td>允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是</td></tr><tr><td>不允许，只有 root 可以挂载分区</td><td></td></tr><tr><td>usrquota</td><td>写入代表文件系统支持用户磁盘配额，默认不支持</td></tr><tr><td>grpquota</td><td></td></tr></tbody></table><h3 id="14-2-光盘挂载"><a href="#14-2-光盘挂载" class="headerlink" title="14.2 光盘挂载"></a>14.2 光盘挂载</h3><p><img src="/2022/01/07/Linux/76.png"> </p><p>14.3 挂载 U 盘<br>U 盘会和硬盘共用设备文件名，所以 U 盘的设备文件名不是固定的，需要手工查询<br><img src="/2022/01/07/Linux/77.png"><br>挂载U盘<br><img src="/2022/01/07/Linux/78.png"><br>如果 U 盘中有中文，会发现中文是乱码。Linux 要想正常显示中文，需要两个条件：</p><ul><li>安装了中文编码和中文字体</li><li>操作终端需要支持中文显示（纯字符终端，是不支持中文编码的）<br>手工指定中文编码<br><img src="/2022/01/07/Linux/79.png"><br>卸载U盘<br><img src="/2022/01/07/Linux/80.png"> </li></ul><h3 id="14-4-挂载-NTFS-分区"><a href="#14-4-挂载-NTFS-分区" class="headerlink" title="14.4 挂载 NTFS 分区"></a>14.4 挂载 NTFS 分区</h3><ol><li>下载 NTFS-3G 插件<br>从网站 <a href="http://www.tuxera.com/community/ntfs-3g-download/%E4%B8%8B%E8%BD%BD">http://www.tuxera.com/community/ntfs-3g-download/下载</a> NTFS-3G 插件到 Linux服务器上</li><li>安装 NTFS-3G 插件<br><img src="/2022/01/07/Linux/81.png"> </li><li>挂载Windows 的 NTFS 分区<br>注意挂载分区时的文件系统不是 ntfs，而是 ntfs-3g<br><img src="/2022/01/07/Linux/82.png"> </li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQ高级</title>
      <link href="/2022/01/05/MySQLSenior/"/>
      <url>/2022/01/05/MySQLSenior/</url>
      
        <content type="html"><![CDATA[<h2 id="1-mysql的架构介绍"><a href="#1-mysql的架构介绍" class="headerlink" title="1. mysql的架构介绍"></a>1. mysql的架构介绍</h2><h3 id="1-1-SQL配置文件"><a href="#1-1-SQL配置文件" class="headerlink" title="1.1 SQL配置文件"></a>1.1 SQL配置文件</h3><p>二进制日志：log-bin<br>主从复制</p><p>错误日志：log-error<br>默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等</p><p>查询日志：log<br>默认是关闭，记录查询的sql语句，如果开启会降低mysql的整体性能，因为记录日志也是需要消耗系统资源</p><p>数据文件<br>Linux：/var/lib/mysql<br>frm文件：存放表结构<br>myd文件：存放表数据<br>myi文件：存放表索引</p><p>如何配置<br>windows：my.ini<br>Linux：/etc/my.cnf</p><h3 id="1-2-MySQL逻辑架构介绍"><a href="#1-2-MySQL逻辑架构介绍" class="headerlink" title="1.2 MySQL逻辑架构介绍"></a>1.2 MySQL逻辑架构介绍</h3><p>和其他数据库相比，MySQL有点与众不同，它的架构在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。<br><img src="/2022/01/05/MySQLSenior/1.png" alt="MySQL逻辑架构"></p><ol><li>连接层<br> 最上层是一些客户和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理，授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限</li><li>服务层<br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统性能</li><li>引擎层<br>存储引擎层，存储引擎真正负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li><li>存储层<br>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互</li></ol><h3 id="1-3-MySQL存储引擎"><a href="#1-3-MySQL存储引擎" class="headerlink" title="1.3 MySQL存储引擎"></a>1.3 MySQL存储引擎</h3><h4 id="1-3-1-查看命令"><a href="#1-3-1-查看命令" class="headerlink" title="1.3.1 查看命令"></a>1.3.1 查看命令</h4><p>查看你的mysql现在已提供什么存储引擎</p><pre class=" language-mysql"><code class="language-mysql">show engines</code></pre><p>查看mysql当前默认的存储引擎</p><pre class=" language-mysql"><code class="language-mysql">show variables like '%storage_engine%'</code></pre><h4 id="1-3-2-MyISAM和InnoDB"><a href="#1-3-2-MyISAM和InnoDB" class="headerlink" title="1.3.2 MyISAM和InnoDB"></a>1.3.2 MyISAM和InnoDB</h4><table><thead><tr><th>对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁住某一行，不对其他行有影响，适合高并发操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性影响</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr></tbody></table><h3 id="1-4-Mysql-的用户与权限管理"><a href="#1-4-Mysql-的用户与权限管理" class="headerlink" title="1.4 Mysql 的用户与权限管理"></a>1.4 Mysql 的用户与权限管理</h3><h4 id="1-4-1-MySQL的用户管理"><a href="#1-4-1-MySQL的用户管理" class="headerlink" title="1.4.1 MySQL的用户管理"></a>1.4.1 MySQL的用户管理</h4><ol><li>创建用户<br>CREATE USER ‘username‘@’host’ IDENTIFIED BY ‘password’;<ul><li>username - 你将创建的用户名</li><li>host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%. </li><li>password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.<br>示创建名称为zhang3的用户，密码设为123123；  <pre class=" language-mysql"><code class="language-mysql">CREATE USER 'zhang3'@'localhost' IDENTIFIED BY '123456';</code></pre></li></ul></li><li>了解user表<br>查看用户<pre class=" language-mysql"><code class="language-mysql">select host,user,password,select_priv,insert_priv,drop_priv from mysql.user;</code></pre><img src="/2022/01/05/MySQLSenior/72.png"><br>host ：表示连接类型<br>%： 表示所有远程通过 TCP方式的连接 IP 地址 如 (192.168.1.2,127.0.0.1) 通过制定ip地址进行的TCP方式的连接机器名，通过制定网络中的机器名进行的TCP方式的连接  ::1   IPv6的本地ip地址  等同于IPv4的 127.0.0.1 。localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p 123xxx 方式的连接。<br>User:表示用户名，同一用户通过不同方式链接的权限是不一样的。<br>password ：密码，所有密码串通过 password(明文字符串) 生成的密文字符串。加密算法为MYSQLSHA1 ，不可逆 。 mysql 5.7 的密码保存到 authentication_string 字段中不再使用password 字段。<br>select_priv , insert_priv等为该用户所拥有的权限。        </li><li>设置密码<br> 修改当前用户的密码<pre class=" language-mysql"><code class="language-mysql">set password =password('123456') </code></pre>修改某个用户的密码<pre class=" language-mysql"><code class="language-mysql">update mysql.user set password=password('123456') where user='li4';flush privileges;  #所有通过user表的修改，必须用该命令才能生效。</code></pre></li><li>修改用户<br> 修改用户名<pre class=" language-mysql"><code class="language-mysql">update mysql.user set user='li4' where user='wang5';flush privileges;#所有通过user表的修改，必须用该命令才能生效。   </code></pre></li><li>删除用户<br> 不要通过delete from  user u where user=’li4’ 进行删除，系统会有残留信息保留。 <pre class=" language-mysql"><code class="language-mysql"> drop user li4 ;  </code></pre></li></ol><h4 id="1-4-2-权限管理"><a href="#1-4-2-权限管理" class="headerlink" title="1.4.2 权限管理"></a>1.4.2 权限管理</h4><ol><li>授予权限<br>授权命令<br>grant 权限1,权限2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘连接口令’;<br>该权限如果发现没有该用户，则会直接新建一个用户。<pre class=" language-mysql"><code class="language-mysql"> grant select,insert,delete,drop on atguigudb.* to li4@localhost  ;  #给li4用户用本地命令行方式下，授予atguigudb这个库下的所有表的插删改查的权限</code></pre><pre class=" language-mysql"><code class="language-mysql">grant all privileges on *.* to joe@'%'  identified by '123'; #授予通过网络方式登录的的joe用户 ，对所有库所有表的全部权限，密码设为123.就算 all privileges 了所有权限，grant_priv 权限也只有 root 才能拥有。 </code></pre>  给 root 赋连接口令后<pre class=" language-mysql"><code class="language-mysql">grant all privileges on *.* to root@'%'  ;</code></pre>  新建的连接没有密码，需要设置密码才能远程连接。<pre class=" language-mysql"><code class="language-mysql">update user set password=password('root') where user='root' and host='%'; </code></pre></li><li>收回权限<br>授权命令<br>revoke  权限1,权限2,…权限n on 数据库名称.表名称  from  用户名@用户地址 ;<pre class=" language-mysql"><code class="language-mysql"> REVOKE ALL PRIVILEGES ON mysql.* FROM joe@localhost; #若赋的全库的表就 收回全库全表的所有权限 REVOKE </code></pre><pre class=" language-mysql"><code class="language-mysql">select,insert,update,delete ON mysql.* FROM joe@localhost;#收回mysql库下的所有表的插删改查权限 对比赋予权限的方法。必须用户重新登录后才能生效 </code></pre></li><li>查看权限<br>查看当前用户权限<pre class=" language-mysql"><code class="language-mysql">show grants; </code></pre>查看某用户的全局权限select  * from user ;查看某用户的某库的权限select * from  db; 查看某用户的某个表的权限select * from tables_priv;</li></ol><h4 id="1-4-3-通过远程工具访问"><a href="#1-4-3-通过远程工具访问" class="headerlink" title="1.4.3 通过远程工具访问"></a>1.4.3 通过远程工具访问</h4><ol><li>先 ping 一下数据库服务器的ip 地址确认网络畅通。 </li><li>关闭数据库服务的防火墙    service iptables stop <pre class=" language-mysql"><code class="language-mysql"> service iptables stop </code></pre></li><li>确认Mysql中已经有可以通过远程登录的账户    <pre class=" language-mysql"><code class="language-mysql"> select  * from mysql.user where user='li4' and host='%'; </code></pre>如果没有用户,先执行如下命令<pre class=" language-mysql"><code class="language-mysql"> grant all privileges on *.*  to li4@'%'  identified by '123123';</code></pre></li><li>测试连接：</li></ol><h4 id="1-4-3-Mysql的一些杂项配置"><a href="#1-4-3-Mysql的一些杂项配置" class="headerlink" title="1.4.3 Mysql的一些杂项配置"></a>1.4.3 Mysql的一些杂项配置</h4><ol><li>大小写问题<pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE '%lower_case_table_names%'</code></pre></li></ol><ul><li>windows系统默认大小写不敏感，但是linux系统是大小写敏感的。默认为0，大小写敏感。</li><li>设置1，大小写不敏感。创建的表，数据库都是以小写形式存放在磁盘上，对于sql语句都是转换为小写对表和DB进行查找。</li><li>设置2，创建的表和DB依据语句上格式存放，凡是查找都是转换为小写进行。   设置变量常采用 set lower_case_table_names = 1； 的方式，但此变量是只读权限，所以需要在配置文件中改。</li><li>当想设置为大小写不敏感时，要在my.cnf这个配置文件 [mysqld] 中加入 lower_case_table_names = 1 ，然后重启服务器。但是要在重启数据库实例之前就需要将原来的数据库和表转换为小写，否则更改后将找不到数据库名。在进行数据库参数设置之前，需要掌握这个参数带来的影响，切不可盲目设置。   </li></ul><ol start="2"><li>(生产环境)sql_mode<br>MySQL的sql_mode默认值是空值，在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式，所以开发、测试环境的数据库也必须要设置，这样在开发测试阶段就可以发现问题。<br>使用 set sql_mode=ONLY_FULL_GROUP_BY; 的方式设置会将之前的设置覆盖掉同时<br>设置多个限制：set sql_mode=’ONLY_FULL_GROUP_BY,NO_AUTO_VALUE_ON_ZERO’;<br>sql_mode常用值如下： <ul><li>ONLY_FULL_GROUP_BY：对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 </li><li>NO_AUTO_VALUE_ON_ZERO：该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 </li><li>STRICT_TRANS_TABLES：在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</li><li>NO_ZERO_IN_DATE：在严格模式下，不允许日期和月份为零    NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</li><li>ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回</li><li>NULL NO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户 </li><li>NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 PIPES_AS_CONCAT：将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似</li><li>ANSI_QUOTES：启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符 ORACLE：  设置等同：PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS, NO_AUTO_CREATE_USER.</li></ul></li></ol><h2 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2. 索引优化"></a>2. 索引优化</h2><h3 id="2-1-性能下降SQL慢，执行时间长，等待时间长"><a href="#2-1-性能下降SQL慢，执行时间长，等待时间长" class="headerlink" title="2.1 性能下降SQL慢，执行时间长，等待时间长"></a>2.1 性能下降SQL慢，执行时间长，等待时间长</h3><p>查询语句写的烂<br>索引失效（单值、复合）<br>关联查询太多join（设计缺陷或不得已的需求）<br>服务器调优及各个参数设置（缓冲、线程数）</p><h3 id="2-2-常见通用的join查询"><a href="#2-2-常见通用的join查询" class="headerlink" title="2.2 常见通用的join查询"></a>2.2 常见通用的join查询</h3><h4 id="2-2-1-SQL执行顺序"><a href="#2-2-1-SQL执行顺序" class="headerlink" title="2.2.1 SQL执行顺序"></a>2.2.1 SQL执行顺序</h4><p><strong>手写：</strong><br><img src="/2022/01/05/MySQLSenior/2.png"><br><strong>机读：</strong><br><img src="/2022/01/05/MySQLSenior/3.png"></p><p><strong>总结：</strong><br><img src="/2022/01/05/MySQLSenior/4.png"></p><h4 id="2-2-2-join图"><a href="#2-2-2-join图" class="headerlink" title="2.2.2 join图"></a>2.2.2 join图</h4><p><strong>left join</strong><br><img src="/2022/01/05/MySQLSenior/64.png" alt="left join"></p><p><strong>right join</strong><br><img src="/2022/01/05/MySQLSenior/65.png" alt="right join"></p><p><strong>inner join</strong><br><img src="/2022/01/05/MySQLSenior/66.png" alt="inner join"></p><p><strong>full outer join</strong><br><img src="/2022/01/05/MySQLSenior/67.png" alt="full outer join"></p><p><img src="/2022/01/05/MySQLSenior/68.png" alt="full outer join"></p><h3 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h3><h4 id="2-3-1-索引是什么"><a href="#2-3-1-索引是什么" class="headerlink" title="2.3.1 索引是什么"></a>2.3.1 索引是什么</h4><ol><li>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：索引是数据结构。</li><li>你可以简单理解为“排好序的快速查找数据结构”。<ul><li>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址 为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。二叉树弊端之一：二叉树很可能会发生两边不平衡的情况。B-TREE: (B:balance)  会自动根据两边的情况自动调节，使两端无限趋近于平衡状态。可以使性能最稳定。(myisam使用的方式)    B-TREE弊端：(插入/修改操作多时，B-TREE会不断调整平衡，消耗性能)从侧面说明了索引不是越多越好。B+TREE:Innodb 所使用的索引  </li><li>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。 </li></ul></li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</li><li>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</li></ol><h4 id="2-3-2-索引的优势"><a href="#2-3-2-索引的优势" class="headerlink" title="2.3.2 索引的优势"></a>2.3.2 索引的优势</h4><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ol><h4 id="2-3-3-索引的劣势"><a href="#2-3-3-索引的劣势" class="headerlink" title="2.3.3 索引的劣势"></a>2.3.3 索引的劣势</h4><ol><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</li></ol><h4 id="2-3-4-mysql索引分类"><a href="#2-3-4-mysql索引分类" class="headerlink" title="2.3.4 mysql索引分类"></a>2.3.4 mysql索引分类</h4><ol><li>主键索引<br> 设定为主键后数据库会自动建立索引，innodb为聚簇索引</li><li>单值索引<br> 即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引<br> 索引列的值必须唯一，但允许有空值</li><li>复合索引<br> 即一个索引包含多个列</li><li>基本语法：<br> 有四种方式来添加数据表的索引：<pre class=" language-mysql"><code class="language-mysql">ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)#该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</code></pre><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)#这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</code></pre><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE tbl_name ADD INDEX index_name (column_list)# 添加普通索引，索引值可出现多次。</code></pre><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)#该语句指定了索引为 FULLTEXT ，用于全文索引。 </code></pre> 删除：<pre class=" language-mysql"><code class="language-mysql">DROP INDEX [indexName] ON mytable; </code></pre> 查看：<pre class=" language-mysql"><code class="language-mysql">SHOW INDEX FROM table_name\G</code></pre></li></ol><h4 id="2-3-5-mysql索引结构"><a href="#2-3-5-mysql索引结构" class="headerlink" title="2.3.5 mysql索引结构"></a>2.3.5 mysql索引结构</h4><ol><li>BTree索引<br>检索原理：<br><img src="/2022/01/05/MySQLSenior/69.png"><br>【初始化介绍】 一颗b树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。<br>【查找过程】如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。 真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</li><li>B+Tree索引</li><li>聚簇索引与非聚簇索引</li><li>full-text全文索引</li><li>Hash索引</li><li>R-Tree索引</li></ol><h4 id="2-3-6-哪些情况需要创建索引"><a href="#2-3-6-哪些情况需要创建索引" class="headerlink" title="2.3.6 哪些情况需要创建索引"></a>2.3.6 哪些情况需要创建索引</h4><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引(where 后面的语句)</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ol><h4 id="2-3-7-哪些情况不要创建索引"><a href="#2-3-7-哪些情况不要创建索引" class="headerlink" title="2.3.7 哪些情况不要创建索引"></a>2.3.7 哪些情况不要创建索引</h4><ol><li>表记录太少</li><li>经常增删改的表。Why:提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</li><li>Where条件里用不到的字段不创建索引。索引建多了影响 增删改 的效率</li><li>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ol><h3 id="2-4-性能分析"><a href="#2-4-性能分析" class="headerlink" title="2.4 性能分析"></a>2.4 性能分析</h3><h4 id="2-4-1-MySQL-Query-Optimizer"><a href="#2-4-1-MySQL-Query-Optimizer" class="headerlink" title="2.4.1 MySQL Query Optimizer"></a>2.4.1 MySQL Query Optimizer</h4><ol><li>MySQL中有专门负责优化select语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划（它认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗时间）</li><li>当客户端向MySQL请求一条query，命令解析器模块完成请求分类，区别是select转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query中的Hint信息（如果有），看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取锁所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</li></ol><h4 id="2-4-2-MySQL常见瓶颈"><a href="#2-4-2-MySQL常见瓶颈" class="headerlink" title="2.4.2 MySQL常见瓶颈"></a>2.4.2 MySQL常见瓶颈</h4><ol><li>CPU<br>CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候<br>SQL中对大量数据进行比较、关联、排序、分组</li><li>IO<br> 磁盘I/O瓶颈发生在装入数据远大于内存容量的时候<ul><li>实例内存满足不了缓存数据或排序等需要，导致产生大量 物理 IO。</li><li>查询执行效率低，扫描过多数据行。</li></ul></li><li>锁<ul><li>不适宜的锁的设置，导致线程阻塞，性能下降。</li><li>死锁，线程之间交叉调用资源，导致死锁，程序卡住。</li></ul></li><li>服务器硬件的性能瓶颈<br>top,free, iostat和vmstat来查看系统的性能状态 </li></ol><h4 id="2-4-3-Explain"><a href="#2-4-3-Explain" class="headerlink" title="2.4.3 Explain"></a>2.4.3 Explain</h4><ol><li>是什么<br>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈<br>官网：<a href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">http://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a></li><li>能干嘛<ul><li>表的读取顺序</li><li>哪些索引可以使用</li><li>数据读取操作的操作类型</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul></li><li>怎么玩<br>Explain + SQL语句<br>执行计划包含的信息：<br><img src="/2022/01/05/MySQLSenior/5.png"></li><li>各字段解释<ol><li>id<ul><li>select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序</li><li>三种情况<ul><li>id相同，执行顺序由上至下</li><li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li></ul></li></ul></li><li>select_type<br> 查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询<ul><li>SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION</li><li>PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</li><li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)MySQL会递归执行这些子查询, 把结果放在临时表里。</li><li>SUBQUERY：在SELECT或WHERE列表中包含了子查询</li><li>DEPENDENT SUBQUERY：在SELECT或WHERE列表中包含了子查询,子查询基于外层</li><li>UNCACHEABLE SUBQUREY：无法被缓存的子查询</li><li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li><li>UNION RESULT：从UNION表获取结果的SELECT</li></ul></li><li>table<br>显示这一行的数据是关于哪张表的</li><li>type<br>访问类型排列。显示查询使用了何种类型，<br>从最好到最差依次是：<br>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL<ul><li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</li><li>const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li><li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li><li>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引。一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li><li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</li><li>all：Full Table Scan，将遍历全表以找到匹配的行<br>注意：一般来说，得保证查询至少达到range级别，最好能达到ref。</li></ul></li><li>possible_keys<br>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</li><li>key<br>实际使用的索引。如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引和查询的select字段重叠<br>覆盖索引：select查询后的字段与索引的字段顺序，个数都一致</li><li>key_len<br>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 在不损失精确性的情况下，长度越短越好。<br>key_len显示的值为索引字段的最大可能长度，并非实际使用的长度，即key_len是根据表定义计算而得，不是通过表内检索出的。<br>key_len字段能够帮你检查是否充分的利用上了索引</li><li>ref<br>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</li><li>rows<br> 根据表统计信息及索引选用情况，大致估算出找到所需记录所需要读取的行数。（每张表有多少行被优化器查询）。</li><li>Extra<br>包含不适合在其他列中显示但十分重要的额外信息<ul><li>Using filesort<br>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”</li><li>Using temporary<br>使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</li><li>USING index<br>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！<br>如果同时出现using where，表明索引被用来执行索引键值的查找;<br>如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</li><li>Using where<br>表明使用了where过滤</li><li>using join buffer<br>使用了连接缓存：</li><li>impossible where<br>where子句的值总是false，不能用来获取任何元组</li><li>select tables optimized away<br>在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li><li>distinct<br> 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作</li></ul></li></ol></li></ol><h4 id="2-4-4-索引优化"><a href="#2-4-4-索引优化" class="headerlink" title="2.4.4 索引优化"></a>2.4.4 索引优化</h4><p>索引分析</p><ol><li><p>单表：</p><pre class=" language-mysql"><code class="language-mysql">#查询 category_id 为1 且  comments 大于 1 的情况下,views 最多的 article_id。       EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments > 1 ORDER BY views DESC LIMIT 1; </code></pre><p> <img src="/2022/01/05/MySQLSenior/6.png"><br> 结论:type 是 ALL,即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。<br> <strong>开始优化：</strong></p><ol><li>新建索引+删除索引<pre class=" language-mysql"><code class="language-mysql">ALTER TABLE `article` ADD INDEX idx_article_ccv ( `category_id` , `comments`, `views` );create index idx_article_ccv on article(category_id,comments,views);DROP INDEX idx_article_ccv ON article </code></pre></li><li>explain <pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT id,author_id FROM `article` WHERE category_id = 1 AND comments >1 ORDER BY views DESC LIMIT 1; </code></pre> <img src="/2022/01/05/MySQLSenior/7.png"><br> 结论：<br> type 变成了 range,这是可以忍受的。但是 extra 里使用 Using filesort 仍是无法接受的。<br> 但是我们已经建立了索引,为啥没用呢?<br> 这是因为按照 BTree 索引的工作原理,先排序 category_id,如果遇到相同的 category_id 则再排序 comments,如果遇到相同的 comments 则再排序 views。当 comments 字段在联合索引里处于中间位置时,因comments &gt; 1 条件是一个范围值(所谓 range),MySQL 无法利用索引再对后面的 views 部分进行检索,即 range 类型查询字段后面的索引无效。  </li><li>删除第一次建立的索引<pre class=" language-mysql"><code class="language-mysql">DROP INDEX idx_article_ccv ON article; </code></pre></li><li>第2次新建索引<pre class=" language-mysql"><code class="language-mysql">ALTER TABLE `article` ADD INDEX idx_article_cv ( `category_id` , `views` ) ;create index idx_article_cv on article(category_id,views); </code></pre></li><li>第3次explain<pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments > 1 ORDER BY views DESC LIMIT 1;</code></pre> <img src="/2022/01/05/MySQLSenior/8.png"><br> 结论：可以看到,type 变为了 ref,Extra 中的 Using filesort 也消失了,结果非常理想。</li></ol></li></ol><ol start="2"><li>两表<pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;</code></pre> <img src="/2022/01/05/MySQLSenior/9.png"> 结论：type 有All<br> 添加索引优化<pre class=" language-mysql"><code class="language-mysql">ALTER TABLE `book` ADD INDEX Y ( `card`); </code></pre><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;</code></pre> <img src="/2022/01/05/MySQLSenior/10.png"><br> 可以看到第二行的 type 变为了 ref,rows 也变成了优化比较明显。这是由左连接特性决定的。LEFT JOIN 条件用于确定如何从右表搜索行,左边一定都有,所以右边是我们的关键点,一定需要建立索引。<br> 删除旧索引 + 新建 + 第3次explain<pre class=" language-mysql"><code class="language-mysql">DROP INDEX Y ON book;ALTER TABLE class ADD INDEX X (card);EXPLAIN       SELECT * FROM class LEFT JOIN book ON class.card = book.card;   </code></pre> <img src="/2022/01/05/MySQLSenior/11.png"></li></ol><ol start="3"><li><p>三表</p><pre class=" language-mysql"><code class="language-mysql">explain select * from class left join book on class.card=book.card left join phone on book.card=phone.card;</code></pre><p> <img src="/2022/01/05/MySQLSenior/12.png"></p><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE book ADD INDEX X (card);ALTER TABLE phone ADD INDEX Y (card);</code></pre><p> <img src="/2022/01/05/MySQLSenior/13.png"></p><p> 结论：join语句优化</p><ol><li>尽可能减少join语句中的嵌套循环的循环总次数，“永远用小结果集驱动打的结果集”</li><li>优先优化嵌套循环的内层循环</li><li>保证join语句中被驱动表上join条件字段已经被索引</li><li>当无法保证被驱动表的join条件字段被索引且内存资源充足的前提下，不要台吝啬joinbuffer的设置</li></ol></li><li><p>索引失效</p><ol><li><p>全值匹配我最爱<br>索引  idx_staffs_nameAgePos 建立索引时 以 name ， age ，pos 的顺序建立的。全值匹配表示 按顺序匹配的</p><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT * FROM staffs WHERE NAME = 'July';</code></pre><p> <img src="/2022/01/05/MySQLSenior/14.png"></p><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT * FROM staffs WHERE NAME = 'July' AND age = 25;</code></pre><p> <img src="/2022/01/05/MySQLSenior/15.png"></p><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT * FROM staffs WHERE NAME = 'July' AND age = 25 AND pos = 'dev';  </code></pre><p> <img src="/2022/01/05/MySQLSenior/16.png" alt="全值匹配"></p></li><li><p>最佳左前缀法则<br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。<br>索引失效</p><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT * FROM staffs WHERE age = 25 AND pos = 'dev'; </code></pre><p> <img src="/2022/01/05/MySQLSenior/17.png" alt="跳过了索引的第一列"></p><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT * FROM staffs WHERE pos = 'dev'; </code></pre><p> <img src="/2022/01/05/MySQLSenior/18.png" alt="跳过了索引的第一列，第二列"></p><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT * FROM staffs WHERE NAME = 'July'  AND pos = 'dev';</code></pre><p>  <img src="/2022/01/05/MySQLSenior/19.png" alt="跳过了中间索引"></p></li><li><p>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描<br>  <img src="/2022/01/05/MySQLSenior/20.png"></p></li><li><p>存储引擎不能使用索引中范围条件右边的列（范围之后【不含】的索引全失效。范围条件右边与范围条件使用的同一个组合索引，右边的才会失效。若是不同索引则不会失效）<br> <img src="/2022/01/05/MySQLSenior/21.png"></p></li><li><p>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *<br> <img src="/2022/01/05/MySQLSenior/22.png"></p></li><li><p>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描<br> <img src="/2022/01/05/MySQLSenior/23.png"></p></li><li><p>is null，is not null 也无法使用索引<br>  <img src="/2022/01/05/MySQLSenior/24.png"></p></li><li><p>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作<br> <img src="/2022/01/05/MySQLSenior/25.png"><br> 问题：解决like ‘%字符串%’时索引不被使用的方法？（覆盖索引解决）</p><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT NAME,age    FROM tbl_user WHERE NAME LIKE '%aa%';EXPLAIN SELECT id    FROM tbl_user WHERE NAME LIKE '%aa%';EXPLAIN SELECT NAME     FROM tbl_user WHERE NAME LIKE '%aa%';EXPLAIN SELECT age   FROM tbl_user WHERE NAME LIKE '%aa%';EXPLAIN SELECT id,NAME    FROM tbl_user WHERE NAME LIKE '%aa%';EXPLAIN SELECT id,NAME,age FROM tbl_user WHERE NAME LIKE '%aa%';EXPLAIN SELECT NAME,age FROM tbl_user WHERE NAME LIKE '%aa%';EXPLAIN SELECT *     FROM tbl_user WHERE NAME LIKE '%aa%';EXPLAIN SELECT id,NAME,age,email  FROM tbl_user WHERE NAME LIKE '%aa%';</code></pre><pre class=" language-mysql"><code class="language-mysql">#create indexCREATE INDEX idx_user_nameAge ON tbl_user(NAME,age);SELECT NAME,age    FROM tbl_user WHERE NAME LIKE '%aa%';</code></pre><p>  <img src="/2022/01/05/MySQLSenior/26.png"></p><pre class=" language-mysql"><code class="language-mysql">EXPLAIN SELECT id,NAME,age,email FROM tbl_user WHERE NAME LIKE '%aa%';</code></pre><p> <img src="/2022/01/05/MySQLSenior/27.png"></p></li><li><p>字符串不加单引号索引失效<br>  底层进行类型转换使索引失效，使用了函数造成索引失效<br> <img src="/2022/01/05/MySQLSenior/28.png"></p></li><li><p>少用or,用它来连接时会索引失效<br> <img src="/2022/01/05/MySQLSenior/29.png"></p></li></ol></li></ol><p>一般性建议：</p><ol><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。(避免索引过滤性好的索引失效)</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li></ol><h2 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3.查询截取分析"></a>3.查询截取分析</h2><h3 id="3-1-查询优化"><a href="#3-1-查询优化" class="headerlink" title="3.1 查询优化"></a>3.1 查询优化</h3><ol><li>永远小表驱动大表</li><li>order by关键字优化<ul><li>ORDER BY子句，尽量使用Index方式排序,避免使用FileSort方式排序<pre class=" language-mysql"><code class="language-mysql"> CREATE INDEX idx_A_ageBirth on tblA(age,birth); explain select * from tblA where age>20 order by age;</code></pre>   <img src="/2022/01/05/MySQLSenior/30.png"><pre class=" language-mysql"><code class="language-mysql"> explain select * from tblA where age>20 order by age,birth;</code></pre>   <img src="/2022/01/05/MySQLSenior/31.png"><pre class=" language-mysql"><code class="language-mysql"> explain select * from tblA where age>20 order by birth;</code></pre>   <img src="/2022/01/05/MySQLSenior/32.png"><pre class=" language-mysql"><code class="language-mysql">explain select * from tblA where age>20 order by birth,age;</code></pre>   <img src="/2022/01/05/MySQLSenior/33.png"><br>explain select * from tblA where birth&gt;’2016-01-28 00:00:00’ order by age ASC,birth DESC;<br><img src="/2022/01/05/MySQLSenior/34.png"><ul><li>MySQL支持二种方式的排序，FileSort和Index，Index效率高.它指MySQL扫描索引本身完成排序。FileSort方式效率较低。</li><li>ORDER BY满足两情况，会使用Index方式排序:<ul><li>ORDER BY 语句使用索引最左前列</li><li>使用Where子句与Order BY子句条件列组合满足索引最左前列</li><li>where子句中如果出现索引的范围查询(即explain中出现range)会导致order by 索引失效。</li></ul></li></ul></li><li>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</li><li>如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序<ul><li>双路排序：<br>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出<br>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</li><li>取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</li><li>单路排序：<br>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li><li>结论及引申出的问题：<br>由于单路是后出的，总体而言好过双路<br>但是用单路有问题</li><li>优化策略<br>增大sort_buffer_size参数的设置<br>增大max_length_for_sort_data参数的设置<br>去掉select 后面不需要的字段</li></ul></li></ul></li><li>GROUP BY关键字优化：<ol><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增sort_buffer_size参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了。</li></ol></li></ol><h3 id="3-2-慢查询日志"><a href="#3-2-慢查询日志" class="headerlink" title="3.2 慢查询日志"></a>3.2 慢查询日志</h3><p>3.2.1 是什么<br> MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。<br>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。<br>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p><p>3.2.2 怎么玩</p><ol><li><p>说明<br> 默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p></li><li><p>查看是否开启及如何开启<br> 默认：</p><pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE '%slow_query_log%';</code></pre><p> 开启：</p><pre class=" language-mysql"><code class="language-mysql">set global slow_query_log=1;#只对当前数据库生效，如果mysql重启后则会失效</code></pre></li><li><p>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？<br> 这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒，命令：SHOW VARIABLES LIKE ‘long_query_time%’;可以使用命令修改，也可以在my.cnf参数里面修改。假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是判断大于long_query_time，而非大于等于。 </p></li><li><p>case<br> 查看当前多少秒算慢</p><pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE 'long_query_time%';</code></pre><p> 设置慢的阙值时间<br> 为什么设置后看不出变化？<br> 需要重新连接或新开一个会话才能看到修改值。 </p><pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE 'long_query_time%';</code></pre><p> 或者通过set session long_query_time=1来改变当前session变量;</p><p> 查询当前系统中有多少条慢查询记录</p><pre class=" language-mysql"><code class="language-mysql">show global status like '%Slow_queries%';  </code></pre><p> 配置版</p><pre class=" language-mysql"><code class="language-mysql">slow_query_log=1;slow_query_log_file=/var/lib/mysql/atguigu-slow.loglong_query_time=3;log_output=FILE</code></pre></li><li><p>日志分析工具mysqldumpslow<br> 在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。<br> 查看mysqldumpslow的帮助信息</p><pre class=" language-bash"><code class="language-bash">mysqldumpslow --help</code></pre><p> s: 是表示按照何种方式排序；<br> c: 访问次数<br> l: 锁定时间<br> r: 返回记录<br> t: 查询行数<br> al:平均锁定时间<br> ar:平均返回记录数<br> at:平均查询时间<br> t:即为返回前面多少条的数据；<br> g:后边搭配一个正则匹配模式，大小写不敏感的；</p></li></ol><h3 id="3-4-show-profile"><a href="#3-4-show-profile" class="headerlink" title="3.4 show profile"></a>3.4 show profile</h3><ol><li>是什么<br>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量<br>官网：<a href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a><br>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</li><li>分析步骤<ul><li>是否支持，看看当前的mysql版本是否支持<br>  Show  variables like ‘profiling’;默认是关闭，使用前需要开启     </li><li>开启功能，默认是关闭，使用前需要开启<br> show variables like ‘profiling’; set profiling=1; </li><li>运行SQL<br>select * from emp group by id%10 limit 150000;<br>select * from emp group by id%20  order by 5</li><li>查看结果，show profiles;</li><li>诊断SQL，show profile cpu,block io for query  n  (n为上一步前面的问题SQL数字号码);<br>type:   ALL       –显示所有的开销信息<br>BLOCK IO         –显示块IO相关开销<br>CONTEXT SWITCHES –上下文切换相关开销<br>CPU              –显示CPU相关开销信息<br>IPC              –显示发送和接收相关开销信息<br>MEMORY           –显示内存相关开销信息<br>PAGE FAULTS      –显示页面错误相关开销信息<br>SOURCE           –显示和Source_function，Source_file，Source_line相关的开销信息<br>SWAPS            –显示交换次数相关开销的信息</li></ul></li></ol><ul><li>日常开发需要注意的结论<ul><li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li><li>Creating tmp table 创建临时表<ul><li> 1 select * from emp group by id%20 limit 120000; 2  select * from emp group by id%20  order by 5 </li><li>拷贝数据到临时表</li><li>用完再删除</li></ul></li><li>Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！</li><li>locked</li></ul></li></ul><h3 id="3-5-全局查询日志"><a href="#3-5-全局查询日志" class="headerlink" title="3.5 全局查询日志"></a>3.5 全局查询日志</h3><ol><li>配置启用<br>在mysql的my.cnf中，设置如下：#开启general_log=1   # 记录日志文件的路径general_log_file=/path/logfile#输出格式log_output=FILE</li><li>编码启用<br> 命令set global general_log=1; #全局日志可以存放到日志文件中，也可以存放到Mysql系统表中。存放到日志中性能更好一些，存储到表中set global log_output=’TABLE’;    此后 ，你所编写的sql语句，将会记录到mysql库里的general_log表，可以用下面的命令查看 select * from mysql.general_log;    </li><li>尽量不要在生产环境开启这个功能。</li></ol><h2 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4. MySQL锁机制"></a>4. MySQL锁机制</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>4.1.1 定义<br>  锁是计算机协调多个进程或线程并发访问某一资源的机制。  在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。<br>4.1.2 锁的分类</p><ol><li>从对数据操作的类型（读\写）分<br>读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li><li>从对数据操作的粒度分<br>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。一种提高共享资源并发发性的方式是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。</li></ol><ul><li>表锁</li><li>行锁</li></ul><h3 id="4-2-三锁"><a href="#4-2-三锁" class="headerlink" title="4.2 三锁"></a>4.2 三锁</h3><h4 id="4-2-1-表锁（偏读）"><a href="#4-2-1-表锁（偏读）" class="headerlink" title="4.2.1 表锁（偏读）"></a>4.2.1 表锁（偏读）</h4><p>表锁(偏读)<br>偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p><p>【手动增加表锁】 lock table 表名字1 read(write)，表名字2 read(write)，其它;<br>【查看表上加过的锁】  show open tables; 【释放表锁】unlock tables;</p><p>加读锁<br>我们为mylock表加read锁(读阻塞写例子) session_1session_2获得表mylock的READ锁定连接终端当前session可以查询该表记录 其他session也可以查询该表的记录 当前session不能查询其它没有锁定的表 其他session可以查询或者更新未锁定的表 当前session中插入或者更新锁定的表都会提示错误： 其他session插入或者更新锁定表会一直等待获得锁： 释放锁 Session2获得锁，插入操作完成： </p><p>lock table mylock read,book write;<br>     <img src="/2022/01/05/MySQLSenior/35.png"><br> unlock tables;<br>  <img src="/2022/01/05/MySQLSenior/36.png"></p><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>获得表mylock的READ锁定  <img src="/2022/01/05/MySQLSenior/37.png"></td><td>连接终端</td></tr><tr><td>当前session可以查询该表记录 <img src="/2022/01/05/MySQLSenior/38.png"></td><td>其他session也可以查询该表的记录 <img src="/2022/01/05/MySQLSenior/39.png"></td></tr><tr><td>当前session不能查询其他没有锁定的表 <img src="/2022/01/05/MySQLSenior/40.png"></td><td>其他session可以查询或者更新未锁定的表<img src="/2022/01/05/MySQLSenior/41.png"></td></tr><tr><td>当前session中插入或者更新锁定的表都会提示错误<img src="/2022/01/05/MySQLSenior/42.png"></td><td>其他session插入或者更新锁定的表会一直等待获得锁<img src="/2022/01/05/MySQLSenior/43.png"></td></tr><tr><td>释放锁<img src="/2022/01/05/MySQLSenior/44.png"></td><td>session2获得锁，插入操作完成<img src="/2022/01/05/MySQLSenior/45.png"></td></tr></tbody></table><p>加写锁<br> mylockwrite(MyISAM) session_1session_2获得表mylock的WRITE锁定待Session1开启写锁后，session2再连接终端当前session对锁定表的查询+更新+插入操作都可以执行： 其他session对锁定表的查询被阻塞，需要等待锁被释放： 在锁表前，如果session2有数据缓存，锁表以后，在锁住的表不发生改变的情况下session2可以读出缓存数据，一旦数据发生改变，缓存将失效，操作将被阻塞住。释放锁 Session2获得锁，查询返回：    </p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td>获得表mylock的write锁<img src="/2022/01/05/MySQLSenior/46.png"></td><td>待session_1开启写锁后，session2再连接终端</td></tr><tr><td>当前session对锁定表的查询+更新+插入操作都可以执行<img src="/2022/01/05/MySQLSenior/47.png"></td><td>其他session对锁定表的查询被阻塞，需要等待锁被释放<img src="/2022/01/05/MySQLSenior/48.png"></td></tr><tr><td>释放锁<img src="/2022/01/05/MySQLSenior/49.png"></td><td>session2获得锁，查询返回  <img src="/2022/01/05/MySQLSenior/50.png"></td></tr></tbody></table><p>总结：</p><ul><li><p>MyISAM在执行查询语句select前，会自动给设计的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p></li><li><p>MySQL的表级锁有两种模式</p><ul><li><p>表共享读锁</p></li><li><p>表独占写锁</p><table><thead><tr><th>锁类型</th><th>可否兼容</th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>是</td><td>否</td></tr><tr><td>写锁</td><td>是</td><td>否</td><td>否</td></tr></tbody></table></li></ul></li></ul><p>结论：</p><ol><li>对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作。</li><li>对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作<br> <font color="#F44336">读锁会阻塞写，但是不会阻塞读。写锁会把读和写都阻塞。</font></li></ol><p>表锁分析：</p><ol><li><p>看看哪些表被加锁了</p><pre class=" language-mysql"><code class="language-mysql">show open tables;</code></pre></li><li><p>如何分析表锁定<br> 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定。</p><pre class=" language-mysql"><code class="language-mysql">show status like "table%"</code></pre><p> <img src="/2022/01/05/MySQLSenior/51.png"><br> Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1<br> Table_locks_waited：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加1），此值高则说明存在着较严重的表级锁争用情况<br> <font color="#F44336">MyISAM的读写锁调度是写优先，这也是myisam不适合做为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</font></p></li></ol><h4 id="4-2-2-行锁（偏写）"><a href="#4-2-2-行锁（偏写）" class="headerlink" title="4.2.2 行锁（偏写）"></a>4.2.2 行锁（偏写）</h4><p><strong>特点：</strong></p><ol><li>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁</li></ol><p><strong>行锁支持事务</strong><br>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。</p><ol><li>原子性（Atomicity）<br>事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。 </li><li>一致性（Consistent）<br>在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性（Isolation）<br>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。 </li><li>持久性（Durable）<br>事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。 </li></ol><p><strong>并发事务处理带来的问题</strong></p><ol><li>更新丢失<br> 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。 </li><li>脏读<br>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。 一句话：事务A读取到了事务B已修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</li><li>不可重复读<br> 在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。       一句话：一个事务范围内两个相同的查询却返回了不同数据。 </li><li>幻读<br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。 一句话：事务A 读取到了事务B提交的新增数据，不符合隔离性。   脏读是事务B里面修改了数据<br> 幻读是事务B里面新增了数据</li></ol><p><strong>事务隔离级别</strong><br>脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。 数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。<br>常看当前数据库的事务隔离级别</p><pre class=" language-mysql"><code class="language-mysql">show variables like 'tx_isolation';</code></pre><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>已提交读</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可序列化</td><td>最高级别，事务级</td><td>否</td><td>否</td><td></td></tr></tbody></table><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上串行化进行，这显然与并发是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对不可重复读和幻读并不敏感，可能更关心数据并发访问的能力。</p><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td><img src="/2022/01/05/MySQLSenior/52.png"></td><td><img src="/2022/01/05/MySQLSenior/53.png"></td></tr><tr><td>更新但是不提交，没有手写commit<img src="/2022/01/05/MySQLSenior/54.png"></td><td>session2被阻塞，只能等待<img src="/2022/01/05/MySQLSenior/55.png"></td></tr><tr><td>提交更新<img src="/2022/01/05/MySQLSenior/56.png"></td><td>commit命令执行</td></tr><tr><td></td><td>commit命令执行</td></tr><tr><td>更新a=1</td><td>更新a=9</td></tr></tbody></table><p><strong>无索引行锁升级为表锁</strong><br> Session_1Session_2正常情况，各自锁定各自的行，互相不影响，一个2000另一个3000由于在column字段b上面建了索引，如果没有正常使用，会导致行锁变表锁比如没加单引号导致索引失效，行锁变表锁被阻塞，等待。只到Session_1提交后才阻塞解除，完成更新 </p><p><strong>间隙锁危害</strong><br> 间隙锁带来的插入问题 Session_1Session_2阻塞产生，暂时不能插入commit;阻塞解除，完成插入<br>【什么是间隙锁】当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（GAP Lock）。<br>【危害】因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>查询表的内容，无a=2的记录<img src="/2022/01/05/MySQLSenior/58.png"></td><td>连接终端</td></tr><tr><td>更改表的记录，未提交<img src="/2022/01/05/MySQLSenior/59.png"></td><td>插入表的记录<img src="/2022/01/05/MySQLSenior/60.png"></td></tr><tr><td>提交记录 <img src="/2022/01/05/MySQLSenior/61.png"></td><td>插入成功并提交commit  <img src="/2022/01/05/MySQLSenior/62.png"></td></tr><tr><td>查看数据  <img src="/2022/01/05/MySQLSenior/63.png"></td><td></td></tr></tbody></table><p>案例结论：</p><ol><li> Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。  </li><li>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</li></ol><p>  <strong>如何分析行锁：</strong><br>【如何分析行锁定】通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><pre class=" language-mysql"><code class="language-mysql"> mysql>show status like 'innodb_row_lock%';</code></pre><p> <img src="/2022/01/05/MySQLSenior/70.png"><br>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</p><p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；</p><p>Innodb_row_lock_time_avg：每次等待所花平均时间；<br>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；<br>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；对于这5个状态变量，比较重要的主要是 </p><p>Innodb_row_lock_time_avg（等待平均时长）</p><p>Innodb_row_lock_waits（等待总次数）  </p><p>Innodb_row_lock_time（等待总时长）这三项。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。最后可以通过SELECT * FROM information_schema.INNODB_TRX\G;来查询正在被锁阻塞的sql语句。</p><p><strong>Select也可以加锁</strong><br>读锁：select ..lock in share mode<br>共享锁(Share Lock) 共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。 用法SELECT … LOCK IN SHARE MODE; 在查询语句后面增加 LOCK IN SHARE MODE ，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表（行？），而且这些线程读取的是同一个版本的数据。 </p><p>写锁<br>select… for update  【select * from a where a=1 for update   锁定一行】<br>排他锁（eXclusive Lock）共享锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。用法SELECT … FOR UPDATE;       在查询语句后面增加 FOR UPDATE ，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。 </p><p>优化建议：</p><ol><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</li><li>尽可能较少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁。</li><li>涉及相同表的事务，对于调用表的顺序尽量保持一致。</li><li>在业务环境允许的情况下,尽可能低级别事务隔离</li></ol><h4 id="4-2-3-页锁"><a href="#4-2-3-页锁" class="headerlink" title="4.2.3 页锁"></a>4.2.3 页锁</h4><p>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><h2 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5. 主从复制"></a>5. 主从复制</h2><h3 id="5-1-复制的基本原理"><a href="#5-1-复制的基本原理" class="headerlink" title="5.1 复制的基本原理"></a>5.1 复制的基本原理</h3><p>slave会从master读取binlog来进行数据同步<br>三步骤+原理图<br> <img src="/2022/01/05/MySQLSenior/71.png"><br> MySQL复制过程分成三步</p><ol><li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li><li>slave将master的binary log events拷贝到它的中继日志（relay log）；</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的 </li></ol><p>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events<br>slave将master的binary log events拷贝到它的中继日志（relay log）<br>slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的</p><h3 id="5-2-复制的基本原则"><a href="#5-2-复制的基本原则" class="headerlink" title="5.2 复制的基本原则"></a>5.2 复制的基本原则</h3><ol><li>每个slave只有一个master</li><li>每个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个salve</li></ol><h3 id="5-3-复制的最大问题"><a href="#5-3-复制的最大问题" class="headerlink" title="5.3 复制的最大问题"></a>5.3 复制的最大问题</h3><p>延时</p><h3 id="5-5-一主一从常见配置（待更新步骤）"><a href="#5-5-一主一从常见配置（待更新步骤）" class="headerlink" title="5.5 一主一从常见配置（待更新步骤）"></a>5.5 一主一从常见配置（待更新步骤）</h3><ol><li>mysql版本一致且后台以服务运行</li><li>主从都配置在[mysqld]结点下，都是小写</li><li>主机修改my.ini配置文件<ul><li>[必须]主服务器唯一ID。<br>server-id=1</li><li>[必须]启用二进制日志</li><li>[可选]启用错误日志</li><li>[可选]根目录</li><li>[可选]临时目录</li><li>[可选]数据目录</li><li>read-only=0</li><li>[可选]设置不要复制的数据库</li><li>[可选]设置需要复制的数据库</li></ul></li><li>从机修改my.cnf配置文件<ul><li>[必须]从服务器唯一ID</li><li>[可选]启用二进制日志</li></ul></li><li>因修改过配置文件，请主机+从机都重启后台mysql服务</li><li>主机从机都关闭防火墙<ul><li>windows手动关闭</li><li>关闭虚拟机linux防火墙    service iptables stop</li></ul></li><li>在Windows主机上建立帐户并授权slave<ul><li>GRANT REPLICATION SLAVE ON <em>.</em> TO ‘zhangsan‘@’从机器数据库IP’ IDENTIFIED BY ‘123456’;</li><li>Subtopic</li><li>flush privileges;</li><li>查询master的状态<ul><li>show master status;</li><li>记录下File和Position的值</li></ul></li><li>执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化</li></ul></li><li>在Linux从机上配置需要复制的主机<ul><li>CHANGE MASTER TO MASTER_HOST=’主机IP’,MASTER_USER=’zhangsan’,MASTER_PASSWORD=’123456’,MASTER_LOG_FILE=’File名字’,MASTER_LOG_POS=Position数字;</li><li>启动从服务器复制功能<ul><li>start slave;</li></ul></li><li>show slave status\G<ul><li>下面两个参数都是Yes，则说明主从配置成功！</li><li>Slave_IO_Running: Yes</li><li>Slave_SQL_Running: Yes</li></ul></li></ul></li><li>主机新建库、新建表、insert记录，从机复制</li><li>如何停止从服务复制功能</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试环境搭建</title>
      <link href="/2022/01/03/testEnvironmentSetup/"/>
      <url>/2022/01/03/testEnvironmentSetup/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h2><h3 id="1-1-手动安装"><a href="#1-1-手动安装" class="headerlink" title="1.1 手动安装"></a>1.1 手动安装</h3><ol><li><p>在/usr/local下新建一个java文件夹</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /usr/local/java</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/1.png"></p></li><li><p>将jdk源码包放在/usr/local/java中</p></li><li><p>解压jdk源码包</p><pre class=" language-bash"><code class="language-bash"><span class="token function">tar</span> -zxvf  jdk-8u161-linux-x64.tar.gz</code></pre></li><li><p>配置环境变量</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/profile</code></pre><p> 添加如下内容，要根据自己安装路径修改<br> export JAVA_HOME=/usr/local/java/jdk1.8.0_161<br> export JRE_HOME=${JAVA_HOME}<br> export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:CLASSPATH<br> export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin<br> export PATH=${PATH}:${JAVA_PATH}</p></li></ol><ol start="5"><li><p>编辑完之后，保存并退出，然后刷新环境配置使其生效</p><pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> /etc/profile</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/3.png"><br>6、经查看jdk是否安装成功</p><pre class=" language-bash"><code class="language-bash">java -version</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/2.png"></p></li></ol><h3 id="1-2-yum安装"><a href="#1-2-yum安装" class="headerlink" title="1.2 yum安装"></a>1.2 yum安装</h3><ol><li><p>安装之前先查看一下有无系统自带jdk</p><pre class=" language-bash"><code class="language-bash">rpm -qa <span class="token operator">|</span><span class="token function">grep</span> javarpm -qa <span class="token operator">|</span><span class="token function">grep</span> jdkrpm -qa <span class="token operator">|</span><span class="token function">grep</span> gcj</code></pre></li><li><p>如果有就使用批量卸载命令</p><pre class=" language-bash"><code class="language-bash">rpm -qa <span class="token operator">|</span> <span class="token function">grep</span> java <span class="token operator">|</span> <span class="token function">xargs</span> rpm -e --nodeps </code></pre></li><li><p>直接yum安装1.8.0版本openjdk</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> java-1.8.0-openjdk* -y</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/26.png"></p></li><li><p>配置环境变量</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/profile</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/27.png"></p></li><li><p>使配置文件生效</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">.</span> /etc/profile</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/28.png"></p></li><li><p>经查看jdk是否安装成功</p><pre class=" language-bash"><code class="language-bash">java -version</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/29.png"><br> 默认jre jdk 安装路径是/usr/lib/jvm 下面</p></li><li><p><font color="#F44336">当再次启动tomcat时报错：( 待解决   )<br> 找不到jdk与jre的路径<br> <img src="/2022/01/03/testEnvironmentSetup/30.png"><br> 修改路径后只能启动一次** </font></p><h2 id="2-安装mysql"><a href="#2-安装mysql" class="headerlink" title="2. 安装mysql"></a>2. 安装mysql</h2></li></ol><h3 id="2-1-手动安装"><a href="#2-1-手动安装" class="headerlink" title="2.1 手动安装"></a>2.1 手动安装</h3><ol><li><p>在/usr/local下新建一个mysql文件夹</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /usr/local/mysql</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/7.png"></p></li><li><p>将mysql源码包放在/usr/local/mysql中</p></li><li><p>解压mysql源码包</p><pre class=" language-bash"><code class="language-bash"><span class="token function">tar</span> -zxvf mysql-5.7.36-linux-glibc2.12-x86_64.tar.gz </code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/10.png"></p></li><li><p>添加系统mysql组和mysql用户</p><pre class=" language-bash"><code class="language-bash"><span class="token function">groupadd</span> mysql<span class="token function">useradd</span> -r -g mysql mysql<span class="token comment" spellcheck="true">#useradd -r参数表示mysql用户是系统用户，不可用于登录系统</span></code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/11.png"></p></li><li><p>创建data目录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> data</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/12.png"></p></li><li><p>将/usr/local/mysql/mysql-5.7.36-linux-glibc2.12-x86_64的所有者及所属组改为mysql</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chown</span> -R mysql:mysql /usr/local/mysql/mysql-5.7.36-linux-glibc2.12-x86_64</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/13.png"></p></li><li><p>在/usr/local/mysql/mysql-5.7.36-linux-glibc2.12-x86_64/support-files目录下创建my_default.cnf</p><pre class=" language-bash"><code class="language-bash"><span class="token function">touch</span> my_default.cnf</code></pre><p><img src="/2022/01/03/testEnvironmentSetup/14.png"></p></li><li><p>将如下内容拷贝进my_default.cnf，根据自己安装的路径进行修改</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># For advice on how to change settings please see</span><span class="token comment" spellcheck="true"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</span><span class="token comment" spellcheck="true"># *** DO NOT EDIT THIS FILE. It's a template which will be copied to the</span><span class="token comment" spellcheck="true"># *** default location during install, and will be replaced if you</span><span class="token comment" spellcheck="true"># *** upgrade to a newer version of MySQL.</span><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>sql_mode<span class="token operator">=</span>NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES basedir <span class="token operator">=</span> /opt/mysql/mysql-5.7.25datadir <span class="token operator">=</span> /opt/mysql/mysql-5.7.25/dataport <span class="token operator">=</span> 3306socket <span class="token operator">=</span> /tmp/mysql.sockcharacter-set-server<span class="token operator">=</span>utf8log-error <span class="token operator">=</span> /opt/mysql/mysql-5.7.25/data/mysqld.logpid-file <span class="token operator">=</span> /opt/mysql/mysql-5.7.25/data/mysqld.pid8、将my_default.cnf拷贝到/etc/my.cnf。或者直接修改my.cnf也可。<span class="token function">cp</span> /usr/local/mysql/mysql-5.7.36-linux-glibc2.12-x86_64/support-files/my_default.cnf /etc/my.cnf</code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/15.png"></p></li><li><p>初始化mysqld，根据自己安装的目录进行修改</p><pre class=" language-bash"><code class="language-bash">./mysqld --initialize  --user<span class="token operator">=</span>mysql --basedir<span class="token operator">=</span>/usr/local/mysql/mysql-5.7.36-linux-glibc2.12-x86_64/   --datadir<span class="token operator">=</span>/usr/local/mysql/mysql-5.7.36-linux-glibc2.12-x86_64/data/   </code></pre><p> <img src="/2022/01/03/testEnvironmentSetup/16.png"></p></li><li><p>查看日志，获取mysql的初始密码</p><pre class=" language-bash"><code class="language-bash"> <span class="token function">cat</span> /usr/local/mysql/mysql-5.7.36-linux-glibc2.12-x86_64/data/mysqld.log</code></pre><p><img src="/2022/01/03/testEnvironmentSetup/17.png"></p></li><li><p>登录mysql，密码为初始密码</p><pre class=" language-bash"><code class="language-bash">./mysql -u root -p</code></pre><p><img src="/2022/01/03/testEnvironmentSetup/18.png"><br>解决办法：<br>第一步：找到mysql的安装目录，我的是：/usr/local/mysql/mysql-5.7.36-linux-glibc2.12-x86_64，不用去mysql底下的bin目录<br> 第二步：执行 ./support-files/mysql.server start </p><pre class=" language-bash"><code class="language-bash">./support-files/mysql.server start</code></pre><p><img src="/2022/01/03/testEnvironmentSetup/20.png"></p></li><li><p>修改密码<br><img src="/2022/01/03/testEnvironmentSetup/21.png"></p></li><li><p>添加远程访问权限 </p><pre class=" language-mysql"><code class="language-mysql">mysql> use mysql;mysql> update user set host='%' where user = 'root';mysql> flush privileges;</code></pre></li></ol><h3 id="2-2-yum安装-CentOS6"><a href="#2-2-yum安装-CentOS6" class="headerlink" title="2.2 yum安装(CentOS6)"></a>2.2 yum安装(CentOS6)</h3><ol><li>查看有没有安装包<pre class=" language-bash"><code class="language-bash">yum list mysql</code></pre> <img src="/2022/01/03/testEnvironmentSetup/34.png"></li><li>安装mysql客户端<pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> mysql</code></pre> <img src="/2022/01/03/testEnvironmentSetup/35.png"></li><li>安装mysql服务端<pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> mysql-server</code></pre> <img src="/2022/01/03/testEnvironmentSetup/36.png"><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> mysql-devel</code></pre><img src="/2022/01/03/testEnvironmentSetup/37.png"></li><li>启动mysql服务<pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld start    </code></pre> <img src="/2022/01/03/testEnvironmentSetup/38.png"></li><li>修改数据库密码<pre class=" language-mysql"><code class="language-mysql">mysqladmin -u root password 123456</code></pre> <img src="/2022/01/03/testEnvironmentSetup/39.png"></li><li>连接mysql<pre class=" language-mysql"><code class="language-mysql">mysql -u root -p</code></pre><img src="/2022/01/03/testEnvironmentSetup/40.png"></li><li>修改端口<br> 在/etc/my.cnf中添加端口，改成自己想要的。例如3506<br> <img src="/2022/01/03/testEnvironmentSetup/42.png"><br> 报错<br> <img src="/2022/01/03/testEnvironmentSetup/41.png"><br> 解决办法：<br> 关闭 SELinux问题<br> setenforce 0<br> <img src="/2022/01/03/testEnvironmentSetup/43.png"></li></ol><h2 id="3-安装apache"><a href="#3-安装apache" class="headerlink" title="3. 安装apache"></a>3. 安装apache</h2><h3 id="3-1-手动安装"><a href="#3-1-手动安装" class="headerlink" title="3.1 手动安装"></a>3.1 手动安装</h3><ol><li>在/usr/local下新建一个apache文件夹<pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /usr/local/apache</code></pre> <img src="/2022/01/03/testEnvironmentSetup/4.png"></li><li>将apache源码包放在/usr/local/apache中</li><li>解压apache源码包<pre class=" language-bash"><code class="language-bash"><span class="token function">tar</span> -zxvf apache-tomcat-8.5.73.tar.gz </code></pre> <img src="/2022/01/03/testEnvironmentSetup/5.png"></li><li>执行/usr/local/apache/apache-tomcat-8.5.73/bin/startup.sh，<br> <img src="/2022/01/03/testEnvironmentSetup/6.png"></li><li>去浏览器输入你的ip:8080,查看apache是否运行成功,若出现一下画面则成功<br> <img src="/2022/01/03/testEnvironmentSetup/8.png"><br> 注意：可能启动Apache失败，有可能是防火墙导致<br> CentOS6：<br> 查看防火墙状态：service iptables status<br> 关闭防火墙：    service iptables stop<br> 开启防火墙：    service iptables start<br> 重启防火墙：service iptables restart<br> 永久关闭防火墙：chkconfig iptables off<br> CentOS7：<br> 查看防火墙状态：firewall-cmd  –state<br> 关闭防火墙：systemctl stop firewalld.service<br> 禁止防火墙开机启动：systemctl disable firewalld.service</li><li>修改端口<br> server.xml可以设置端口号、设置域名或IP、默认加载的项目、请求编码<br> 修改页面访问端口：<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8090<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>HTTP/1.1<span class="token punctuation">"</span></span>                   <span class="token attr-name">connectionTimeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span>                   <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre> <img src="/2022/01/03/testEnvironmentSetup/25.png"><br> 停止端口：<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Server</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8005<span class="token punctuation">"</span></span> <span class="token attr-name">shutdown</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SHUTDOWN<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre> 监听端口：<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8009<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AJP/1.3<span class="token punctuation">"</span></span> <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre></li><li>tomcat目录结构详解<br> tomcat目录结构详解<a href="https://www.cnblogs.com/mharvay/p/13700291.html">https://www.cnblogs.com/mharvay/p/13700291.html</a></li></ol><h3 id="3-2-yum安装"><a href="#3-2-yum安装" class="headerlink" title="3.2 yum安装"></a>3.2 yum安装</h3><ol><li>安装httpd服务<pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span>  httpd -y</code></pre> <img src="/2022/01/03/testEnvironmentSetup/31.png"></li><li>开启服务<pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> httpd start</code></pre> <img src="/2022/01/03/testEnvironmentSetup/32.png"></li><li>浏览器输入<a href="http://ip:80出现如下界面">http://ip:80出现如下界面</a><br> <img src="/2022/01/03/testEnvironmentSetup/33.png"><br> 配置文件位置：/etc/httpd/conf/httpd.conf<br> 网页位置：/var/www/html<br> 日志位置：/var/log/httpd<br> 启动：service httpd start</li><li>修改端口<pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/httpd/conf/httpd.conf</code></pre> <img src="/2022/01/03/testEnvironmentSetup/44.png"><br> 然后重新启动服务报错如下<br> <img src="/2022/01/03/testEnvironmentSetup/45.png"><br> 解决办法：<br> 关闭SELinux   这是最快速直接的办法，也是很多人常用的办法，缺点是牺牲了系统的安全。你可以彻底关闭或者将SELinux模式。<br> vi /etc/selinux/config<br> 在SELINUX=enforcing前面加#，将其注释掉<br> 添加一行<br> SELINUX=disabled<br> 保存退出重启系统在开启服务即可<br> <img src="/2022/01/03/testEnvironmentSetup/46.png"><br> <img src="/2022/01/03/testEnvironmentSetup/47.png"></li></ol><h2 id="4-测试环境搭建"><a href="#4-测试环境搭建" class="headerlink" title="4. 测试环境搭建"></a>4. 测试环境搭建</h2><h3 id="4-1-war包形式的测试环境搭建"><a href="#4-1-war包形式的测试环境搭建" class="headerlink" title="4.1 war包形式的测试环境搭建"></a>4.1 war包形式的测试环境搭建</h3><ol><li>确定java环境<br>   java -version</li><li>确定数据库状态<br>  netstat -tlnp<br>  <img src="/2022/01/03/testEnvironmentSetup/22.png"></li><li>确定tomcat状态<br>  <img src="/2022/01/03/testEnvironmentSetup/23.png"></li><li>将项目的war文件放在Apache下的webapps目录下<br>  开启浏览器访问项目如：<a href="http://ip:8080/warehouse/html/login.html">http://ip:8080/warehouse/html/login.html</a></li></ol><h3 id="4-2-前后台分离的测试环境搭建-前台tar，后台jar"><a href="#4-2-前后台分离的测试环境搭建-前台tar，后台jar" class="headerlink" title="4.2 前后台分离的测试环境搭建(前台tar，后台jar)"></a>4.2 前后台分离的测试环境搭建(前台tar，后台jar)</h3><ol><li>确定java环境<br>java -version</li><li>确定数据库状态<br>  netstat -tlnp<br>  <img src="/2022/01/03/testEnvironmentSetup/22.png" alt="enter description here"></li><li>将前台tar打包的代码放置在/var/www/html并解压</li><li>启动后台的jar<br>  调试模式：java -jar jar包名称<br>  后台启动模式：nohup java -jar jar包名称 &amp;<br>  后台启动会自动生成一个nohup.out文件，该文件就是一个日志</li></ol><h3 id="4-3-前后台都打包在jar包"><a href="#4-3-前后台都打包在jar包" class="headerlink" title="4.3 前后台都打包在jar包"></a>4.3 前后台都打包在jar包</h3><ol><li>确定java环境<br>java -version</li><li>确定数据库状态<br>  netstat -tlnp<br>  <img src="/2022/01/03/testEnvironmentSetup/22.png" alt="enter description here"></li><li>启动jar<br>  调试模式：java -jar jar包名称<br>  后台启动模式：nohup java -jar jar包名称 &amp;<br>  后台启动会自动生成一个nohup.out文件，该文件就是一个日志</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 测试环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础知识（二）</title>
      <link href="/2021/12/31/MySQLBasics2/"/>
      <url>/2021/12/31/MySQLBasics2/</url>
      
        <content type="html"><![CDATA[<h2 id="3-DML语言"><a href="#3-DML语言" class="headerlink" title="3. DML语言"></a>3. DML语言</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>数据操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p><h3 id="3-2-插入"><a href="#3-2-插入" class="headerlink" title="3.2 插入"></a>3.2 插入</h3><p><strong>1. 方式一</strong><br>    语法：insert into 表名(字段名,…) values(值,…);<br><strong>特点：</strong></p><ol><li>要求值的类型和字段的类型要一致或兼容</li><li>字段的个数和顺序不一定与原始表中的字段个数和顺序一致<br>但必须保证值和字段一一对应</li><li>假如表中有可以为null的字段，注意可以通过以下两种方式插入null值<ul><li>字段和值都省略</li><li>字段写上，值使用null</li></ul></li><li>字段和值的个数必须一致</li><li>字段名可以省略，默认所有列</li></ol><p><strong>2. 方式二</strong><br>语法：insert into 表名 set 字段=值,字段=值,…;<br><strong>3. 两种方式 的区别：</strong></p><ol><li>方式一支持一次插入多行，语法如下：<br>insert into 表名【(字段名,..)】 values(值，..),(值，…),…;</li><li>方式一支持子查询，语法如下：<br>insert into 表名</li></ol><pre class=" language-MySQL"><code class="language-MySQL">#方式一：经典的插入/*语法：insert into 表名(列名,...) values(值1,...);*/#1.插入的值的类型要与列的类型一致或兼容INSERT INTO beauty ( id, NAME, sex, borndate, phone, photo, boyfriend_id )VALUES    ( 13, '唐艺昕', '女', '1990-4-23', '1898888888', NULL, 2 );        #2.不可以为null的列必须插入值。可以为null的列如何插入值？#方式一：INSERT INTO beauty ( id, NAME, sex, borndate, phone, photo, boyfriend_id )VALUES    ( 13, '唐艺昕', '女', '1990-4-23', '1898888888', NULL, 2 );#方式二：INSERT INTO beauty ( id, NAME, sex, phone )VALUES    ( 15, '娜扎', '女', '1388888888' );#3.列的顺序是否可以调换INSERT INTO beauty ( NAME, sex, id, phone )VALUES    ( '蒋欣', '女', 16, '110' );#4.列数和值的个数必须一致INSERT INTO beauty ( NAME, sex, id, phone )VALUES    ( '关晓彤', '女', 17, '110' );#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致INSERT INTO beautyVALUES    ( 18, '张飞', '男', NULL, '119', NULL, NULL );#方式二：/*语法：insert into 表名 set 列名=值,列名=值,...*/INSERT INTO beauty SET id = 19,NAME = '刘涛',phone = '999';#两种方式大pk ★#1、方式一支持插入多行,方式二不支持INSERT INTO beautyVALUES    ( 23, '唐艺昕1', '女', '1990-4-23', '1898888888', NULL, 2 ),    ( 24, '唐艺昕2', '女', '1990-4-23', '1898888888', NULL, 2 ),    ( 25, '唐艺昕3', '女', '1990-4-23', '1898888888', NULL, 2 );#2、方式一支持子查询，方式二不支持INSERT INTO beauty ( id, NAME, phone ) SELECT26,'宋茜','11809866';INSERT INTO beauty ( id, NAME, phone ) SELECTid,boyname,'1234567' FROM    boys WHERE    id < 3;</code></pre><h3 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h3><h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><ol><li><p>修改单表的记录★<br> <strong>语法</strong>：<br> update 表名<br> set 列=新值,列=新值,…<br> where 筛选条件;</p></li><li><p>修改多表的记录【补充】<br> <strong>语法：</strong><br> <strong>sql92语法：</strong><br> update 表1 别名,表2 别名<br> set 列=值,…<br> where 连接条件<br> and 筛选条件;</p><p> <strong>sql99语法：</strong><br> update 表1 别名<br> inner|left|right join 表2 别名<br> on 连接条件<br> set 列=值,…<br> where 筛选条件;</p></li></ol><pre class=" language-MySQL"><code class="language-MySQL">#1.修改单表的记录#案例1：修改beauty表中姓唐的女神的电话为13899888899UPDATE beauty SET phone = '13899888899' WHERE    NAME LIKE '唐%';#案例2：修改boys表中id好为2的名称为张飞，魅力值 10UPDATE boys SET boyname = '张飞',usercp = 10 WHERE    id = 2;#2.修改多表的记录#案例 1：修改张无忌的女朋友的手机号为114UPDATE boys boINNER JOIN beauty b ON bo.`id` = b.`boyfriend_id` SET b.`phone` = '114',bo.`userCP` = 1000 WHERE    bo.`boyName` = '张无忌';#案例2：修改没有男朋友的女神的男朋友编号都为2号UPDATE boys boRIGHT JOIN beauty b ON bo.`id` = b.`boyfriend_id` SET b.`boyfriend_id` = 2 WHERE    bo.`id` IS NULL;</code></pre><h3 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h3><h4 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h4><p>方式一：delete<br>式二：truncate语句<br><strong>语法：</strong></p><ol><li>单表的删除【★】<br>delete from 表名 where 筛选条件</li><li>多表的删除【补充】<br> <strong>sql92语法：</strong><br> delete 表1的别名,表2的别名<br> from 表1 别名,表2 别名<br> where 连接条件<br> and 筛选条件;</li></ol><p><strong>sql99语法：</strong><br>delete 表1的别名,表2的别名<br>from 表1 别名<br>inner|left|right join 表2 别名 on 连接条件<br>where 筛选条件;</p><p><strong>方式一  delete</strong></p><pre class=" language-MySQL"><code class="language-MySQL">#1.单表的删除#案例：删除手机号以9结尾的女神信息DELETE FROM    beauty WHERE    phone LIKE '%9';SELECT    * FROM    beauty;</code></pre><pre class=" language-MySQL"><code class="language-MySQL">#2.多表的删除#案例：删除张无忌的女朋友的信息DELETE b FROM    beauty b    INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id` WHERE    bo.`boyName` = '张无忌';#案例：删除黄晓明的信息以及他女朋友的信息DELETE b,bo FROM    beauty b    INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id` WHERE    bo.`boyName` = '黄晓明';</code></pre><p><strong>方式二：truncate语句</strong></p><pre class=" language-MySQL"><code class="language-MySQL">#案例：将魅力值>100的男神信息删除TRUNCATE TABLE boys ;</code></pre><p><strong>delete pk truncate</strong></p><ol><li>delete 可以加where 条件，truncate不能加</li><li>truncate删除，效率高一丢丢</li><li>假如要删除的表中有自增长列，<br>如果用delete删除后，再插入数据，自增长列的值从断点开始，<br>而truncate删除后，再插入数据，自增长列的值从1开始。</li><li>truncate删除没有返回值，delete删除有返回值</li><li>truncate删除不能回滚，delete删除可以回滚.</li></ol><h2 id="4-DDL语言"><a href="#4-DDL语言" class="headerlink" title="4. DDL语言"></a>4. DDL语言</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><ol><li>数据定义语言</li><li>库和表的管理</li><li>库的管理<br> 创建、修改、删除</li><li>表的管理<br> 创建、修改、删除</li><li>创建： create<br> 修改： alter<br> 删除： drop</li></ol><h3 id="4-2-库的管理"><a href="#4-2-库的管理" class="headerlink" title="4.2 库的管理"></a>4.2 库的管理</h3><p><strong>库的创建</strong>：create database  （if not exists）库名;</p><pre class=" language-mysql"><code class="language-mysql">#案例：创建库BooksCREATE DATABASEIF    NOT EXISTS books;</code></pre><p><strong>库的修改</strong></p><pre class=" language-mysql"><code class="language-mysql">#2、库的修改RENAME DATABASE books TO 新库名;#更改库的字符集ALTER DATABASE books CHARACTER SET gbk;</code></pre><p><strong>库的删除</strong></p><pre class=" language-mysql"><code class="language-mysql">DROP DATABASEIF    EXISTS books;</code></pre><h3 id="4-3-表的管理"><a href="#4-3-表的管理" class="headerlink" title="4.3 表的管理"></a>4.3 表的管理</h3><p><strong>表的创建</strong><br><strong>语法：</strong><br>create table 表名(<br>    列名 列的类型【(长度) 约束】,<br>    列名 列的类型【(长度) 约束】,<br>    列名 列的类型【(长度) 约束】,<br>    …<br>    列名 列的类型【(长度) 约束】<br>)</p><pre class=" language-mysql"><code class="language-mysql">#案例：创建表BookCREATE TABLE book ( id INT, #编号bName VARCHAR ( 20 ), #图书名price DOUBLE, #价格authorId INT, #作者编号publishDate DATETIME #出版日期);#查看表的结构DESC book;#案例：创建表authorCREATE TABLEIF    NOT EXISTS author ( id INT, au_name VARCHAR ( 20 ), nation VARCHAR ( 10 ) );</code></pre><p><strong>表的修改</strong><br><strong>语法</strong>：alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</p><pre class=" language-mysql"><code class="language-mysql">#①修改列名ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;#②修改列的类型或约束ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;#③添加新列ALTER TABLE author ADD COLUMN annual DOUBLE; #④删除列ALTER TABLE book_author DROP COLUMN  annual;#⑤修改表名ALTER TABLE author RENAME TO book_author;</code></pre><p><strong>表的删除</strong></p><pre class=" language-mysql"><code class="language-mysql">DROP TABLE IF EXISTS book_author;SHOW TABLES;#通用的写法：DROP DATABASE IF EXISTS 旧库名;CREATE DATABASE 新库名;DROP TABLE IF EXISTS 旧表名;CREATE TABLE  表名;</code></pre><p><strong>表的创建</strong></p><pre class=" language-mysql"><code class="language-mysql">#1.仅仅复制表的结构CREATE TABLE copy LIKE author;#2.复制表的结构+数据CREATE TABLE copy2 SELECT * FROM author;#只复制部分数据CREATE TABLE copy3SELECT id,au_nameFROM author WHERE nation='中国';#仅仅复制某些字段CREATE TABLE copy4 SELECT idFROM author</code></pre><h3 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h3><h4 id="4-3-1-数值型"><a href="#4-3-1-数值型" class="headerlink" title="4.3.1 数值型"></a>4.3.1 数值型</h4><ol><li><p>整型<br> tinyint、smallint、mediumint、int/integer、bigint<br> 1           2              3                  4                  8</p><p> 特点：</p><ul><li>都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号</li><li>如果超出了范围，会报out or range异常，插入临界值</li><li>长度可以不指定，默认会有一个长度</li><li>长度代表显示的最大宽度，如果不够则左边用0填充，但需要搭配zerofill，并且默认变为无符号整型</li></ul></li><li><p>浮点型<br> 定点数：decimal(M,D)<br> 浮点数:<br>float(M,D)   4<br>double(M,D)  8</p><p> 特点：</p><ul><li>M代表整数部位+小数部位的个数，D代表小数部位</li><li>如果超出范围，则报out or range异常，并且插入临界值</li><li>M和D都可以省略，但对于定点数，M默认为10，D默认为0</li><li>如果精度要求较高，则优先考虑使用定点数</li></ul></li></ol><h4 id="4-3-2-字符型"><a href="#4-3-2-字符型" class="headerlink" title="4.3.2 字符型"></a>4.3.2 字符型</h4><p>   char、varchar、binary、varbinary、enum、set、text、blob</p><p>   char：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1<br>   varchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略</p><h4 id="4-3-1-日期型"><a href="#4-3-1-日期型" class="headerlink" title="4.3.1 日期型"></a>4.3.1 日期型</h4><p>year年<br>date日期<br>time时间<br>datetime 日期+时间          8<br>timestamp 日期+时间         4   比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间</p><h3 id="4-4-常见的约束"><a href="#4-4-常见的约束" class="headerlink" title="4.4 常见的约束"></a>4.4 常见的约束</h3><h4 id="4-4-1-常见的约束"><a href="#4-4-1-常见的约束" class="headerlink" title="4.4.1 常见的约束"></a>4.4.1 常见的约束</h4><ul><li><p>NOT NULL：非空，该字段的值必填</p></li><li><p>UNIQUE：唯一，该字段的值不可重复</p></li><li><p>DEFAULT：默认，该字段的值不用手动插入有默认值</p></li><li><p>CHECK：检查，mysql不支持</p></li><li><p>PRIMARY KEY：主键，该字段的值不可重复并且非空  unique+not null</p></li><li><p>FOREIGN KEY：外键，该字段的值引用了另外的表的字段</p></li><li><p>主键和唯一<br>  <strong>1. 区别：</strong><br>  ①、一个表至多有一个主键，但可以有多个唯一<br>  ②、主键不允许为空，唯一可以为空<br>  <strong>2. 相同点</strong><br>  都具有唯一性<br>  都支持组合键，但不推荐</p></li><li><p>外键：</p><ol><li>用于限制两个表的关系，从表的字段值引用了主表的某字段值</li><li>外键列和主表的被引用列要求类型一致，意义一样，名称无要求</li><li>主表的被引用列要求是一个key（一般就是主键）</li><li>插入数据，先插入主表</li></ol></li><li><p>删除数据，先删除从表<br>  可以通过以下两种方式来删除主表的记录<br>  <strong>#方式一：级联删除</strong><br>  ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;</p><p>  <strong>#方式二：级联置空</strong><br>  ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;</p></li></ul><h4 id="4-4-2-创建表时添加约束"><a href="#4-4-2-创建表时添加约束" class="headerlink" title="4.4.2 创建表时添加约束"></a>4.4.2 创建表时添加约束</h4><p>create table 表名(<br>    字段名 字段类型 not null,#非空<br>    字段名 字段类型 primary key,#主键<br>    字段名 字段类型 unique,#唯一<br>    字段名 字段类型 default 值,#默认<br>    constraint 约束名 foreign key(字段名) references 主表（被引用列）<br>)<br><strong>注意：</strong></p><table><thead><tr><th></th><th>支持类型</th><th>可以起约束名</th></tr></thead><tbody><tr><td>列级约束</td><td>除了外键</td><td>不可以</td></tr><tr><td>表级约束</td><td>除了非空和默认</td><td>可以，但对主键无效</td></tr></tbody></table><p>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p><pre class=" language-MySQL"><code class="language-MySQL">#1.添加列级约束/*语法：直接在字段名和类型后面追加 约束类型即可。只支持：默认、非空、主键、唯一*/CREATE TABLE stuinfo (id INT PRIMARY KEY,#主键stuName VARCHAR ( 20 ) NOT NULL UNIQUE,#非空gender CHAR ( 1 ) CHECK ( gender = '男' OR gender = '女' ),#检查seat INT UNIQUE,#唯一age INT DEFAULT 18,#默认约束majorId INT REFERENCES major ( id ) #外键);CREATE TABLE major ( id INT PRIMARY KEY, majorName VARCHAR ( 20 ) );#查看stuinfo中的所有索引，包括主键、外键、唯一SHOW INDEX FROM stuinfo;#2.添加表级约束/*语法：在各个字段的最下面 【constraint 约束名】 约束类型(字段名) */CREATE TABLEIF    NOT EXISTS stuinfo (    id INT PRIMARY KEY,    stuname VARCHAR ( 20 ),    sex CHAR ( 1 ),    age INT DEFAULT 18,    seat INT UNIQUE,    majorid INT,    CONSTRAINT fk_stuinfo_major FOREIGN KEY ( majorid ) REFERENCES major ( id )     );</code></pre><h4 id="4-4-3-修改表时添加或删除约束"><a href="#4-4-3-修改表时添加或删除约束" class="headerlink" title="4.4.3 修改表时添加或删除约束"></a>4.4.3 修改表时添加或删除约束</h4><p><strong>非空</strong><br>添加非空<br>alter table 表名 modify column 字段名 字段类型 not null;<br>删除非空<br>alter table 表名 modify column 字段名 字段类型 ;</p><pre class=" language-MySQL"><code class="language-MySQL">#1.添加非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;#1.删除非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</code></pre><p><strong>默认</strong><br>添加默认<br>alter table 表名 modify column 字段名 字段类型 default 值;<br>删除默认<br>alter table 表名 modify column 字段名 字段类型 ;</p><pre class=" language-MySQL"><code class="language-MySQL">#2.添加默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;#2.删除默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT ;</code></pre><p><strong>主键</strong><br>添加主键<br>alter table 表名 add【 constraint 约束名】 primary key(字段名);<br>删除主键<br>alter table 表名 drop primary key;</p><pre class=" language-MySQL"><code class="language-MySQL">#3.添加主键#①列级约束ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;#②表级约束ALTER TABLE stuinfo ADD PRIMARY KEY(id);#3.删除主键ALTER TABLE stuinfo DROP PRIMARY KEY;</code></pre><p><strong>唯一</strong><br>添加唯一<br>alter table 表名 add【 constraint 约束名】 unique(字段名);<br>删除唯一<br>alter table 表名 drop index 索引名;</p><pre class=" language-MySQL"><code class="language-MySQL">#①列级约束ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;#②表级约束ALTER TABLE stuinfo ADD UNIQUE(seat);#4.删除唯一ALTER TABLE stuinfo DROP INDEX seat;</code></pre><p><strong>外键</strong><br>添加外键<br>alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;<br>删除外键<br>alter table 表名 drop foreign key 约束名;</p><pre class=" language-MySQL"><code class="language-MySQL">#5.添加外键ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); #5.删除外键ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</code></pre><h4 id="4-4-4-自增长列"><a href="#4-4-4-自增长列" class="headerlink" title="4.4.4 自增长列"></a>4.4.4 自增长列</h4><p><strong>特点：</strong></p><ol><li>不用手动插入值，可以自动提供序列值，默认从1开始，步长为1<br> auto_increment_increment<br> 如果要更改起始值：手动插入值<br> 如果要更改步长：更改系统变量<br> set auto_increment_increment=值;</li><li>一个表至多有一个自增长列</li><li>自增长列只能支持数值型</li><li>自增长列必须为一个key</li></ol><p><strong>创建表时设置自增长列</strong></p><pre class=" language-mysql"><code class="language-mysql">create table 表(        字段名 字段类型 约束 auto_increment)</code></pre><p><strong>修改表时设置自增长列</strong></p><pre class=" language-mysql"><code class="language-mysql"> alter table 表 modify column 字段名 字段类型 约束 auto_increment</code></pre><p><strong>删除自增长列</strong></p><pre class=" language-mysql"><code class="language-mysql">alter table 表 modify column 字段名 字段类型 约束 </code></pre><h2 id="5-TCL语言"><a href="#5-TCL语言" class="headerlink" title="5. TCL语言"></a>5. TCL语言</h2><h4 id="5-1-1-事务"><a href="#5-1-1-事务" class="headerlink" title="5.1.1 事务"></a>5.1.1 事务</h4><ol><li><p>含义<br>事务：一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行</p></li><li><p>特点（ACID）<br> A 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行<br> C 一致性：一个事务可以使数据从一个一致状态切换到另外一个一致的状态<br> I 隔离性：一个事务不受其他事务的干扰，多个事务互相隔离的<br> D 持久性：一个事务一旦提交了，则永久的持久化到本地</p><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>repeatable read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>serializable</td><td>×</td><td>×</td><td></td></tr></tbody></table><p> mysql中默认 第三个隔离级别 repeatable read<br> oracle中默认第二个隔离级别 read committed<br> 查看隔离级别<br> select @@tx_isolation;<br> 设置隔离级别<br> set session|global transaction isolation level 隔离级别;</p></li></ol><h4 id="5-1-2-事务的使用步骤-★"><a href="#5-1-2-事务的使用步骤-★" class="headerlink" title="5.1.2 事务的使用步骤 ★"></a>5.1.2 事务的使用步骤 ★</h4><p>了解：<br>隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete<br>显式事务：具有明显的开启和结束</p><p>使用显式事务：<br>①开启事务<br>set autocommit=0;<br>start transaction;#可以省略</p><pre class=" language-MySQL"><code class="language-MySQL">SET autocommit = 0;START TRANSACTION;</code></pre><p>②编写一组逻辑sql语句<br>注意：sql语句支持的是insert、update、delete</p><pre class=" language-MySQL"><code class="language-MySQL">UPDATE account SET balance = 1000 WHERE    username = '张无忌';UPDATE account SET balance = 1000 WHERE    username = '赵敏';</code></pre><p>设置回滚点：<br>savepoint 回滚点名;</p><p>③结束事务<br>提交：commit;<br>回滚：rollback;<br>回滚到指定的地方：rollback to 回滚点名;</p><pre class=" language-MySQL"><code class="language-MySQL">ROLLBACK;</code></pre><pre class=" language-MySQL"><code class="language-MySQL">SHOW VARIABLES LIKE 'autocommit';SHOW ENGINES;#1.演示事务的使用步骤#开启事务SET autocommit = 0;START TRANSACTION;#编写一组事务的语句UPDATE account SET balance = 1000 WHERE    username = '张无忌';UPDATE account SET balance = 1000 WHERE    username = '赵敏';#结束事务ROLLBACK;#commit;</code></pre><p><strong>演示事务对于delete和truncate的处理的区别</strong></p><pre class=" language-MySQL"><code class="language-MySQL">#2.演示事务对于delete和truncate的处理的区别SET autocommit=0;START TRANSACTION;DELETE FROM account;ROLLBACK;</code></pre><p><strong>演示savepoint 的使用</strong></p><pre class=" language-MySQL"><code class="language-MySQL">#3.演示savepoint 的使用SET autocommit=0;START TRANSACTION;DELETE FROM account WHERE id=25;SAVEPOINT a;#设置保存点DELETE FROM account WHERE id=28;ROLLBACK TO a;#回滚到保存点</code></pre><h4 id="5-1-3-并发事务"><a href="#5-1-3-并发事务" class="headerlink" title="5.1.3 并发事务"></a>5.1.3 并发事务</h4><ol><li>事务的并发问题是如何发生的？<br> 多个事务 同时 操作 同一个数据库的相同数据时</li><li>并发问题都有哪些？<br>脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据<br>不可重复读：一个事务多次读取，结果不一样<br>幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的 数据</li><li>如何解决并发问题<br> 通过设置隔离级别来解决并发问题</li><li>隔离级别<table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>×</td><td>×</td><td>×</td></tr><tr><td>read committed</td><td>√</td><td>×</td><td>×</td></tr><tr><td>repeatable read</td><td>√</td><td>√</td><td>×</td></tr><tr><td>serializable</td><td>√</td><td>√</td><td></td></tr></tbody></table></li></ol><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h2><h3 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h3><h4 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1 概述"></a>6.1.1 概述</h4><ol><li>含义<br> mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。</li><li>好处：<ul><li>简化sql语句</li><li>提高了sql的重用性</li><li>保护基表的数据，提高了安全性</li></ul></li></ol><h4 id="6-1-2-创建"><a href="#6-1-2-创建" class="headerlink" title="6.1.2 创建"></a>6.1.2 创建</h4><p>create view 视图名<br>as<br>查询语句;</p><pre class=" language-MySQL"><code class="language-MySQL">#1.查询姓名中包含a字符的员工名、部门名和工种信息#①创建CREATE VIEW myv1 AS SELECTlast_name,department_name,job_title FROM    employees e    JOIN departments d ON e.department_id = d.department_id    JOIN jobs j ON j.job_id = e.job_id;#②使用SELECT    * FROM    myv1 WHERE    last_name LIKE '%a%';#2.查询各部门的平均工资级别#①创建视图查看每个部门的平均工资CREATE VIEW myv2 AS SELECTAVG( salary ) ag,department_id FROM    employees GROUP BY    department_id;#②使用SELECT    myv2.`ag`,    g.grade_level FROM    myv2    JOIN job_grades g ON myv2.`ag` BETWEEN g.`lowest_sal`     AND g.`highest_sal`;#3.查询平均工资最低的部门信息SELECT    * FROM    myv2 ORDER BY    ag     LIMIT 1;#4.查询平均工资最低的部门名和工资CREATE VIEW myv3 AS SELECT* FROM    myv2 ORDER BY    ag     LIMIT 1;SELECT    d.*,    m.ag FROM    myv3 m    JOIN departments d ON m.`department_id` = d.`department_id`;</code></pre><h4 id="6-1-3-修改"><a href="#6-1-3-修改" class="headerlink" title="6.1.3 修改"></a>6.1.3 修改</h4><p><strong>方式一：</strong><br>create or replace view 视图名<br>as<br>查询语句;</p><pre class=" language-MySQL"><code class="language-MySQL">CREATE     OR REPLACE VIEW myv3 AS SELECT    AVG( salary ),    job_id FROM    employees GROUP BY    job_id;</code></pre><p><strong>方式二：</strong><br>alter view 视图名<br>as<br>查询语句</p><pre class=" language-MySQL"><code class="language-MySQL">ALTER VIEW myv3 AS SELECT* FROM    employees;</code></pre><h4 id="6-1-4-删除"><a href="#6-1-4-删除" class="headerlink" title="6.1.4 删除"></a>6.1.4 删除</h4><p>drop view 视图1，视图2,…;</p><pre class=" language-MySQL"><code class="language-MySQL">DROP VIEW emp_v1,emp_v2,myv3;</code></pre><h4 id="6-1-5-查看"><a href="#6-1-5-查看" class="headerlink" title="6.1.5 查看"></a>6.1.5 查看</h4><p>desc 视图名;<br>show create view 视图名;</p><pre class=" language-MySQL"><code class="language-MySQL">DESC myv3;SHOW CREATE VIEW myv3;</code></pre><h4 id="6-1-6-使用–视图更新"><a href="#6-1-6-使用–视图更新" class="headerlink" title="6.1.6 使用–视图更新"></a>6.1.6 使用–视图更新</h4><p><strong>插入</strong><br>insert</p><pre class=" language-MySQL"><code class="language-MySQL">INSERT INTO myv1VALUES    ( '张飞', 'zf@qq.com' );</code></pre><p><strong>修改</strong><br>update</p><pre class=" language-MySQL"><code class="language-MySQL">UPDATE myv1 SET last_name = '张无忌' WHERE    last_name = '张飞';</code></pre><p><strong>删除</strong><br>delete</p><pre class=" language-MySQL"><code class="language-MySQL">DELETE FROM    myv1 WHERE    last_name = '张无忌';</code></pre><p><strong>查看</strong><br>select<br><font color="#FF0000"><strong>注意：</strong></font>视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新<br>①包含分组函数、group by、distinct、having、union、union all<br>②join<br>③常量视图<br>④where后的子查询用到了from中的表<br>⑤用到了不可更新的视图</p><h4 id="6-1-7-视图和表的对比"><a href="#6-1-7-视图和表的对比" class="headerlink" title="6.1.7 视图和表的对比"></a>6.1.7 视图和表的对比</h4><table><thead><tr><th></th><th>创建语法关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td>视图</td><td>create view</td><td>只是保存了sql逻辑</td><td>增，删，查，改，只是一般不能增删改</td></tr><tr><td>表</td><td>create table</td><td>保存了数据</td><td></td></tr></tbody></table><h3 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h3><h4 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h4><p><strong>分类</strong><br>一、系统变量<br>说明：变量由系统提供的，不用自定义<br>语法：</p><ul><li>①查看系统变量<br>  show 【global|session 】variables like ‘’; 如果没有显式声明global还是session，则默认是session</li><li>②查看指定的系统变量的值<br>  select @@【global|session】.变量名; 如果没有显式声明global还是session，则默认是session</li></ul><ul><li>③为系统变量赋值<br>  方式一：<br>  set 【global|session 】 变量名=值; 如果没有显式声明global还是session，则默认是session<br>  方式二：<br>  set @@global.变量名=值;<br>  set @@变量名=值；</li></ul><h4 id="6-2-2-全局变量"><a href="#6-2-2-全局变量" class="headerlink" title="6.2.2 全局变量"></a>6.2.2 全局变量</h4><p>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效</p><pre class=" language-MySQL"><code class="language-MySQL">#①查看所有全局变量SHOW GLOBAL VARIABLES;#②查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE '%char%';#③查看指定的系统变量的值SELECT @@global.autocommit;#④为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre><h4 id="6-2-3-会话变量"><a href="#6-2-3-会话变量" class="headerlink" title="6.2.3 会话变量"></a>6.2.3 会话变量</h4><p>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p><pre class=" language-MySQL"><code class="language-MySQL">#①查看所有会话变量SHOW SESSION VARIABLES;#②查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE '%char%';#③查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;#④为某个会话变量赋值SET @@session.tx_isolation='read-uncommitted';SET SESSION tx_isolation='read-committed';</code></pre><h4 id="6-2-4-自定义变量"><a href="#6-2-4-自定义变量" class="headerlink" title="6.2.4 自定义变量"></a>6.2.4 自定义变量</h4><ol><li><p>用户变量<br> 作用域：针对于当前连接（会话）生效<br> 位置：begin end里面，也可以放在外面<br> 使用：</p><ul><li><p>①声明并赋值：<br>  set @变量名=值;或<br>  set @变量名:=值;或<br>  select @变量名:=值;</p></li><li><p>②更新值<br>  方式一：<br>  set @变量名=值;或<br>  set @变量名:=值;或<br>  select @变量名:=值</p><p>  方式二：<br>  select xx into @变量名 from 表;</p></li><li><p>③使用<br>  select @变量名;</p></li></ul></li><li><p>局部变量<br> 作用域：仅仅在定义它的begin end中有效<br> 位置：只能放在begin end中，而且只能放在第一句<br> 使用：</p><ul><li>①声明<br>  declare 变量名 类型<br>  declare 变量名 类型 【default 值】;</li><li>②赋值或更新<br>  方式一：<br>  set 变量名=值;或<br>  set 变量名:=值;或<br>  select @变量名:=值;<br>  方式二：<br>  select xx into 变量名 from 表;</li><li>③使用<br>  select 变量名;</li></ul></li></ol><pre class=" language-MySQL"><code class="language-MySQL">#案例：声明两个变量，求和并打印#用户变量SET @m=1;SET @n=1;SET @sum=@m+@n;SELECT @sum;#局部变量DECLARE m INT DEFAULT 1;DECLARE n INT DEFAULT 1;DECLARE SUM INT;SET SUM=m+n;SELECT SUM;</code></pre><h3 id="6-3-存储过程"><a href="#6-3-存储过程" class="headerlink" title="6.3 存储过程"></a>6.3 存储过程</h3><h4 id="6-3-1-存储过程概述"><a href="#6-3-1-存储过程概述" class="headerlink" title="6.3.1 存储过程概述"></a>6.3.1 存储过程概述</h4><p><strong>含义：</strong>一组预先编译好的SQL语句的集合，理解成批处理语句</p><ol><li>提高代码的重用性</li><li>简化操作</li><li>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</li></ol><h4 id="6-3-2-存储过程创建-★"><a href="#6-3-2-存储过程创建-★" class="headerlink" title="6.3.2 存储过程创建 ★"></a>6.3.2 存储过程创建 ★</h4><pre class=" language-mysql"><code class="language-mysql">create procedure 存储过程名(参数模式 参数名 参数类型)begin        存储过程体（一组合法的SQL语句）end</code></pre><p><font color="#FF0000">注意：</font></p><ol><li>参数模式：<ul><li>in：该参数可以作为输入，也就是该参数需要调用方法入值</li><li>out：该参数可以作为输出，也就是该蚕食可以作为返回值</li><li>inout：该参数既可以作为输入又可以作为输出，也就是该参数需要传入值，又可以返回值</li></ul></li><li>存储过程体的每一条sql语句都需要用分号结尾</li><li>如果存储过程体仅仅只有一句话，begin end可以省略，<br> 存储过程的结尾可以使用 delimiter 重新设置<br> 语法：<br> delimiter 结束标记<br> 案例：<br> delimiter $</li></ol><h4 id="6-3-3-调用"><a href="#6-3-3-调用" class="headerlink" title="6.3.3 调用"></a>6.3.3 调用</h4><p>call 存储过程名(实参列表)<br>举例：</p><ul><li>调用in模式的参数：call sp1（‘值’）;</li><li>调用out模式的参数：set @name; call sp1(@name);select @name;</li><li>调用inout模式的参数：set @name=值; call sp1(@name); select @name;</li></ul><pre class=" language-MySQL"><code class="language-MySQL">#1.空参列表#案例：插入到admin表中五条记录SELECT * FROM admin;DELIMITER $CREATE PROCEDURE myp1()BEGIN    INSERT INTO admin(username,`password`)     VALUES('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');END $#调用CALL myp1()$#2.创建带in模式参数的存储过程#案例1：创建存储过程实现 根据女神名，查询对应的男神信息CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))BEGIN    SELECT bo.*    FROM boys bo    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id    WHERE b.name=beautyName;END $#调用CALL myp2('柳岩')$#案例2 ：创建存储过程实现，用户是否登录成功CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))BEGIN    DECLARE result INT DEFAULT 0;#声明并初始化    SELECT COUNT(*) INTO result#赋值        FROM admin    WHERE admin.username = username    AND admin.password = PASSWORD;        SELECT IF(result>0,'成功','失败');#使用END $#调用CALL myp3('张飞','8888')$#3.创建out 模式参数的存储过程#案例1：根据输入的女神名，返回对应的男神名CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))BEGIN    SELECT bo.boyname INTO boyname    FROM boys bo    RIGHT JOIN    beauty b ON b.boyfriend_id = bo.id    WHERE b.name=beautyName ;END $#案例2：根据输入的女神名，返回对应的男神名和魅力值CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) BEGIN    SELECT boys.boyname ,boys.usercp INTO boyname,usercp    FROM boys     RIGHT JOIN    beauty b ON b.boyfriend_id = boys.id    WHERE b.name=beautyName ;END $#调用CALL myp7('小昭',@name,@cp)$SELECT @name,@cp$#4.创建带inout模式参数的存储过程#案例1：传入a和b两个值，最终a和b都翻倍并返回CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)BEGIN    SET a=a*2;    SET b=b*2;END $#调用SET @m=10$SET @n=20$CALL myp8(@m,@n)$SELECT @m,@n$</code></pre><h4 id="6-3-4-查看"><a href="#6-3-4-查看" class="headerlink" title="6.3.4 查看"></a>6.3.4 查看</h4><pre class=" language-mysql"><code class="language-mysql">show create procedure 存储过程名;</code></pre><pre class=" language-MySQL"><code class="language-MySQL">DESC myp2;#××SHOW CREATE PROCEDURE  myp2;</code></pre><h4 id="6-3-5-删除"><a href="#6-3-5-删除" class="headerlink" title="6.3.5 删除"></a>6.3.5 删除</h4><pre class=" language-mysql"><code class="language-mysql">drop procedure 存储过程名;</code></pre><pre class=" language-MySQL"><code class="language-MySQL">DROP PROCEDURE p1;DROP PROCEDURE p2,p3;#×××</code></pre><h3 id="6-4-函数"><a href="#6-4-函数" class="headerlink" title="6.4 函数"></a>6.4 函数</h3><h4 id="6-4-1-创建函数"><a href="#6-4-1-创建函数" class="headerlink" title="6.4.1 创建函数"></a>6.4.1 创建函数</h4><pre class=" language-mysql"><code class="language-mysql">create function 函数名(参数名 参数类型) returns  返回类型begin    函数体end</code></pre><p><font color="#FF0000">注意：</font>函数体中肯定需要有return语句</p><h4 id="6-4-2-调用函数"><a href="#6-4-2-调用函数" class="headerlink" title="6.4.2 调用函数"></a>6.4.2 调用函数</h4><pre class=" language-mysql"><code class="language-mysql">select 函数名(实参列表);</code></pre><h4 id="6-4-3-查看函数"><a href="#6-4-3-查看函数" class="headerlink" title="6.4.3 查看函数"></a>6.4.3 查看函数</h4><pre class=" language-mysql"><code class="language-mysql">show create function 函数名;</code></pre><h4 id="6-4-4-删除函数"><a href="#6-4-4-删除函数" class="headerlink" title="6.4.4 删除函数"></a>6.4.4 删除函数</h4><pre class=" language-mysql"><code class="language-mysql">drop function 函数名；</code></pre><h4 id="6-4-5-流程控制语句"><a href="#6-4-5-流程控制语句" class="headerlink" title="6.4.5 流程控制语句"></a>6.4.5 流程控制语句</h4><ol><li>if函数<br> 功能：实现简单双分支<br> 语法：if(条件，值1，值2)<br> 位置：可以作为表达式放在任何位置 if结构<br> 功能：实现多分支<br> 语法：<br> if 条件1 then 语句1;<br> elseif 条件2 then 语句2;<br> …<br> else 语句n;<br> end if;<br> 位置：<br> 只能放在begin end</li></ol><pre class=" language-MySQL"><code class="language-MySQL">#案例1：创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回DCREATE FUNCTION test_if(score FLOAT) RETURNS CHARBEGIN    DECLARE ch CHAR DEFAULT 'A';    IF score>90 THEN SET ch='A';    ELSEIF score>80 THEN SET ch='B';    ELSEIF score>60 THEN SET ch='C';    ELSE SET ch='D';    END IF;    RETURN ch;        END $SELECT test_if(87)$#案例2：创建存储过程，如果工资<2000,则删除，如果5000>工资>2000,则涨工资1000，否则涨工资500CREATE PROCEDURE test_if_pro(IN sal DOUBLE)BEGIN    IF sal<2000 THEN DELETE FROM employees WHERE employees.salary=sal;    ELSEIF sal>=2000 AND sal<5000 THEN UPDATE employees SET salary=salary+1000 WHERE employees.`salary`=sal;    ELSE UPDATE employees SET salary=salary+500 WHERE employees.`salary`=sal;    END IF;END $CALL test_if_pro(2100)$</code></pre><ol start="2"><li>case结构—实现多分支</li></ol><ul><li>语法1：<br>  case 表达式或字段<br>  when 值1 then 语句1;<br>  when 值2 then 语句2；<br>  ..<br>  else 语句n;<br>  end [case];</li><li>语法2：<br>  case<br>  when 条件1 then 语句1;<br>  when 条件2 then 语句2；<br>  ..<br>  else 语句n;<br>  end [case];<br>  位置：可以放在任何位置，<br>  如果放在begin end 外面，作为表达式结合着其他语句使用<br>  如果放在begin end 里面，一般作为独立的语句使用</li></ul><pre class=" language-MySQL"><code class="language-MySQL">#案例1：创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回DCREATE FUNCTION test_case(score FLOAT) RETURNS CHARBEGIN     DECLARE ch CHAR DEFAULT 'A';        CASE     WHEN score>90 THEN SET ch='A';    WHEN score>80 THEN SET ch='B';    WHEN score>60 THEN SET ch='C';    ELSE SET ch='D';    END CASE;    RETURN ch;END $SELECT test_case(56)$</code></pre><ol start="3"><li><p>循环结构<br>位置：只能放在begin end中<br>特点：都能实现循环结构<br>对比：<br>①这三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称<br>②loop 一般用于实现简单的死循环<br>while 先判断后执行<br>repeat 先执行后判断，无条件至少执行一次</p><p> leave：类似于break，用于跳出所在的循环<br> iterate：类似于continue，用于结束本次循环，继续下一次</p></li></ol><ul><li>while<br>  语法：<br>【名称:】while 循环条件 do<br>  循环体<br>  end while 【名称】;</li></ul><pre class=" language-MySQL"><code class="language-MySQL">#1.没有添加循环控制语句#案例：批量插入，根据次数插入到admin表中多条记录CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN    DECLARE i INT DEFAULT 1;    WHILE i<=insertCount DO        INSERT INTO admin(username,`password`) VALUES(CONCAT('Rose',i),'666');        SET i=i+1;    END WHILE;    END $CALL pro_while1(100)$#2.添加leave语句#案例：批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN    DECLARE i INT DEFAULT 1;    a:WHILE i<=insertCount DO        INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000');        IF i>=20 THEN LEAVE a;        END IF;        SET i=i+1;    END WHILE a;END $CALL test_while1(100)$#3.添加iterate语句#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN    DECLARE i INT DEFAULT 0;    a:WHILE i<=insertCount DO        SET i=i+1;        IF MOD(i,2)!=0 THEN ITERATE a;        END IF;        INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000');            END WHILE a;END $CALL test_while1(100)$</code></pre><ul><li>loop</li></ul><pre class=" language-mysql"><code class="language-mysql">  【名称：】loop         循环体    end loop 【名称】;</code></pre><ul><li>repeat</li></ul><pre class=" language-mysql"><code class="language-mysql">【名称:】repeat            循环体    until 结束条件     end repeat 【名称】;</code></pre><h4 id="6-4-6-流程控制案例"><a href="#6-4-6-流程控制案例" class="headerlink" title="6.4.6 流程控制案例"></a>6.4.6 流程控制案例</h4><pre class=" language-MySQL"><code class="language-MySQL">/*一、已知表stringcontent其中字段：id 自增长content varchar(20)向该表插入指定个数的，随机的字符串*/DROP TABLE IF EXISTS stringcontent;CREATE TABLE stringcontent(    id INT PRIMARY KEY AUTO_INCREMENT,    content VARCHAR(20)    );DELIMITER $CREATE PROCEDURE test_randstr_insert(IN insertCount INT)BEGIN    DECLARE i INT DEFAULT 1;    DECLARE str VARCHAR(26) DEFAULT 'abcdefghijklmnopqrstuvwxyz';    DECLARE startIndex INT;#代表初始索引    DECLARE len INT;#代表截取的字符长度    WHILE i<=insertcount DO        SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26        SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）        INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));        SET i=i+1;    END WHILE;END $CALL test_randstr_insert(10)$</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础知识（一）</title>
      <link href="/2021/12/30/MySQLBasics/"/>
      <url>/2021/12/30/MySQLBasics/</url>
      
        <content type="html"><![CDATA[<h2 id="1-与MySQL的第一次亲密接触"><a href="#1-与MySQL的第一次亲密接触" class="headerlink" title="1. 与MySQL的第一次亲密接触"></a>1. 与MySQL的第一次亲密接触</h2><h3 id="1-1-数据库的相关概念"><a href="#1-1-数据库的相关概念" class="headerlink" title="1.1 数据库的相关概念"></a>1.1 数据库的相关概念</h3><h4 id="1-1-1-数据库的好处"><a href="#1-1-1-数据库的好处" class="headerlink" title="1.1.1 数据库的好处"></a>1.1.1 数据库的好处</h4><p>(1) 可以持久化数据到本地<br>(2) 结构化查询</p><h4 id="1-1-2-数据库的常见概念"><a href="#1-1-2-数据库的常见概念" class="headerlink" title="1.1.2 数据库的常见概念"></a>1.1.2 数据库的常见概念</h4><p>(1) DB：数据库，存储数据的容器<br>(2) DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB<br>(3) SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</p><h4 id="1-1-3-数据库存储数据的特点"><a href="#1-1-3-数据库存储数据的特点" class="headerlink" title="1.1.3 数据库存储数据的特点"></a>1.1.3 数据库存储数据的特点</h4><p>(1) 数据存放到表中，然后表再放到库中<br>(2) 一个库中可以有多张表，每张表具有唯一的表名用来标识自己<br>(3) 表中有一个或多个列，列又称为“字段”，相当于java中“属性”<br>(4) 表中的每一行数据，相当于java中“对象”</p><h4 id="1-1-4-常见的数据库管理系统"><a href="#1-1-4-常见的数据库管理系统" class="headerlink" title="1.1.4 常见的数据库管理系统"></a>1.1.4 常见的数据库管理系统</h4><p>mysql、oracle、db2、sqlserver</p><h3 id="1-2-MySQL的介绍"><a href="#1-2-MySQL的介绍" class="headerlink" title="1.2 MySQL的介绍"></a>1.2 MySQL的介绍</h3><h4 id="1-2-1-MySQL的背景"><a href="#1-2-1-MySQL的背景" class="headerlink" title="1.2.1 MySQL的背景"></a>1.2.1 MySQL的背景</h4><p>前身属于瑞典的一家公司，MySQL AB<br>08年被sun公司收购<br>09年sun被oracle收购</p><h4 id="1-2-2-MySQL的优点"><a href="#1-2-2-MySQL的优点" class="headerlink" title="1.2.2 MySQL的优点"></a>1.2.2 MySQL的优点</h4><p>(1) 开源、免费、成本低<br>(2) 性能高、移植性也好<br>(3) 体积小，便于安装</p><h4 id="1-2-3-MySQL的安装"><a href="#1-2-3-MySQL的安装" class="headerlink" title="1.2.3 MySQL的安装"></a>1.2.3 MySQL的安装</h4><p>属于c/s架构的软件，一般来讲安装服务端<br>企业版<br>社区版<br>5.5  5.6   5.7 8.0</p><h4 id="1-2-4-MySQL服务的启动和停止"><a href="#1-2-4-MySQL服务的启动和停止" class="headerlink" title="1.2.4 MySQL服务的启动和停止"></a>1.2.4 MySQL服务的启动和停止</h4><p>(1) 通过命令行</p><ul><li>net start 服务名</li><li>net stop 服务名</li></ul><p>(2) 计算机——右击——管理——服务</p><h4 id="1-2-5-MySQL服务的登录和退出"><a href="#1-2-5-MySQL服务的登录和退出" class="headerlink" title="1.2.5 MySQL服务的登录和退出"></a>1.2.5 MySQL服务的登录和退出</h4><p>登录：mysql  -h主机名  -P端口号   -u用户名  -p密码<br>退出：exit或ctrl+c</p><h2 id="2-DQL语言"><a href="#2-DQL语言" class="headerlink" title="2. DQL语言"></a>2. DQL语言</h2><h3 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><p>语法：select  查询列表  from  表名;<br>类似于：System.out.println(打印东西)<br>特点：</p><ul><li>查询列表可以是字段、常量、表达式、函数</li><li>查询结果是一个虚拟表</li></ul><h4 id="2-2-2查询单个字段"><a href="#2-2-2查询单个字段" class="headerlink" title="2.2.2查询单个字段"></a>2.2.2查询单个字段</h4><pre class=" language-MySQL"><code class="language-MySQL">SELECT    last_name FROM    employees;</code></pre><h4 id="2-2-3-查询多个字段"><a href="#2-2-3-查询多个字段" class="headerlink" title="2.2.3 查询多个字段"></a>2.2.3 查询多个字段</h4><pre class=" language-MySQL"><code class="language-MySQL">SELECT    last_name,    salary,    email FROM    employees;</code></pre><h4 id="2-2-4-查询所有字段"><a href="#2-2-4-查询所有字段" class="headerlink" title="2.2.4 查询所有字段"></a>2.2.4 查询所有字段</h4><pre class=" language-MySQL"><code class="language-MySQL">#方式一：SELECT    `employee_id`,    `first_name`,    `last_name`,    `phone_number`,    `last_name`,    `job_id`,    `phone_number`,    `job_id`,    `salary`,    `commission_pct`,    `manager_id`,    `department_id`,    `hiredate` FROM    employees;        #方式二：  SELECT    * FROM    employees;</code></pre><h4 id="2-2-5-查询常量"><a href="#2-2-5-查询常量" class="headerlink" title="2.2.5 查询常量"></a>2.2.5 查询常量</h4><pre class=" language-MySQL"><code class="language-MySQL">SELECT    100;        SELECT    'john';</code></pre><h4 id="2-2-6-查询表达式"><a href="#2-2-6-查询表达式" class="headerlink" title="2.2.6 查询表达式"></a>2.2.6 查询表达式</h4><pre class=" language-MySQL"><code class="language-MySQL">SELECT    100 % 98;</code></pre><h4 id="2-2-7-查询函数"><a href="#2-2-7-查询函数" class="headerlink" title="2.2.7 查询函数"></a>2.2.7 查询函数</h4><pre class=" language-MySQL"><code class="language-MySQL">SELECT    VERSION( );</code></pre><h4 id="2-2-8-起别名"><a href="#2-2-8-起别名" class="headerlink" title="2.2.8 起别名"></a>2.2.8 起别名</h4><pre class=" language-MySQL"><code class="language-MySQL"> #方式一：使用asSELECT    100 % 98 AS 结果;SELECT    last_name AS 姓,    first_name AS 名 FROM    employees;#方式二：使用空格SELECT    last_name 姓,    first_name 名 FROM    employees;#案例：查询salary，显示结果为 out putSELECT    salary AS "out put" FROM    employees;</code></pre><h4 id="2-2-9-去重"><a href="#2-2-9-去重" class="headerlink" title="2.2.9 去重"></a>2.2.9 去重</h4><pre class=" language-MySQL"><code class="language-MySQL">#案例：查询员工表中涉及到的所有的部门编号SELECT DISTINCT    department_id FROM    employees;</code></pre><h4 id="2-2-10-号的作用"><a href="#2-2-10-号的作用" class="headerlink" title="2.2.10 +号的作用"></a>2.2.10 +号的作用</h4><pre class=" language-MySQL"><code class="language-MySQL">/*java中的+号：①运算符，两个操作数都为数值型②连接符，只要有一个操作数为字符串mysql中的+号：仅仅只有一个功能：运算符select 100+90; 两个操作数都为数值型，则做加法运算select '123'+90;只要其中一方为字符型，试图将字符型数值转换成数值型            如果转换成功，则继续做加法运算select 'john'+90;    如果转换失败，则将字符型数值转换成0select null+10; 只要其中一方为null，则结果肯定为null*/#案例：查询员工名和姓连接成一个字段，并显示为 姓名SELECT    CONCAT( 'a', 'b', 'c' ) AS 结果;SELECT    CONCAT( last_name, first_name ) AS 姓名 FROM    employees;</code></pre><h3 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h3><h4 id="2-2-1-概述-1"><a href="#2-2-1-概述-1" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><p><strong>语法：</strong><br>    select 查询列表<br>    from 表名<br>    where 筛选条件</p><p><strong>筛选条件分类</strong></p><ul><li>按条件表达式筛选   &lt;     &gt;     =     &lt;&gt;     !=     &gt;=     &lt;=     &lt;=&gt;</li><li>按逻辑表达式筛选   and     or    not </li><li>模糊查询   like   between…and…   in   (is null/is not null)<br>is null：仅仅可以判断null值<br>&lt;=&gt;:   既可以判断null值又可以判断普通的数值<table><thead><tr><th></th><th>普通类型的数值</th><th>null值</th><th>可读性</th></tr></thead><tbody><tr><td>is null</td><td>×</td><td>√</td><td>√</td></tr><tr><td>&lt;=&gt;</td><td>√</td><td>√</td><td>×</td></tr></tbody></table></li></ul><h4 id="2-2-2按条件表达式筛选"><a href="#2-2-2按条件表达式筛选" class="headerlink" title="2.2.2按条件表达式筛选"></a>2.2.2按条件表达式筛选</h4><pre class=" language-MySQL"><code class="language-MySQL">#案例1：查询工资>12000的员工信息SELECT     *FROM    employeesWHERE    salary>12000;        #案例2：查询部门编号不等于90号的员工名和部门编号SELECT     last_name,    department_idFROM    employeesWHERE    department_id<>90;</code></pre><h4 id="2-2-3-按逻辑表达式筛选"><a href="#2-2-3-按逻辑表达式筛选" class="headerlink" title="2.2.3 按逻辑表达式筛选"></a>2.2.3 按逻辑表达式筛选</h4><pre class=" language-MySQL"><code class="language-MySQL">#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金SELECT    last_name,    salary,    commission_pct FROM    employees WHERE    salary >= 10000     AND salary <= 20000;        #案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息SELECT    *FROM    employeesWHERE    NOT(department_id>=90 AND  department_id<=110) OR salary>15000;</code></pre><h4 id="2-2-4-模糊查询"><a href="#2-2-4-模糊查询" class="headerlink" title="2.2.4 模糊查询"></a>2.2.4 模糊查询</h4><pre class=" language-MySQL"><code class="language-MySQL">/***like****************//*特点：①一般和通配符搭配使用    通配符：    % 任意多个字符,包含0个字符    _ 任意单个字符*/#案例1：查询员工名中包含字符a的员工信息select     *from    employeeswhere    last_name like '%a%';#案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资select    last_name,    salaryFROM    employeesWHERE    last_name LIKE '__n_l%';#案例3：查询员工名中第二个字符为_的员工名SELECT    last_nameFROM    employeesWHERE    last_name LIKE '_$_%' ESCAPE '$';/****between and *********//*①使用between and 可以提高语句的简洁度②包含临界值③两个临界值不要调换顺序*/#案例1：查询员工编号在100到120之间的员工信息SELECT    * FROM    employees WHERE    employee_id >= 120     AND employee_id <= 100;SELECT    *FROM    employeesWHERE    employee_id BETWEEN 120 AND 100;/***********in***********//*含义：判断某字段的值是否属于in列表中的某一项特点：    ①使用in提高语句简洁度    ②in列表的值类型必须一致或兼容    ③in列表中不支持通配符*/#案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号SELECT    last_name,    job_id FROM    employees WHERE    job_id = 'IT_PROT'     OR job_id = 'AD_VP'     OR JOB_ID = 'AD_PRES';SELECT    last_name,    job_id FROM    employees WHERE    job_id IN ( 'IT_PROT', 'AD_VP', 'AD_PRES' );    /******is null***********************//*=或<>不能用于判断null值is null或is not null 可以判断null值*/#案例1：查询没有奖金的员工名和奖金率SELECT    last_name,    commission_pctFROM    employeesWHERE    commission_pct IS NULL;#案例1：查询有奖金的员工名和奖金率SELECT    last_name,    commission_pctFROM    employeesWHERE    commission_pct IS NOT NULL;    #----------以下为×SELECT    last_name,    commission_pctFROM    employeesWHERE     salary IS 12000;    #安全等于  <=>#案例1：查询没有奖金的员工名和奖金率SELECT    last_name,    commission_pctFROM    employeesWHERE    commission_pct <=>NULL;    #案例2：查询工资为12000的员工信息SELECT    last_name,    salaryFROM    employeesWHERE     salary <=> 12000;</code></pre><h3 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h3><h4 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h4><p><strong>语法：</strong><br>select 查询列表<br>from 表<br>where 筛选条件<br>order by 排序列表 【asc}desc】<br><strong>特点：</strong></p><ul><li>asc ：升序，如果不写默认升序<br>   desc：降序</li><li>排序列表 支持 单个字段、多个字段、函数、表达式、别名</li><li>order by的位置一般放在查询语句的最后（除limit语句之外）</li></ul><h4 id="2-3-2-按单个字段排序"><a href="#2-3-2-按单个字段排序" class="headerlink" title="2.3.2 按单个字段排序"></a>2.3.2 按单个字段排序</h4><pre class=" language-mysql"><code class="language-mysql">SELECT    * FROM    employees ORDER BY    salary DESC;</code></pre><h4 id="2-3-3-添加筛选条件再排序"><a href="#2-3-3-添加筛选条件再排序" class="headerlink" title="2.3.3 添加筛选条件再排序"></a>2.3.3 添加筛选条件再排序</h4><pre class=" language-mysql"><code class="language-mysql">#案例：查询部门编号>=90的员工信息，并按员工编号降序SELECT    * FROM    employees WHERE    department_id >= 90 ORDER BY    employee_id DESC;</code></pre><h4 id="2-3-4-按表达式排序"><a href="#2-3-4-按表达式排序" class="headerlink" title="2.3.4 按表达式排序"></a>2.3.4 按表达式排序</h4><pre class=" language-mysql"><code class="language-mysql">#案例：查询员工信息 按年薪降序SELECT    *,    salary * 12 * ( 1+ IFNULL( commission_pct, 0 ) ) FROM    employees ORDER BY    salary * 12 * ( 1+ IFNULL( commission_pct, 0 ) ) DESC;</code></pre><h4 id="2-3-5-按别名排序"><a href="#2-3-5-按别名排序" class="headerlink" title="2.3.5 按别名排序"></a>2.3.5 按别名排序</h4><pre class=" language-mysql"><code class="language-mysql">#案例：查询员工信息 按年薪升序SELECT    *,    salary * 12 * ( 1+ IFNULL( commission_pct, 0 ) ) 年薪 FROM    employees ORDER BY    年薪 ASC;</code></pre><h4 id="2-3-6-按函数排序"><a href="#2-3-6-按函数排序" class="headerlink" title="2.3.6 按函数排序"></a>2.3.6 按函数排序</h4><pre class=" language-mysql"><code class="language-mysql">#案例：查询员工名，并且按名字的长度降序SELECT    LENGTH( last_name ),    last_name FROM    employees ORDER BY    LENGTH( last_name ) DESC;</code></pre><h4 id="2-3-7-按多个字段排序"><a href="#2-3-7-按多个字段排序" class="headerlink" title="2.3.7 按多个字段排序"></a>2.3.7 按多个字段排序</h4><pre class=" language-mysql"><code class="language-mysql">#案例：查询员工信息，要求先按工资降序，再按employee_id升序SELECT    * FROM    employees ORDER BY    salary DESC,    employee_id ASC;</code></pre><h3 id="2-4-常见函数"><a href="#2-4-常见函数" class="headerlink" title="2.4 常见函数"></a>2.4 常见函数</h3><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p><strong>功能</strong>：类似于java中的方法<br><strong>好处</strong>：</p><ul><li>隐藏了实现细节  </li><li>提高代码的重用性</li></ul><p><strong>调用</strong>：select 函数名(实参列表) 【from 表】<br><strong>特点：</strong></p><ul><li>叫什么（函数名）</li><li>干什么（函数功能）</li></ul><p><strong>分类</strong></p><ul><li>单行函数<ul><li>字符函数<br>length:获取字节个数(utf-8一个汉字代表3个字节,gbk为2个字节)、concat、substr、     instr、trim、upper、lower、lpad、rpad、replace</li><li>数学函数<br>round、ceil、floor、truncate、mod</li><li>日期函数：<br>now、curdate、curtime、year、month、monthname、day、hour、minute、   second、str_to_date、date_format</li><li>其他函数：<br>version、database、user</li><li>控制函数<br>if、case</li></ul></li><li>分组函数<br>功能：做统计使用，又称为统计函数、聚合函数、组函数</li></ul><h4 id="2-4-2-字符函数"><a href="#2-4-2-字符函数" class="headerlink" title="2.4.2 字符函数"></a>2.4.2 字符函数</h4><p>length 获取参数值的字节个数</p><pre class=" language-mysql"><code class="language-mysql">SELECT    LENGTH( 'john' );#4SELECT    LENGTH( '张三丰hahaha' );#15</code></pre><p>concat 拼接字符串</p><pre class=" language-mysql"><code class="language-mysql">SELECT    CONCAT( last_name, '_', first_name ) 姓名 FROM    employees;</code></pre><p>upper、lower</p><pre class=" language-mysql"><code class="language-mysql">SELECT    UPPER( 'john' );SELECT    LOWER( 'joHn' );    #示例：将姓变大写，名变小写，然后拼接SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;</code></pre><p>substr、substring</p><pre class=" language-mysql"><code class="language-mysql">#注意：索引从1开始#截取从指定索引处后面所有字符SELECT    SUBSTR( '李莫愁爱上了陆展元', 7 ) out_put;#截取从指定索引处指定字符长度的字符SELECT    SUBSTR( '李莫愁爱上了陆展元', 1, 3 ) out_put;#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来SELECT    CONCAT( UPPER( SUBSTR( last_name, 1, 1 ) ), '_', LOWER( SUBSTR( last_name, 2 ) ) ) out_put FROM    employees;</code></pre><p> instr 返回子串第一次出现的索引，如果找不到返回0</p><pre class=" language-mysql"><code class="language-mysql">SELECT    INSTR( '杨不殷六侠悔爱上了殷六侠', '殷八侠' ) AS out_put;</code></pre><p>trim</p><pre class=" language-mysql"><code class="language-mysql">SELECT    LENGTH( TRIM( '    张翠山    ' ) ) AS out_put;SELECT    TRIM( 'aa' FROM 'aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' ) AS out_put;</code></pre><p> lpad 用指定的字符实现左填充指定长度</p><pre class=" language-mysql"><code class="language-mysql">SELECT    LPAD( '殷素素', 2, '*' ) AS out_put;#殷素</code></pre><p> rpad 用指定的字符实现右填充指定长度</p><pre class=" language-mysql"><code class="language-mysql">SELECT    RPAD( '殷素素', 12, 'ab' ) AS out_put;#殷素素ababababa</code></pre><p> replace 替换</p><pre class=" language-mysql"><code class="language-mysql">SELECT REPLACE    ( '周芷若周芷若周芷若周芷若张无忌爱上了周芷若', '周芷若', '赵敏' ) AS out_put;#赵敏赵敏赵敏赵敏张无忌爱上了赵敏</code></pre><h4 id="2-4-3-数学函数"><a href="#2-4-3-数学函数" class="headerlink" title="2.4.3 数学函数"></a>2.4.3 数学函数</h4><p>round 四舍五入</p><pre class=" language-mysql"><code class="language-mysql">SELECT    ROUND( - 1.55 );#-2    SELECT    ROUND( 1.567, 2 );#1.57</code></pre><p>ceil 向上取整,返回&gt;=该参数的最小整数</p><pre class=" language-mysql"><code class="language-mysql">SELECT    CEIL( - 1.02 );#-1</code></pre><p>floor 向下取整，返回&lt;=该参数的最大整数</p><pre class=" language-mysql"><code class="language-mysql">SELECT    FLOOR( - 9.99 );#-10</code></pre><p>truncate 截断</p><pre class=" language-mysql"><code class="language-mysql">SELECT TRUNCATE    ( 1.69999, 1 );#1.6</code></pre><p>mod取余</p><pre class=" language-mysql"><code class="language-mysql">SELECT MOD    ( 10,- 3 );#1    SELECT    - 10 % 3;#-1</code></pre><h4 id="2-4-4-日期函数"><a href="#2-4-4-日期函数" class="headerlink" title="2.4.4 日期函数"></a>2.4.4 日期函数</h4><p>now 返回当前系统日期+时间</p><pre class=" language-mysql"><code class="language-mysql">SELECT    NOW( );</code></pre><p>curdate 返回当前系统日期，不包含时间</p><pre class=" language-mysql"><code class="language-mysql">SELECT    CURDATE( );</code></pre><p>curtime 返回当前时间，不包含日期</p><pre class=" language-mysql"><code class="language-mysql">SELECT    CURTIME( );</code></pre><p>获取指定的部分，年、月、日、小时、分钟、秒</p><pre class=" language-mysql"><code class="language-mysql">SELECT YEAR    ( NOW( ) ) 年;    SELECT YEAR    ( '1998-1-1' ) 年;SELECT MONTH    ( NOW( ) ) 月;    SELECT    MONTHNAME( NOW( ) ) 月;</code></pre><p>str_to_date 将字符通过指定的格式转换成日期</p><pre class=" language-mysql"><code class="language-mysql">SELECT    STR_TO_DATE( '1998-3-2', '%Y-%c-%d' ) AS out_put;#1998-03-02;SELECT    * FROM    employees WHERE    hiredate = STR_TO_DATE( '4-3 1992', '%c-%d %Y' );</code></pre><p>date_format 将日期转换成字符</p><pre class=" language-mysql"><code class="language-mysql">SELECT    DATE_FORMAT( NOW( ), '%y年%m月%d日' ) AS out_put;</code></pre><h4 id="2-4-5-其他函数"><a href="#2-4-5-其他函数" class="headerlink" title="2.4.5 其他函数"></a>2.4.5 其他函数</h4><pre class=" language-mysql"><code class="language-mysql">SELECT VERSION();SELECT DATABASE();SELECT USER();</code></pre><h4 id="2-4-6-流程控制函数"><a href="#2-4-6-流程控制函数" class="headerlink" title="2.4.6 流程控制函数"></a>2.4.6 流程控制函数</h4><pre class=" language-mysql"><code class="language-mysql">#1.if函数： if else 的效果SELECTIF    ( 10 < 5, '大', '小' );SELECT    last_name,    commission_pct,IF    ( commission_pct IS NULL, '没奖金，呵呵', '有奖金，嘻嘻' ) 备注 FROM    employees;    #案例：查询员工的工资的情况#如果工资>20000,显示A级别#如果工资>15000,显示B级别#如果工资>10000，显示C级别#否则，显示D级别SELECT salary,CASE WHEN salary>20000 THEN 'A'WHEN salary>15000 THEN 'B'WHEN salary>10000 THEN 'C'ELSE 'D'END AS 工资级别FROM employees;/*案例：查询员工的工资，要求部门号=30，显示的工资为1.1倍部门号=40，显示的工资为1.2倍部门号=50，显示的工资为1.3倍其他部门，显示的工资为原工资*/SELECT salary 原始工资,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS 新工资FROM employees;</code></pre><h4 id="2-4-7-分组函数"><a href="#2-4-7-分组函数" class="headerlink" title="2.4.7 分组函数"></a>2.4.7 分组函数</h4><ul><li>功能：用作统计使用，又称为聚合函数或统计函数或组函数</li><li>分类：<br>sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数</li><li>特点：<ul><li>sum、avg一般用于处理数值型</li><li>max、min、count可以处理任何类型</li><li>以上分组函数都忽略null值</li><li>可以和distinct搭配实现去重的运算</li><li>count函数的单独介绍<br>一般使用count(*)用作统计行数</li><li>和分组函数一同查询的字段要求是group by后的字段</li></ul></li></ul><p>简单 的使用</p><pre class=" language-mysql"><code class="language-mysql">#1、简单 的使用SELECT    SUM( salary ) FROM    employees;    SELECT    AVG( salary ) FROM    employees;    SELECT    MIN( salary ) FROM    employees;    SELECT    MAX( salary ) FROM    employees;    SELECT    COUNT( salary ) FROM    employees;    SELECT    SUM( salary ) 和,    AVG( salary ) 平均,    MAX( salary ) 最高,    MIN( salary ) 最低,    COUNT( salary ) 个数 FROM    employees;    SELECT    SUM( salary ) 和,    ROUND( AVG( salary ), 2 ) 平均,    MAX( salary ) 最高,    MIN( salary ) 最低,    COUNT( salary ) 个数 FROM    employees;</code></pre><p>参数支持哪些类型</p><pre class=" language-mysql"><code class="language-mysql">#2、参数支持哪些类型SELECT    SUM( last_name ),    AVG( last_name ) FROM    employees;    SELECT    SUM( hiredate ),    AVG( hiredate ) FROM    employees;    SELECT    MAX( last_name ),    MIN( last_name ) FROM    employees;    SELECT    MAX( hiredate ),    MIN( hiredate ) FROM    employees;    SELECT    COUNT( commission_pct ) FROM    employees;    SELECT    COUNT( last_name ) FROM    employees;</code></pre><p>是否忽略null（忽略）</p><pre class=" language-mysql"><code class="language-mysql">SELECT    SUM( commission_pct ),    AVG( commission_pct ),    SUM( commission_pct ) / 35,    SUM( commission_pct ) / 107 FROM    employees;    SELECT    MAX( commission_pct ),    MIN( commission_pct ) FROM    employees;SELECT    COUNT( commission_pct ) FROM    employees;    SELECT    commission_pct FROM    employees;</code></pre><p>和distinct搭配</p><pre class=" language-mysql"><code class="language-mysql">SELECT    SUM( DISTINCT salary ),    SUM( salary ) FROM    employees;    SELECT    COUNT( DISTINCT salary ),    COUNT( salary ) FROM    employees;</code></pre><p>count函数的详细介绍</p><pre class=" language-mysql"><code class="language-mysql">SELECT    COUNT( salary ) FROM    employees;    SELECT    COUNT( * ) FROM    employees;    SELECT    COUNT( 1 ) FROM    employees;/*效率：MYISAM存储引擎下  ，COUNT(*)的效率高INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些*/</code></pre><p>和分组函数一同查询的字段有限制</p><pre class=" language-mysql"><code class="language-mysql">SELECT    AVG( salary ),    employee_id FROM    employees;</code></pre><h3 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><ul><li><p><strong>语法：</strong><br>select 查询列表<br>from 表<br>【where 筛选条件】<br>group by 分组的字段<br>【order by 排序的字段】;</p></li><li><p><strong>特点：</strong></p><ul><li><p>和分组函数一同查询的字段必须是group by后出现的字段</p></li><li><p>筛选分为两类：分组前筛选和分组后筛选</p></li><li><table><thead><tr><th></th><th>针对的表</th><th>位置</th><th>连接的关键字</th></tr></thead><tbody><tr><td>分组前筛选</td><td>原始表</td><td>group by前</td><td>where</td></tr><tr><td>分组后筛选</td><td>group by后的结果集</td><td>group by后</td><td>group by后  having</td></tr></tbody></table></li><li><p>分组函数做筛选不能放在where后面</p></li><li><p>where——group by——having<br> 一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率</p></li><li><p>分组可以按单个字段也可以按多个字段</p></li><li><p>可以搭配着排序使用</p></li></ul></li></ul><h4 id="2-5-2-简单分组"><a href="#2-5-2-简单分组" class="headerlink" title="2.5.2 简单分组"></a>2.5.2 简单分组</h4><pre class=" language-mysql"><code class="language-mysql">#案例1：查询每个工种的员工平均工资SELECT    AVG( salary ),    job_id FROM    employees GROUP BY    job_id;#案例2：查询每个位置的部门个数SELECT    COUNT( * ),    location_id FROM    departments GROUP BY    location_id;</code></pre><h4 id="2-5-3-分组前的筛选"><a href="#2-5-3-分组前的筛选" class="headerlink" title="2.5.3 分组前的筛选"></a>2.5.3 分组前的筛选</h4><pre class=" language-mysql"><code class="language-mysql">#案例1：查询邮箱中包含a字符的 每个部门的最高工资SELECT    MAX( salary ),    department_id FROM    employees WHERE    email LIKE '%a%' GROUP BY    department_id;#案例2：查询有奖金的每个领导手下员工的平均工资SELECT    AVG( salary ),    manager_id FROM    employees WHERE    commission_pct IS NOT NULL GROUP BY    manager_id;</code></pre><h4 id="2-5-4-分组后筛选"><a href="#2-5-4-分组后筛选" class="headerlink" title="2.5.4 分组后筛选"></a>2.5.4 分组后筛选</h4><pre class=" language-mysql"><code class="language-mysql">#案例：查询哪个部门的员工个数>5#①查询每个部门的员工个数SELECT    COUNT( * ),    department_id FROM    employees GROUP BY    department_id;#② 筛选刚才①结果SELECT    COUNT( * ),    department_id FROM    employees GROUP BY    department_id HAVING    COUNT( * ) > 5;#案例2：每个工种有奖金的员工的最高工资>12000的工种编号和最高工资SELECT    job_id,    MAX( salary ) FROM    employees WHERE    commission_pct IS NOT NULL GROUP BY    job_id HAVING    MAX( salary ) > 12000;#案例3：领导编号>102的每个领导手下的最低工资大于5000的领导编号和最低工资SELECT    manager_id,    MIN( salary ) FROM    employees GROUP BY    manager_id HAVING    MIN( salary ) > 5000;</code></pre><h4 id="2-5-5-添加排序"><a href="#2-5-5-添加排序" class="headerlink" title="2.5.5 添加排序"></a>2.5.5 添加排序</h4><pre class=" language-mysql"><code class="language-mysql">#案例：每个工种有奖金的员工的最高工资>6000的工种编号和最高工资,按最高工资升序SELECT    job_id,    MAX( salary ) m FROM    employees WHERE    commission_pct IS NOT NULL GROUP BY    job_id HAVING    m > 6000 ORDER BY    m;</code></pre><h4 id="2-5-6-按多个字段分组"><a href="#2-5-6-按多个字段分组" class="headerlink" title="2.5.6 按多个字段分组"></a>2.5.6 按多个字段分组</h4><pre class=" language-mysql"><code class="language-mysql">#案例：查询每个工种每个部门的最低工资,并按最低工资降序SELECT    MIN( salary ),    job_id,    department_id FROM    employees GROUP BY    department_id,    job_id ORDER BY    MIN( salary ) DESC;</code></pre><h3 id="2-6-连接查询"><a href="#2-6-连接查询" class="headerlink" title="2.6 连接查询"></a>2.6 连接查询</h3><h4 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1 概述"></a>2.6.1 概述</h4><ul><li><strong>含义</strong>：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</li><li><strong>笛卡尔乘积现象</strong>：表1 有m行，表2有n行，结果=m*n行。当查询多个表时，没有添加        有效的连接条件，导致多个表所有行实现完全连接<ul><li>发生原因：没有有效的连接条件</li><li>如何避免：添加有效的连接条件</li></ul></li><li><strong>分类</strong>：<ul><li><strong>按年代分类：</strong><ul><li>sql92标准:仅仅支持内连接</li><li>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</li></ul></li><li><strong>按功能分类</strong>：<ul><li>内连接：等值连接、非等值连接、自连接</li><li>外连接：左外连接、右外连接、全外连接、交叉连接</li></ul></li><li><strong>等值连接（sql92）</strong><br>  多表连接的结果为多表的交集部分<br>  n表连接，至少需要n-1个连接条件<br>  多表的顺序没有要求<br>  一般需要为表起别名<br> 可以搭配前面介绍的所有子句进行搭配使用</li></ul></li></ul><h4 id="2-6-2-sql92标准—等值连接"><a href="#2-6-2-sql92标准—等值连接" class="headerlink" title="2.6.2 sql92标准—等值连接"></a>2.6.2 sql92标准—等值连接</h4><ol><li>多表等值连接的结果为多表的交集部分</li><li>n表连接，至少需要n-1个连接条件</li><li> 多表的顺序没有要求</li><li>一般需要为表起别名</li><li>可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</li></ol><pre class=" language-mysql"><code class="language-mysql">#案例1：查询女神名和对应的男神名SELECT NAME    ,    boyName FROM    boys,    beauty WHERE    beauty.boyfriend_id = boys.id;#案例2：查询员工名和对应的部门名SELECT    last_name,    department_name FROM    employees,    departments WHERE    employees.`department_id` = departments.`department_id`;</code></pre><p><strong>为表起别名</strong></p><ol><li>提高语句的简洁度</li><li>区分多个重名的字段</li></ol><p>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定     </p><pre class=" language-mysql"><code class="language-mysql">#查询员工名、工种号、工种名SELECT    e.last_name,    e.job_id,    j.job_title FROM    employees e,    jobs j WHERE    e.`job_id` = j.`job_id`;</code></pre><p><strong>两个表的顺序是否可以调换</strong></p><pre class=" language-mysql"><code class="language-mysql">#查询员工名、工种号、工种名SELECT    e.last_name,    e.job_id,    j.job_title FROM    jobs j,    employees e WHERE    e.`job_id` = j.`job_id`;</code></pre><p><strong>可以加筛选</strong></p><pre class=" language-mysql"><code class="language-mysql">#案例：查询有奖金的员工名、部门名SELECT    last_name,    department_name,    commission_pct FROM    employees e,    departments d WHERE    e.`department_id` = d.`department_id`     AND e.`commission_pct` IS NOT NULL;#案例2：查询城市名中第二个字符为o的部门名和城市名SELECT    department_name,    city FROM    departments d,    locations l WHERE    d.`location_id` = l.`location_id`     AND city LIKE '_o%';</code></pre><p><strong>可以加分组</strong></p><pre class=" language-mysql"><code class="language-mysql">#案例1：查询每个城市的部门个数SELECT    COUNT( * ) 个数,    city FROM    departments d,    locations l WHERE    d.`location_id` = l.`location_id` GROUP BY    city;#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资SELECT    department_name,    d.`manager_id`,    MIN( salary ) FROM    departments d,    employees e WHERE    d.`department_id` = e.`department_id`     AND commission_pct IS NOT NULL GROUP BY    department_name,    d.`manager_id`;</code></pre><p><strong>可以加排序</strong></p><pre class=" language-mysql"><code class="language-mysql">#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序SELECT    job_title,    COUNT( * ) FROM    employees e,    jobs j WHERE    e.`job_id` = j.`job_id` GROUP BY    job_title ORDER BY    COUNT( * ) DESC;</code></pre><p><strong>可以实现三表连接</strong></p><pre class=" language-mysql"><code class="language-mysql">#案例：查询员工名、部门名和所在的城市SELECT    last_name,    department_name,    city FROM    employees e,    departments d,    locations l WHERE    e.`department_id` = d.`department_id`     AND d.`location_id` = l.`location_id`     AND city LIKE 's%' ORDER BY    department_name DESC;</code></pre><h4 id="2-6-3-sql92标准—非等值连接"><a href="#2-6-3-sql92标准—非等值连接" class="headerlink" title="2.6.3 sql92标准—非等值连接"></a>2.6.3 sql92标准—非等值连接</h4><pre class=" language-mysql"><code class="language-mysql">#案例1：查询员工的工资和工资级别SELECT    salary,    grade_level FROM    employees e,    job_grades g WHERE    salary BETWEEN g.`lowest_sal`     AND g.`highest_sal`     AND g.`grade_level` = 'A';</code></pre><h4 id="2-6-4-sql92标准—自连接"><a href="#2-6-4-sql92标准—自连接" class="headerlink" title="2.6.4 sql92标准—自连接"></a>2.6.4 sql92标准—自连接</h4><pre class=" language-mysql"><code class="language-mysql">#案例：查询 员工名和上级的名称SELECT    e.employee_id,    e.last_name,    m.employee_id,    m.last_name FROM    employees e,    employees m WHERE    e.`manager_id` = m.`employee_id`;</code></pre><h4 id="2-6-5-sql99标准—等值连接"><a href="#2-6-5-sql99标准—等值连接" class="headerlink" title="2.6.5 sql99标准—等值连接"></a>2.6.5 sql99标准—等值连接</h4><p><strong>1. 语法：</strong><br>    select 查询列表<br>    from 表1 别名 【连接类型】<br>    join 表2 别名<br>    on 连接条件<br>    【where 筛选条件】<br>    【group by 分组】<br>    【having 筛选条件】<br>    【order by 排序列表】<br><strong>2. 分类：</strong><br>    <strong>内连接（★）</strong>：inner<br>    <strong>语法：</strong><br>            select 查询列表<br>            from 表1 别名<br>            inner join 表2 别名<br>            on 连接条件;<br>            分类：<br>                等值<br>                非等值<br>                自连接<br>            <strong>特点：</strong><br>                ①添加排序、分组、筛选<br>                ②inner可以省略<br>                ③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>                ④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集<br>   <strong>外连接</strong><br>         左外(★):left 【outer】<br>         右外(★)：right 【outer】<br>         全外：full【outer】<br>   交叉连接：cross<br>#sql92和 sql99pk<br>功能：sql99支持的较多<br>可读性：sql99实现连接条件和筛选条件的分离，可读性较高</p><pre class=" language-mysql"><code class="language-mysql">#1、等值连接#案例1.查询员工名、部门名SELECT    last_name,    department_name FROM    departments d    JOIN employees e ON e.`department_id` = d.`department_id`;#案例2.查询名字中包含e的员工名和工种名（添加筛选）SELECT    last_name,    job_title FROM    employees e    INNER JOIN jobs j ON e.`job_id` = j.`job_id` WHERE    e.`last_name` LIKE '%e%';#3. 查询部门个数>3的城市名和部门个数，（添加分组+筛选）#①查询每个城市的部门个数#②在①结果上筛选满足条件的SELECT    city,    COUNT( * ) 部门个数 FROM    departments d    INNER JOIN locations l ON d.`location_id` = l.`location_id` GROUP BY    city HAVING    COUNT( * ) > 3;#案例4.查询哪个部门的员工个数>3的部门名和员工个数，并按个数降序（添加排序）#①查询每个部门的员工个数SELECT    COUNT( * ),    department_name FROM    employees e    INNER JOIN departments d ON e.`department_id` = d.`department_id` GROUP BY    department_name#② 在①结果上筛选员工个数>3的记录，并排序SELECT    COUNT( * ) 个数,    department_name FROM    employees e    INNER JOIN departments d ON e.`department_id` = d.`department_id` GROUP BY    department_name HAVING    COUNT( * ) > 3 ORDER BY    COUNT( * ) DESC;#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）SELECT    last_name,    department_name,    job_title FROM    employees e    INNER JOIN departments d ON e.`department_id` = d.`department_id`    INNER JOIN jobs j ON e.`job_id` = j.`job_id` ORDER BY    department_name DESC;</code></pre><h4 id="2-6-6-sql99标准—非等值连接"><a href="#2-6-6-sql99标准—非等值连接" class="headerlink" title="2.6.6 sql99标准—非等值连接"></a>2.6.6 sql99标准—非等值连接</h4><pre class=" language-mysql"><code class="language-mysql">#二）非等值连接#查询员工的工资级别SELECT    salary,    grade_level FROM    employees e    JOIN job_grades g ON e.`salary` BETWEEN g.`lowest_sal`     AND g.`highest_sal`; #查询工资级别的个数>20的个数，并且按工资级别降序SELECT    COUNT( * ),    grade_level FROM    employees e    JOIN job_grades g ON e.`salary` BETWEEN g.`lowest_sal`     AND g.`highest_sal` GROUP BY    grade_level HAVING    COUNT( * ) > 20 ORDER BY    grade_level DESC;</code></pre><h4 id="2-6-7-sql99标准—自连接"><a href="#2-6-7-sql99标准—自连接" class="headerlink" title="2.6.7 sql99标准—自连接"></a>2.6.7 sql99标准—自连接</h4><pre class=" language-mysql"><code class="language-mysql"> #查询员工的名字、上级的名字SELECT    e.last_name,    m.last_name FROM    employees e    JOIN employees m ON e.`manager_id` = m.`employee_id`;  #查询姓名中包含字符k的员工的名字、上级的名字SELECT    e.last_name,    m.last_name FROM    employees e    JOIN employees m ON e.`manager_id` = m.`employee_id` WHERE    e.`last_name` LIKE '%k%';</code></pre><h4 id="2-6-8-sql99标准—外连接"><a href="#2-6-8-sql99标准—外连接" class="headerlink" title="2.6.8 sql99标准—外连接"></a>2.6.8 sql99标准—外连接</h4><p><strong>应用场景：</strong>用于查询一个表中有，另一个表没有的记录</p><p><strong>特点：</strong></p><ol><li>外连接的查询结果为主表中的所有记录<br>如果从表中有和它匹配的，则显示匹配的值<br>如果从表中没有和它匹配的，则显示null<br>外连接查询结果=内连接结果+主表中有而从表没有的记录</li><li>左外连接，left join左边的是主表</li><li>右外连接，right join右边的是主表</li><li>左外和右外交换两个表的顺序，可以实现同样的效果 </li><li>全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的</li></ol><pre class=" language-mysql"><code class="language-mysql"> #左外连接SELECT    b.*,    bo.* FROM    boys bo    LEFT OUTER JOIN beauty b ON b.`boyfriend_id` = bo.`id` WHERE    b.`id` IS NULL;  #案例1：查询哪个部门没有员工#左外SELECT    d.*,    e.employee_id FROM    departments d    LEFT OUTER JOIN employees e ON d.`department_id` = e.`department_id` WHERE    e.`employee_id` IS NULL;  #右外SELECT    d.*,    e.employee_id FROM    employees e    RIGHT OUTER JOIN departments d ON d.`department_id` = e.`department_id` WHERE    e.`employee_id` IS NULL;   #全外USE girls;SELECT    b.*,    bo.* FROM    beauty b    FULL OUTER JOIN boys bo ON b.`boyfriend_id` = bo.id; #交叉连接SELECT    b.*,    bo.* FROM    beauty b    CROSS JOIN boys bo;</code></pre><h3 id="2-7-子查询"><a href="#2-7-子查询" class="headerlink" title="2.7 子查询"></a>2.7 子查询</h3><h4 id="2-7-1-概述"><a href="#2-7-1-概述" class="headerlink" title="2.7.1 概述"></a>2.7.1 概述</h4><p><strong>1. 含义</strong>：出现在其他语句中的select语句，称为子查询或内查询。外部的查询语句，称为主查询或外查询。外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多，外面如果为select语句，则此语句称为外查询或主查询。</p><p><strong>2. 分类</strong>：</p><ul><li><strong>按子查询出现的位置</strong>：<br>  <strong>select后面</strong>：仅仅支持标量子查询<br>  <strong>from后面</strong>：支持表子查询<br>  <strong>where或having后面</strong>：★<br>  标量子查询（单行） √<br>  列子查询  （多行） √<br>   行子查询<br>   <strong>exists后面</strong>（相关子查询）<br>   标量子查询<br>  列子查询<br>  行子查询<br>  表子查询</li><li><strong>按结果集的行列数不同</strong>：<br> 标量子查询（结果集只有一行一列）<br> 列子查询（结果集只有一列多行）<br> 行子查询（结果集有一行多列）<br> 表子查询（结果集一般为多行多列）</li><li><strong>特点：</strong><br>①子查询放在小括号内<br>②子查询一般放在条件的右侧<br>③标量子查询，一般搭配着单行操作符使用 &gt; &lt; &gt;= &lt;= = &lt;&gt;<br> 列子查询，一般搭配着多行操作符使用<br> in（任意一个）、any/some(某一个)、all（所有）<br>④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</li></ul><h4 id="2-7-2-where或having后面"><a href="#2-7-2-where或having后面" class="headerlink" title="2.7.2   where或having后面"></a>2.7.2   where或having后面</h4><ul><li>标量子查询（单行子查询）</li><li>列子查询（多行子查询）</li><li>行子查询（多列多行）</li></ul><p><strong>特点：</strong></p><ol><li>子查询放在小括号内</li><li>子查询一般放在条件的右侧</li><li>标量子查询，一般搭配着单行操作符使用 &gt; &lt; &gt;= &lt;= = &lt;&gt;<br> 列子查询，一般搭配着多行操作符使用in、any/some、all</li><li>子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</li></ol><p> <strong>标量子查询</strong></p><pre class=" language-mysql"><code class="language-mysql">#案例1：谁的工资比 Abel 高?#①查询Abel的工资SELECT    salary FROM    employees WHERE    last_name = 'Abel'#②查询员工的信息，满足 salary>①结果SELECT    * FROM    employees WHERE    salary > ( SELECT salary FROM employees WHERE last_name = 'Abel' );#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资#①查询141号员工的job_idSELECT    job_id FROM    employees WHERE    employee_id = 141#②查询143号员工的salarySELECT    salary FROM    employees WHERE    employee_id = 143#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary>②SELECT    last_name,    job_id,    salary FROM    employees WHERE    job_id = ( SELECT job_id FROM employees WHERE employee_id = 141 )     AND salary > ( SELECT salary FROM employees WHERE employee_id = 143 );#案例3：返回公司工资最少的员工的last_name,job_id和salary#①查询公司的 最低工资SELECT    MIN( salary ) FROM    employees#②查询last_name,job_id和salary，要求salary=①SELECT    last_name,    job_id,    salary FROM    employees WHERE    salary = ( SELECT MIN( salary ) FROM employees );#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资#①查询50号部门的最低工资SELECT    MIN( salary ) FROM    employees WHERE    department_id = 50#②查询每个部门的最低工资SELECT    MIN( salary ),    department_id FROM    employees GROUP BY    department_id#③ 在②基础上筛选，满足min(salary)>①SELECT    MIN( salary ),    department_id FROM    employees GROUP BY    department_id HAVING    MIN( salary ) > ( SELECT MIN( salary ) FROM employees WHERE department_id = 50 );#非法使用标量子查询SELECT    MIN( salary ),    department_id FROM    employees GROUP BY    department_id HAVING    MIN( salary ) > ( SELECT salary FROM employees WHERE department_id = 250 );</code></pre><p><strong>列子查询（多行子查询）</strong></p><pre class=" language-mysql"><code class="language-mysql">#案例1：返回location_id是1400或1700的部门中的所有员工姓名#①查询location_id是1400或1700的部门编号SELECT DISTINCT    department_id FROM    departments WHERE    location_id IN ( 1400, 1700 )#②查询员工姓名，要求部门号是①列表中的某一个SELECT    last_name FROM    employees WHERE    department_id <> ALL ( SELECT DISTINCT department_id FROM departments WHERE location_id IN ( 1400, 1700 ) );#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary#①查询job_id为‘IT_PROG’部门任一工资SELECT DISTINCT    salary FROM    employees WHERE    job_id = 'IT_PROG'#②查询员工号、姓名、job_id 以及salary，salary<(①)的任意一个SELECT    last_name,    employee_id,    job_id,    salary FROM    employees WHERE    salary < ANY ( SELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG' )     AND job_id <> 'IT_PROG';#或SELECT    last_name,    employee_id,    job_id,    salary FROM    employees WHERE    salary < ( SELECT MAX( salary ) FROM employees WHERE job_id = 'IT_PROG' )     AND job_id <> 'IT_PROG';#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salarySELECT    last_name,    employee_id,    job_id,    salary FROM    employees WHERE    salary < ALL ( SELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG' )     AND job_id <> 'IT_PROG';#或SELECT    last_name,    employee_id,    job_id,    salary FROM    employees WHERE    salary < ( SELECT MIN( salary ) FROM employees WHERE job_id = 'IT_PROG' )     AND job_id <> 'IT_PROG';</code></pre><p><strong>行子查询（结果集一行多列或多行多列）</strong></p><pre class=" language-mysql"><code class="language-mysql">#3、行子查询（结果集一行多列或多行多列）#案例：查询员工编号最小并且工资最高的员工信息SELECT    * FROM    employees WHERE    ( employee_id, salary ) = ( SELECT MIN( employee_id ), MAX( salary ) FROM employees );#①查询最小的员工编号SELECT    MIN( employee_id ) FROM    employees#②查询最高工资SELECT    MAX( salary ) FROM    employees#③查询员工信息SELECT    * FROM    employees WHERE    employee_id = ( SELECT MIN( employee_id ) FROM employees )     AND salary = ( SELECT MAX( salary ) FROM employees );</code></pre><h4 id="2-7-3-select后面"><a href="#2-7-3-select后面" class="headerlink" title="2.7.3 select后面"></a>2.7.3 select后面</h4><p><strong>仅仅支持标量子查询</strong></p><pre class=" language-mysql"><code class="language-mysql">#案例：查询每个部门的员工个数SELECT    d.*,    ( SELECT COUNT( * ) FROM employees e WHERE e.department_id = d.`department_id` ) 个数 FROM    departments d;  #案例2：查询员工号=102的部门名SELECT    (SELECT    department_name,    e.department_id FROM    departments d    INNER JOIN employees e ON d.department_id = e.department_id WHERE    e.employee_id = 102     ) 部门名;</code></pre><h4 id="2-7-4-from后面"><a href="#2-7-4-from后面" class="headerlink" title="2.7.4 from后面"></a>2.7.4 from后面</h4><p><strong>将子查询结果充当一张表，要求必须起别名</strong></p><pre class=" language-mysql"><code class="language-mysql">#案例：查询每个部门的平均工资的工资等级#①查询每个部门的平均工资SELECT    AVG( salary ),    department_id FROM    employees GROUP BY    department_id#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_salSELECT    ag_dep.*,    g.`grade_level` FROM    ( SELECT AVG( salary ) ag, department_id FROM employees GROUP BY department_id ) ag_dep    INNER JOIN job_grades g ON ag_dep.ag BETWEEN lowest_sal     AND highest_sal;</code></pre><h4 id="2-7-5-exists后面（相关子查询）"><a href="#2-7-5-exists后面（相关子查询）" class="headerlink" title="2.7.5 exists后面（相关子查询）"></a>2.7.5 exists后面（相关子查询）</h4><p><strong>语法：</strong> exists(完整的查询语句)    结果：1或0</p><pre class=" language-mysql"><code class="language-mysql">#案例1：查询有员工的部门名#inSELECT    department_name FROM    departments d WHERE    d.`department_id` IN ( SELECT department_id FROM employees )#existsSELECT    department_name FROM    departments d WHERE    EXISTS ( SELECT * FROM employees e WHERE d.`department_id` = e.`department_id` );#案例2：查询没有女朋友的男神信息#inSELECT    bo.* FROM    boys bo WHERE    bo.id NOT IN ( SELECT boyfriend_id FROM beauty )#existsSELECT    bo.* FROM    boys bo WHERE    NOT EXISTS ( SELECT boyfriend_id FROM beauty b WHERE bo.`id` = b.`boyfriend_id` );</code></pre><h3 id="2-8-分页查询"><a href="#2-8-分页查询" class="headerlink" title="2.8 分页查询"></a>2.8 分页查询</h3><h4 id="2-8-1-概述"><a href="#2-8-1-概述" class="headerlink" title="2.8.1 概述"></a>2.8.1 概述</h4><p><strong>1. 应用场景</strong>：当要显示的数据，一页显示不全，需要分页提交sql请求<br><strong>2. 语法</strong>：<br>    select 查询列表<br>    from 表<br>    【join type join】 表2<br>    on 连接条件<br>    where 筛选条件<br>    group by 分组字段<br>    having 分组后的筛选<br>    order by 排序的字段】<br>    limit 【offset,】size;</p><p>offset要显示条目的起始索引（起始索引从0开始）<br>size 要显示的条目个数<br><strong>3. 特点</strong>：<br>①limit语句放在查询语句的最后<br>②公式<br>要显示的页数 page，每页的条目数size</p><p>select 查询列表<br>from 表<br>limit (page-1)*size,size;</p><pre class=" language-mysql"><code class="language-mysql">#案例1：查询前五条员工信息SELECT    * FROM    employees     LIMIT 0,    5;        SELECT    * FROM    employees     LIMIT 5;#案例2：查询第11条——第25条SELECT    * FROM    employees     LIMIT 10,    15;#案例3：有奖金的员工信息，并且工资较高的前10名显示出来SELECT    * FROM    employees WHERE    commission_pct IS NOT NULL ORDER BY    salary DESC     LIMIT 10;</code></pre><h3 id="2-8-联合查询"><a href="#2-8-联合查询" class="headerlink" title="2.8 联合查询"></a>2.8 联合查询</h3><h4 id="2-8-1-概述-1"><a href="#2-8-1-概述-1" class="headerlink" title="2.8.1 概述"></a>2.8.1 概述</h4><p><strong>union</strong> 联合 合并：将多条查询语句的结果合并成一个结果<br>语法：<br>查询语句1<br>union<br>查询语句2<br>union<br>…<br><strong>应用场景：</strong><br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</p><p><strong>特点</strong>：★<br>1、要求多条查询语句的查询列数是一致的！<br>2、要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3、union关键字默认去重，如果使用union all 可以包含重复项</p><pre class=" language-mysql"><code class="language-mysql">#引入的案例：查询部门编号>90或邮箱包含a的员工信息SELECT    * FROM    employees WHERE    email LIKE '%a%'     OR department_id > 90;SELECT    * FROM    employees WHERE    email LIKE '%a%';UNIONSELECT    * FROM    employees WHERE    department_id > 90;        #案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息SELECT    id,    cname FROM    t_ca WHERE    csex = '男' UNION ALLSELECT    t_id,    tname FROM    t_ua WHERE    tGender = 'male';</code></pre><h3 id="2-9-查询总结"><a href="#2-9-查询总结" class="headerlink" title="2.9 查询总结"></a>2.9 查询总结</h3><p><strong>语法：</strong><br>select 查询列表    ⑦<br>from 表1 别名       ①<br>连接类型 join 表2   ②<br>on 连接条件         ③<br>where 筛选          ④<br>group by 分组列表   ⑤<br>having 筛选         ⑥<br>order by排序列表    ⑧<br>limit 起始条目索引，条目数;  ⑨</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试基础知识</title>
      <link href="/2021/12/29/softwareTestingBasics/"/>
      <url>/2021/12/29/softwareTestingBasics/</url>
      
        <content type="html"><![CDATA[<h2 id="1-软件测试定义"><a href="#1-软件测试定义" class="headerlink" title="1. 软件测试定义"></a>1. 软件测试定义</h2><p>在<font color="red">规定的条件</font>下对程序进行操作，<font color="red">发现程序错误，衡量软件质量</font>，并对其是否能<font color="red">满足设计要求</font>进行评估的过程<br>规定的条件——&gt;测试用例<br>发现程序错误——-&gt;找bug<br>衡量软件质量——-&gt;质量评估<br>满足设计要求——-&gt;满足需求</p><h2 id="2-软件测试方法分类"><a href="#2-软件测试方法分类" class="headerlink" title="2. 软件测试方法分类"></a>2. 软件测试方法分类</h2><h3 id="2-1-按开发阶段划分"><a href="#2-1-按开发阶段划分" class="headerlink" title="2.1 按开发阶段划分"></a>2.1 按开发阶段划分</h3><h4 id="2-1-1-单元测试"><a href="#2-1-1-单元测试" class="headerlink" title="2.1.1 单元测试"></a>2.1.1 单元测试</h4><p>对软件测组成单位进行测试，其目的是检验软件基本组成单位的正确性。测试对象是软件测试的最小单位：模块。</p><h4 id="2-1-2-集成测试"><a href="#2-1-2-集成测试" class="headerlink" title="2.1.2 集成测试"></a>2.1.2 集成测试</h4><p>将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试工作。集成主要目的是检查软件单位之间的接口是否正确。</p><h4 id="2-1-3-系统测试"><a href="#2-1-3-系统测试" class="headerlink" title="2.1.3 系统测试"></a>2.1.3 系统测试</h4><p>将软件系统看成是一个系统进行的测试。包括对功能、性能以及软件所运行的软硬件环境进行测试。 </p><h4 id="2-1-4-验收测试"><a href="#2-1-4-验收测试" class="headerlink" title="2.1.4 验收测试"></a>2.1.4 验收测试</h4><p>是部署软件之前的一个测试操作。它是技术测试的最后一个阶段，也称为交付测试。向软件购买者展示该软件系统满足原始需求。</p><h3 id="2-2-按是否手工执行划分"><a href="#2-2-按是否手工执行划分" class="headerlink" title="2.2 按是否手工执行划分"></a>2.2 按是否手工执行划分</h3><h4 id="2-2-1-手工测试"><a href="#2-2-1-手工测试" class="headerlink" title="2.2.1 手工测试"></a>2.2.1 手工测试</h4><p>   手工测试是由一个一个的输入用例，然后观察结果，和机器测试相对应，属于比较原始但是必须的一种</p><h4 id="2-2-2-自动化测试"><a href="#2-2-2-自动化测试" class="headerlink" title="2.2.2 自动化测试"></a>2.2.2 自动化测试</h4><p>   在预设条件下运行系统或应用程序，评估运行结果。（预先条件包括：正常条件和异常条件）。简单来说，自动化测试就是把人为驱动的测试行为，转化为机器执行的一种过程。</p><h3 id="2-3-按是否查看代码分"><a href="#2-3-按是否查看代码分" class="headerlink" title="2.3 按是否查看代码分"></a>2.3 按是否查看代码分</h3><h4 id="2-3-1-黑盒测试"><a href="#2-3-1-黑盒测试" class="headerlink" title="2.3.1 黑盒测试"></a>2.3.1 黑盒测试</h4><p>黑盒测试也是功能测试，测试中把被测的软件当作一个黑盒子，不关心盒子的内部结构是什么，只关心软件的输入数据和输出数据。</p><h4 id="2-3-2-白盒测试"><a href="#2-3-2-白盒测试" class="headerlink" title="2.3.2 白盒测试"></a>2.3.2 白盒测试</h4><p>白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是指打开盒子，去研究里面的源代码和程序结果。</p><h4 id="2-3-3-灰盒测试"><a href="#2-3-3-灰盒测试" class="headerlink" title="2.3.3 灰盒测试"></a>2.3.3 灰盒测试</h4><p>灰盒测试是介于白盒测试和黑盒测试之间的一种，灰盒测试多用于集成测试阶段，不仅关注输入、输出的正确性，同时也关注程序内部的情况。</p><h3 id="2-4-按是否运行划分"><a href="#2-4-按是否运行划分" class="headerlink" title="2.4 按是否运行划分"></a>2.4 按是否运行划分</h3><h4 id="2-4-1-静态测试"><a href="#2-4-1-静态测试" class="headerlink" title="2.4.1 静态测试"></a>2.4.1 静态测试</h4><p>   静态方法是指不运行被测程序本身，仅通过分析或检查源代码语法、结构、过程、接口等来检查程序的正确性，对需求说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。</p><h4 id="2-4-2-动态测试"><a href="#2-4-2-动态测试" class="headerlink" title="2.4.2 动态测试"></a>2.4.2 动态测试</h4><p>   通过运行被测程序，检查运行结果与预期结果的差异</p><h3 id="2-5-按测试对象划分"><a href="#2-5-按测试对象划分" class="headerlink" title="2.5 按测试对象划分"></a>2.5 按测试对象划分</h3><h4 id="2-5-1-非功能测试"><a href="#2-5-1-非功能测试" class="headerlink" title="2.5.1 非功能测试"></a>2.5.1 非功能测试</h4><ol><li>检查系统是否满足需求规格说明书中规定的性能<ul><li>稳定性  </li><li>响应时间</li><li>吞吐量</li><li>安全测试</li></ul></li><li>安全测试是一个相对独立的领域，需要更多的专业知识。如：WEB的安全测   试、需要熟悉各种网络协议、防火墙、CDN、数字各种操作系统的漏洞、熟悉路由器等。</li><li>兼容性测试<br> 兼容性测试主要是指软件之间能否很好的运作，会不会有影响、软件和硬件之间能否发挥很好的效率工作，会不会影响导致系统的崩溃。<ul><li>平台测试</li><li>浏览器测试</li><li>软件本身能否向前或向后兼容</li><li>测试软件能否与其他相关软件兼容</li><li>数据兼容性测试 </li></ul></li><li>文档测试<ul><li>开发文件：可行性研究报告、软件需求说明书、数据要求说明书、概要设计说明书、详细设计说明书、数据库设计说明书、模块开发卷宗。</li><li>用户文件：用户手册、操作手册，用户文档的作用：改善易安装性；改善软件的易学性与易用性；改善软件可靠性；降低技术支持成本。</li><li>管理文件：项目开发计划、测试计划、测试分析报告、开发进度月报、项目开发总结报告。<br>在实际的测试中，最常见的就是用户文件的测试，例如：用户操作说明书等。<br>文档测试关注点：<ul><li>文档的术语</li><li>文档的正确性</li><li>文档的完整性</li><li>文档的一致性</li><li>文档的易用性</li></ul></li></ul></li><li>易用性<br> 易用性是交互的适应性、功能性和有效性的集中体现。又叫用户体验测试。</li><li>界面测试(UI测试)<br> 测试用户界面的功能模块的布局是否合理、整体风格是否一致、各个控件的放置位置是否符合客户使用习惯，此外还要测试界面操作便捷性、导航简单移动，页面元素的可用性，界面文字是否正确，命名是否同意，页面是否美观，文字、图片组合是否完美等。</li><li>安装测试<br>  安装测试是指：测试程序的安装、卸载。最典型的就是APP的安装、卸载。</li></ol><h4 id="2-5-2-功能测试"><a href="#2-5-2-功能测试" class="headerlink" title="2.5.2 功能测试"></a>2.5.2 功能测试</h4><h3 id="2-6-按测试实施的组织划分"><a href="#2-6-按测试实施的组织划分" class="headerlink" title="2.6 按测试实施的组织划分"></a>2.6 按测试实施的组织划分</h3><h4 id="2-6-1-α测试"><a href="#2-6-1-α测试" class="headerlink" title="2.6.1 α测试"></a>2.6.1 α测试</h4><h4 id="2-6-2-β测试"><a href="#2-6-2-β测试" class="headerlink" title="2.6.2 β测试"></a>2.6.2 β测试</h4><p>α测试与β测试的区别：</p><ol><li>测试的场所不同：α测试是指把用户请到开发方的场所来测试，β测试是指在一个    或多个用户的场所进行测试。</li><li>α测试的环境是受开发方控制的，用户的数量相对比较少，时间比较集中。β测试的环境是不受开发方控制的，用户数量相对比较多，时间不集中。</li><li>α测试先于β测试执行。通用的软件产品需求较大规模的β测试，测试周期比较长。</li></ol><h4 id="2-6-3-第三方测试"><a href="#2-6-3-第三方测试" class="headerlink" title="2.6.3 第三方测试"></a>2.6.3 第三方测试</h4><p>介于开发方和用户方之间的组织测试</p><h3 id="2-7-按测试地域划分"><a href="#2-7-按测试地域划分" class="headerlink" title="2.7 按测试地域划分"></a>2.7 按测试地域划分</h3><h4 id="2-7-1-国际化测试"><a href="#2-7-1-国际化测试" class="headerlink" title="2.7.1 国际化测试"></a>2.7.1 国际化测试</h4><p>   软件的国际化和软件的本地化是开发面向全球不同地区用户使用的软件系统的两个过程。而本地化测试和国际化测试则是针对这类软件产品进行的测试。由于软件的全球化普及，还有软件外包行业的兴起，软件的本地化和国际化测试俨然成为了一个独特的测试专门领域。</p><h4 id="2-7-2-本地测试"><a href="#2-7-2-本地测试" class="headerlink" title="2.7.2 本地测试"></a>2.7.2 本地测试</h4><p>   之前的测试都是本地化测试。</p><h2 id="3-软件测试原则"><a href="#3-软件测试原则" class="headerlink" title="3. 软件测试原则"></a>3. 软件测试原则</h2><ol><li>测试应尽早进行，最好在需求阶段就开始接入，因为最严重的错误不外乎是系统不能满足用户的需求。</li><li>程序员(开发)应该避免检查自己的程序，软件测试应该由第三方(测试人员)来负责。</li><li>设计测试用例时应考虑到合法和不合法的输入(比如金额输入框)</li><li>在测试程序时，不仅要检验程序是否做了该做的事情，还要检验程序是否做了不该做的事情，多余的工作会带来副作用，影响程序的效率，有时会带来潜在的危害或错误。</li><li>应长期保留所有测试用例，保留测试用例有助于以后修改程序后的回归测试。</li></ol><h2 id="4-软件测试策略"><a href="#4-软件测试策略" class="headerlink" title="4. 软件测试策略"></a>4. 软件测试策略</h2><ol><li>选择测试方法<br> 选择对合适当前项目的测试方法(比如项目紧急的时候？项目频繁发版</li><li>角色与职责<br> 需要在测试策略里面明确定义各个角色，以及该角色的职责。比如项目经理，测试组长，测试工程师。</li><li>环境需求<br> 它将描述测试时需要的系统环境(软件，服务器linux，windows，数据库musql)，包括软硬件以及网络环境等待。在澄清环境需求的时候，测试组织可以识别出资源方面的风险。</li><li>风险分析<br> 影响测试过程的风险都应该尽早被识别出来，而且必须有相应的解决办法以便消除或者减轻这些风险。</li><li>测试进度评估<br> 测试进度将会评估完成测试所需要的时间。在设定进度的时候，首先需要明确测试范围(比如说这次增加一个：D模块，部分功能会影响原来已经上线的H模块的功能)，然后根据测试资源的多少来制定能被各方面认可的测试进度计划。</li><li>回归测试策略<br> 回归测试用来保证之前fix bug的代码不会影响软件的其他部分，这    样需要我们选择已经执行过的测试用例重新运行。测试人员需要找到一个方法来确    定哪些测试用例应该在回归测试中运行，用例不能太多，因为资源有限，用例也不    能太少，否则达不到必须的测试强度。</li><li>优先级<br>  测试范围内的东西不会都是一样重要的，加上测试资源各种有限，所以为测试的模块排定优先级是十分必要的。</li></ol><h2 id="5-软件测试模型"><a href="#5-软件测试模型" class="headerlink" title="5. 软件测试模型"></a>5. 软件测试模型</h2><h3 id="5-1-瀑布模型"><a href="#5-1-瀑布模型" class="headerlink" title="5.1 瀑布模型"></a>5.1 瀑布模型</h3><p>瀑布模型适用于结构化方法<br>软件项目或产品选择瀑布模型必须满足下列条件<br>在开发时间内需求没有或很少变化<br>分析设计人员应对应用领域很熟悉<br>低风险项目(对目标、环境很熟悉)<br>用户使用环境很稳定<br>用户除提出需求外，很少参与开发工作<br><img src="/2021/12/29/softwareTestingBasics/waterfallModel.png" alt="瀑布模型">   </p><h3 id="5-2-V模型"><a href="#5-2-V模型" class="headerlink" title="5.2 V模型"></a>5.2 V模型</h3><p>优点：</p><ul><li>包含底层测试(单元测试)和高层测试(系统测试)</li><li>清楚的标识了开发和测试的各个阶段；自上而下逐步求精，每个阶段分工明确，便于整体项目的把控。</li><li>V模型的价值在于它非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试和开发过程期间各阶段的对应关系。<br>缺点：</li><li>自上而下的顺序导致测试工作在编码后，不能及时的进行修改；实际工作中，需求经常变化，导致V模型步骤反复执行，返工量很大，灵活度较低。</li><li>V模型和瀑布模型有一些共同的特征，V模型中的过程从左到右，描述了基本的开发过程和测试行为。</li><li>(测试介入太晚)把测试作为编码之后的最后一个活动，需求分析等前期产生的错误到后期的验收测试才能发现。<br><img src="/2021/12/29/softwareTestingBasics/VModel.png" alt="V模型"><h3 id="5-3-敏捷模型"><a href="#5-3-敏捷模型" class="headerlink" title="5.3 敏捷模型"></a>5.3 敏捷模型</h3><img src="/2021/12/29/softwareTestingBasics/agileModel.png" alt="敏捷模型"></li></ul><h3 id="5-4-探索式测试"><a href="#5-4-探索式测试" class="headerlink" title="5.4 探索式测试"></a>5.4 探索式测试</h3><p>探索性测试可以说是一种测试思维模式。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。</p><h2 id="6-软件测试生命周期"><a href="#6-软件测试生命周期" class="headerlink" title="6. 软件测试生命周期"></a>6. 软件测试生命周期</h2><p><img src="/2021/12/29/softwareTestingBasics/softwareTestLifeCycle.png" alt="软件测试生命周期"></p><h2 id="7-用例设计"><a href="#7-用例设计" class="headerlink" title="7. 用例设计"></a>7. 用例设计</h2><h3 id="7-1-等价类划分"><a href="#7-1-等价类划分" class="headerlink" title="7.1 等价类划分"></a>7.1 等价类划分</h3><p>定义：依据需求将输入划分为若干等价类，从等价类中选定一个测试用例，如果该测试用例通过，则表明整个等价类通过测试。</p><p>使用场景：对于等价类这个方法，一般适用于有无限多种输入，我们不可能完成穷举测试，等价类这个方法可以使我们用较少的测试用例尽可能多的将功能覆盖<br>无效等价类和有效等价类<br>有效等价类：有意义的输入构成的集合，对于需求规格说明书是合法的<br>无效等价类：不满足需求的集合</p><h3 id="7-2-边界值分析法"><a href="#7-2-边界值分析法" class="headerlink" title="7.2 边界值分析法"></a>7.2 边界值分析法</h3><p>定义：边界值分析法是对等价类划分方法的补充，边界值一般都是从等价类的边缘去寻找错误<br>边界值分析的基本思路：正好等于，刚刚小于，刚刚大于，边界值作为测试数据<br>特记：0/空，N/A，null是一个特殊值，我们在考虑边界值的时候同时也要考虑这个特殊值</p><h3 id="7-3-场景法"><a href="#7-3-场景法" class="headerlink" title="7.3 场景法"></a>7.3 场景法</h3><p>尽可能真实全部的模拟用户操作—订单，发货，商品状态变化<br>场景法主要基于：</p><ol><li>业务(需求)层面：对所测软件的重要功能、业务逻辑(系统要干什么，怎么去实现，这个过程)行业背景深入了解</li><li>技术层面：基于等价类划分，有效等价类—-模拟用户正确操作；无效等价类—模拟错误操作<br>核心概念<br>基本流(正确流、有效流)：模拟用户正确的操作流程<br>备选流(错误流、无效流)：模拟用户错误的操作流程</li></ol><h3 id="7-4-判定表"><a href="#7-4-判定表" class="headerlink" title="7.4 判定表"></a>7.4 判定表</h3><h3 id="7-5-因果图"><a href="#7-5-因果图" class="headerlink" title="7.5 因果图"></a>7.5 因果图</h3><p>利用因果图设计测试用例应遵循的步骤</p><ol><li>分析程序的规格说明书中哪些是原因，哪些是结果。所谓原因，是指输入条件  或输入条件的等价类，而结果是指输出条件，给每一个原因和结果赋一个标识符</li><li>分析程序规格说明书中的语义，确定原因与原因，原因与结果之间的关系，画出因果图</li><li>由于语法环境的限制，一些原因与原因之间，原因与结果之间的组合不能出现。对于这些特殊情况，在因果图中用一些记号标明约束或限制条件</li><li>将因果图转化为判定表</li><li>根据判定表的每一列设计测试用例 </li></ol><h3 id="7-6-错误推测法"><a href="#7-6-错误推测法" class="headerlink" title="7.6 错误推测法"></a>7.6 错误推测法</h3><p>定义：基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法<br>2-8原则   80%的问题出在20%的模块中<br>错误推测法的基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例<br>基本要素：</p><ul><li>对开发的开发习惯很熟悉</li><li>对同类型项目业务非常熟悉</li></ul><h3 id="7-7-正交试验法"><a href="#7-7-正交试验法" class="headerlink" title="7.7 正交试验法"></a>7.7 正交试验法</h3><p>正交试验是研究多因素，多水平的一种试验法，它是利用正交表来对试验进行设计，通过少数的试验替代全面试验，根据正交表的正交性从全面试验中挑选适量的、有代表性的点进行试验，这些有代表性的点具备了均匀分散，整齐可比的特点。因素之间互不影响。</p><h2 id="8-需求澄清"><a href="#8-需求澄清" class="headerlink" title="8. 需求澄清"></a>8. 需求澄清</h2><h3 id="8-1-需求阶段位置"><a href="#8-1-需求阶段位置" class="headerlink" title="8.1 需求阶段位置"></a>8.1 需求阶段位置</h3><p>需求是软件项目研发的开始<br>需求是组件研发团队后第一次集体参与讨论的事情<br>需求是保障质量的最重要的一环</p><h3 id="8-2-需求会议"><a href="#8-2-需求会议" class="headerlink" title="8.2 需求会议"></a>8.2 需求会议</h3><h2 id="9-测试计划"><a href="#9-测试计划" class="headerlink" title="9. 测试计划"></a>9. 测试计划</h2><p>软件测试是有计划，有组织和由系统的软件质量保证活动，而不是随意地，松散的、杂乱地实施过程。为了规范软件测试内容、方法和过程，在对软件进行测试之前，必须创建测试计划。<br>测试计划：一个叙述了预定地测试活动地范围(哪些模块)、测试资源(软件、硬件)及进度安排的文档。它确认了测试项、被测特征、测试任务、人员安排，以及任何偶发事件的风险。<br>包含了产品概述、测试策略、测试方法、测试范围、事件安排、测试人力、风险分析等内容。<br>为什么要写测试计划</p><ol><li>使软件测试工作进行更顺利：计划使我们软件测试工作的预先安排，为我们的整个测试工作指明方向(该怎么进行，什么时候进行)</li><li>促进项目参加人员彼此的沟通：测试人员能够了解整个项目测试情况以及项目测试不同阶段的所有要进行的工作等。这种形式使测试工作与开发工作紧密联系起来。</li><li>使软件测试工作更易于管理：领导能够根据测试计划做宏观调控，进行相应的资源配置等；其他人员了解测试人员的工作内容，进行有关配合工作。按照这种方式，资源与变更变成了一个可控制的风险。<br>什么时候开始编写测试计划：确定什么事件开始做测试计划使很重要的，一般来说是测试需求分析完成之后开始。<br>谁编写测试计划：编写测试计划是一项系统工作，编写者必须对项目了解，对测试工作所接触到的方方面面都要有系统地把握。因此一般情况下是由具有丰富经验地项目测试负责人或者测试负责人进行编写。<br>测试计划编写原则：</li><li>制定测试计划应尽早开始：越早进行测试计划，从最根本地地方去了解我们所要测试的对象及内容，方便后续完善测试计划</li><li>保持测试计划简介和易读：测试计划做出来后应该能够让测试人员明了自己的任务和计划</li><li>尽量争取多渠道评审测试嘉华：通过不同的人来发现测试计划中的不足及缺陷，可以很好的改进测试计划的质量</li><li>计算测试的投入：投入到测试中的项目经费是一定的，我们指定测试计划时一定要注意测试计划的费用情况，要量力而行</li></ol><h2 id="10-BUG"><a href="#10-BUG" class="headerlink" title="10 BUG"></a>10 BUG</h2><h3 id="10-1-Bug的定义"><a href="#10-1-Bug的定义" class="headerlink" title="10.1 Bug的定义"></a>10.1 Bug的定义</h3><p>电脑程序里的错误，而现在更是将其延生为漏洞，错误，可改进的细节、或与需求文档存在差异的功能实现等。</p><p><img src="/2021/12/29/softwareTestingBasics/bugTrackingProcess.png" alt="bug跟踪流程"></p><h3 id="10-2-BUG的分类"><a href="#10-2-BUG的分类" class="headerlink" title="10.2 BUG的分类"></a>10.2 BUG的分类</h3><ol><li>代码错误（错误页404、500）</li><li>界面优化（UI问题，图文显示）</li><li>安装部署（安装失败，无法访问等）</li><li>性能问题（响应时间久，加载慢）</li><li>安全相关（密码：123456 ****）</li><li>其他划分（易用性、兼容性类）</li><li>设计缺陷（需求问题）</li></ol><h3 id="10-3-Bug的严重程度"><a href="#10-3-Bug的严重程度" class="headerlink" title="10.3 Bug的严重程度"></a>10.3 Bug的严重程度</h3><ol><li>致命的–最高<br> 系统崩溃（请求直接把服务器搞坏）、死机、死循环，导致数据库数据丢失，与数  据库连接错误，主要功能丧失，基本模块缺失，重要的以及菜单功能不能使用等。</li><li>严重的–高<br>系统主要功能部分丧失、数据库保存，提交调用错误，功能设计与需求严重不符，自动退出，稳定性差，数值计算统计错误等（该等级问题出现在不影响其他功能测试的情况下可以继续该版本）</li><li>一般的–中<br> 功能菜单没有完全实现存在缺陷但不会影响系统稳定性。如：操作时间长、查询时间长、格式错误、边界条件错误，删除没有确认框、数据库表中字段过多等（该问题实际测试中存在最多）</li><li>轻微的–低<br> 兼容性，界面优化，不影响操作功能的执行，错别字，页面显示重叠，提示语丢失（此类问题在测试初期较多，优先程度较低）登录</li><li>建议性–低</li></ol><h3 id="10-4-BUG优先级"><a href="#10-4-BUG优先级" class="headerlink" title="10.4 BUG优先级"></a>10.4 BUG优先级</h3><p>非常紧急、紧急、一般、不重要</p><h3 id="10-5-BUG的状态标准"><a href="#10-5-BUG的状态标准" class="headerlink" title="10.5 BUG的状态标准"></a>10.5 BUG的状态标准</h3><ol><li>待处理（提交–激活）<br>测试人员或用户发现新问题后提交的状态</li><li>已确认<br>经测试人员及研发人员讨论后确认是bug，提交的状态，由开发点击确认按钮</li><li>已处理=已解决<br>经研发人员确认是bug后修复的状态，修改还没有验证，有开发人员来设置</li><li>已修改=已关闭—–最终的bug状态<br>测试人员认为问题已经修改，通过验证，有测试人员设置</li><li>任存在=重新打开<br>测试人员认为bug未修复成功，问题任然存在，有测试人员设置</li><li>不是bug<br>研发人员确认不是bug，或者建议与意见决定不采纳，由开发人员设置</li><li>暂不处理=挂起<br>当前版本不做修改，后续版本再考虑，或者一时不确定是解决不解决，需要过一两天来决定，这样的bug就需要一个挂起状态由研发人员或测试人员设置。</li></ol><h3 id="10-6-如何创建一个高质量的BUG"><a href="#10-6-如何创建一个高质量的BUG" class="headerlink" title="10.6 如何创建一个高质量的BUG"></a>10.6 如何创建一个高质量的BUG</h3><ol><li>标题：主要简明扼要地描述了bug，可以让人快速的了解问题</li><li>测试环境：什么环境下发现的，软件和硬件系统，什么版本，如果需要，还应注明那个，硬件平台</li><li>前提条件：用户测试步骤前的系统环境信息（bug在什么环境或者设置下出现）</li><li>测试步骤：在执行什么操作时，发现问题</li><li>实际结果：在测试软件的过程中，软件本身表现出的结果，可能与预期结果有出入</li><li>预期结果：软件设计所要求达到的需求本身达到的目的，预期目标</li><li>附件—主要</li></ol><h3 id="10-7-怎样与开发沟通"><a href="#10-7-怎样与开发沟通" class="headerlink" title="10.7 怎样与开发沟通"></a>10.7 怎样与开发沟通</h3><ol><li>确保自己提交的是个bug，并且能重现这个bug</li><li>如果开发有疑问，或者说没有问题的时候，我们可以从用户的角度解释使用系统时，用户的操作怎样的不便一</li><li>Bug步骤需要写清楚，或者描述清楚，开发人员在了解问题所在后，可以准确定位</li><li>跟研发确认清楚，修改这块后，主要影响哪里，会对其他模块有影响没，有的话，我们需要重新关注</li></ol><h2 id="11-APP测试-专项测试"><a href="#11-APP测试-专项测试" class="headerlink" title="11. APP测试-专项测试"></a>11. APP测试-专项测试</h2><h3 id="11-1-安装测试"><a href="#11-1-安装测试" class="headerlink" title="11.1 安装测试"></a>11.1 安装测试</h3><ol><li>软件在不同操作系统下安装是否正常</li><li>软件安装后是否能够正常运行，安装后的文件及文件夹是否写到了指定的目录里</li><li>软件安装各个选项的组合是否符合概要设计说明</li><li>软件安装向导的UI测试</li><li>软件安装过程是否可以取消，点击取消后，写入的文件是否如概要设计说明处理</li><li>软件安装过程中意外情况的处理是否符合需求（如死机，重启，断电）</li><li>安装空间不足时是否有相应提示—-特殊极限</li><li>对于需要通过网络验证之类的安装，在断网情况下尝试一下（点点头，眨眨眼）</li><li>对安装手册进行测试，依照安装手册是否能顺利安装（官网帮助手册）</li><li>二次安装（覆盖重新安装）</li><li>浏览器下载.apk安装（app安装包传到手机安装）</li></ol><h3 id="11-2-卸载测试"><a href="#11-2-卸载测试" class="headerlink" title="11.2 卸载测试"></a>11.2 卸载测试</h3><ol><li>直接删除安装文件夹卸载是否有提示信息</li><li>测试系统直接卸载程序是否有提示信息</li><li>卸载过程中出现的意外情况的测试（如死机、断电、重启）</li><li>卸载是否支持取消功能，单击取消后软件卸载的情况</li><li>系统直接卸载UI测试，是否有卸载状态进度条提示 </li></ol><h3 id="11-3-导航测试"><a href="#11-3-导航测试" class="headerlink" title="11.3 导航测试"></a>11.3 导航测试</h3><ol><li>按钮、对话框、列表和窗口等；或在不同的连接页面之间需要导航</li><li>是否易于导航，导航是否直观</li><li>是否需要搜索引擎</li><li>导航与页面结构、菜单、连接页面的风格是否一致</li></ol><h3 id="11-4-图形测试"><a href="#11-4-图形测试" class="headerlink" title="11.4 图形测试"></a>11.4 图形测试</h3><ol><li>横向比较。各控件操作方式统一</li><li>自适应界面设计，内容根据窗口大小自适应</li><li>页面标签风格是否统一</li><li>页面是否美观</li><li>页面的图片应有其实际以及而要求整体有序美观</li><li>图片质量要高且图片尺寸在设计符合要求的情况下应尽量小</li><li>界面整体使用的颜色不宜过多</li></ol><h3 id="11-5-内容测试"><a href="#11-5-内容测试" class="headerlink" title="11.5 内容测试"></a>11.5 内容测试</h3><ol><li>输入框说明文字的内容与系统功能是否一致</li><li>文字长度是否加以限制</li><li>文字内容是否表意不明</li><li>是否有错别字，敏感词</li><li>是否有敏感性图片，如：设计版权、专利、隐私等图片</li></ol><h3 id="11-6-运行测试"><a href="#11-6-运行测试" class="headerlink" title="11.6 运行测试"></a>11.6 运行测试</h3><ol><li>App安装完成后的试运行，可以正常打开软件</li><li>App打开测试，是否有加载状态进度提示</li><li>App打开速度测试，速度是否客观</li><li>App页面间的切换是否流畅，逻辑是否正确</li></ol><h3 id="11-7-APP更新升级"><a href="#11-7-APP更新升级" class="headerlink" title="11.7 APP更新升级"></a>11.7 APP更新升级</h3><ol><li>当客户端有新版本时，有更新提示</li><li>当版本为非强制升级版时，用户可以取消更新，老版本能正常使用。用户在下次启动app时，仍能出现更新提示</li><li>当版本为强制升级版时，当给出强制更新后用户没有做更新时，退出客户端。下次启动app时，仍出现轻质升级提示</li><li>当客户端有新版本时，在本地不删除客户端的情况下，直接更新兼差是否能正常更新</li><li>当客户端有新版本时，在本地删除客户端的情况下，检查更新后的客户端功能是否是新版本</li><li>当客户端有新版本时，在本地不删除客户端的情况下，检查资源同名文件如图片是否能正常更新最新版本</li></ol><h3 id="11-8-交叉时间测试"><a href="#11-8-交叉时间测试" class="headerlink" title="11.8 交叉时间测试"></a>11.8 交叉时间测试</h3><ol><li>多个App同事运行是否影响正常功能</li><li>App运行时前后台切换是否影响功能</li><li>App运行时拨打/接听电话</li><li>App运行时发送/接受信息</li><li>App运行时发送/接受邮件</li><li>App运行时切换网络（2G、3G、4G、5G、wifi）</li><li>App运行时浏览网页</li><li>App运行时使用蓝牙传送/接受数据</li><li>App运行时使用相机、计算器等手机自带设备</li></ol><h3 id="11-9-兼容性测试"><a href="#11-9-兼容性测试" class="headerlink" title="11.9 兼容性测试"></a>11.9 兼容性测试</h3><ol><li>系统版本兼容性测试（ios、android、鸿蒙）</li><li>设备兼容性测试（华为、荣耀、苹果、小米、三星、魅族、诺基亚等等）</li><li>分辨率兼容性测试（720p（720<em>1280），1080p（1080</em>1920），2K（2560*1440）） </li><li>埋点–自有埋点，第三方埋点</li></ol><h3 id="11-10-用户体验测试"><a href="#11-10-用户体验测试" class="headerlink" title="11.10 用户体验测试"></a>11.10 用户体验测试</h3><p>以主观的普通消费者的角度去感知产品或服务的舒适、有用、易用、友好亲切程度。通过不同个体、独立空间和非经验的统计服用方式去有效评价产品的体验特性提出修改意见提升产品潜在的客户满意度。</p><ol><li>是否有空数据界面设计，引导用户去执行操作</li><li>是否滥用用户引导</li><li>是否有不可点击的小幅哦，如：你的按钮此时处于不可用状态，那么一定要灰掉，或者拿掉按钮，否则会给用户误导</li><li>菜单层次是否太深</li><li>交互流程分支是否太多</li><li>界面中按钮可点击范围是否适中</li><li>标签页是否跟内容没有从属关系，当切换标签的时候，内容跟着切换</li><li>是否定义back的逻辑。设计软硬件交互时，back应具体定义</li><li>是否有横屏模式的设计，应用一般需要支持横屏模式，即自适应设计</li></ol><h3 id="11-11-手势操作测试"><a href="#11-11-手势操作测试" class="headerlink" title="11.11 手势操作测试"></a>11.11 手势操作测试</h3><ol><li>手机锁屏对运行中的App的影响</li><li>切换网络对运行中的App的影响</li><li>运行中的App前后台切换的影响</li><li>多个运行中的App的切换</li><li>App运行时关机</li><li>App运行时重启系统</li><li>App运行时充电</li><li>App运行时kill掉进程再打开</li></ol><h3 id="11-12-网络环境测试"><a href="#11-12-网络环境测试" class="headerlink" title="11.12 网络环境测试"></a>11.12 网络环境测试</h3><p>手机的网络目前主要分为3G、4G、5G、wifi。目前3G的网络相较于比较慢，测试时尤其要注意此块的测试。</p><ol><li>无网络时，执行需要网络的操作，给予友好提示</li><li>在网络信号不好时，检查功能状态是否正常，确保不因提交数据失败而造成数据丢失</li><li>在网络信号不好时，检查数据是否会一直处于提交中的状态，有无超时限制。如遇数据交换失败时要给予提示</li><li>在网络信号不好时，执行操作后，在回调没有完成的情况下，退出本页面或者执行其他操作的情况，有无异常情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建(一)   雏形</title>
      <link href="/2021/12/28/blogSetUp/"/>
      <url>/2021/12/28/blogSetUp/</url>
      
        <content type="html"><![CDATA[<p>Hexo+Github Pages搭建博客的前期工作。拥有一个Github账号(Github是代码托管平台)。安装Git(一座通向GitHub的桥梁。我们可以通过git把本地项目上传到GitHub，同时也可以通过git从GitHub上取项目到本地。)；安装Hexo(我们的个人博客网站的框架),安装Node.JS</p><h2 id="一、注册一个Github账号"><a href="#一、注册一个Github账号" class="headerlink" title="一、注册一个Github账号"></a>一、注册一个Github账号</h2><p>  点击<a href="https://github.com/">Github</a>访问Github官网，点击Sign up进行注册，在新的页面输入要求的信息即可<br>   <img src="/2021/12/28/blogSetUp/1.png"></p><h2 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h2><ol><li>点击<a href="https://git-scm.com/downloads">Git官网</a>进入官网，根据自己的电脑环境选择对应的版本。<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">安装教程</a></li><li>按下Win+R输入cmd打开运行窗口，输入<code>git --version </code>测试Git是否安装成功，若出现Git版本信息则安装成功</li><li>配置Git个人信息<ul><li>输入<code>git config --global user.name &quot;name&quot; </code> name=你注册Github时的名字</li><li>输入<code>git config --global user.email  &quot;Email&quot; </code> Email=你注册Github时的邮箱<br><img src="/2021/12/28/blogSetUp/9.png"></li></ul></li></ol><h2 id="三、安装Node-js"><a href="#三、安装Node-js" class="headerlink" title="三、安装Node.js"></a>三、安装Node.js</h2><ol><li>点击<a href="https://nodejs.org/en/download/">nodejs</a>进入官网，按自己电脑的环境选择对应的版本即可。<a href="https://blog.csdn.net/muzidigbig/article/details/80493880">安装教程</a></li><li>按下Win+R输入cmd打开运行窗口，输入<code>node -v</code>，<code>npm -v</code>若出现版本信息则安装成功</li></ol><h2 id="四、安装Hexo"><a href="#四、安装Hexo" class="headerlink" title="四、安装Hexo"></a>四、安装Hexo</h2><ol><li>在你想要存放博客的地方创建一个文件夹，例如F:\Blog</li><li>右键F:\Blog文件夹，点击Git Bash Here</li><li>输入<code>npm install hexo-cli -g</code>安装Hexo<br>   <img src="/2021/12/28/blogSetUp/10.png"></li><li>输入<code>npm install hexo-deployer-git --save </code>安装的Hexo部署到git page的deployer<br>   <img src="/2021/12/28/blogSetUp/11.png"></li></ol><h2 id="五、Hexo初始化配置"><a href="#五、Hexo初始化配置" class="headerlink" title="五、Hexo初始化配置"></a>五、Hexo初始化配置</h2><ol><li>在F:\Blog下新建一个名为Hexo的空文件夹，右键Hexo文件夹，点击Git Bash Here，输入<br><code>hexo init</code></li><li>Hexo文件夹如下所示<br><img src="/2021/12/28/blogSetUp/13.png"></li><li>右键Hexo文件夹，选择Git Bash Here输入<code>hexo g</code>，<code>hexo s</code></li><li>登录 <a href="http://localhost:4000/">http://localhost:4000/</a>，出现下图所示则初始化配置成功<br> <img src="/2021/12/28/blogSetUp/14.png"></li></ol><h2 id="六、创建代码库"><a href="#六、创建代码库" class="headerlink" title="六、创建代码库"></a>六、创建代码库</h2><ol><li>登录Github，点击头像，在下拉列表选择Your repositories进入代码库</li><li>点击右上角的New创建新的代码库<br><img src="/2021/12/28/blogSetUp/2.png"><br><img src="/2021/12/28/blogSetUp/3.png"></li></ol><h2 id="七、配置SSH秘钥"><a href="#七、配置SSH秘钥" class="headerlink" title="七、配置SSH秘钥"></a>七、配置SSH秘钥</h2><ol><li><p>生成SSH秘钥</p><ul><li>在你想要存放博客的地方创建一个文件夹，例如F:\Blog</li><li>右键Blog文件夹，点击Git Bash Here</li><li><code> ssh-keygen -t rsa -C &quot;Email&quot;</code>  Email=你刚才注册Github的邮箱</li><li>之后出现<br><code> Generating public/private rsa key pair.     Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</code>直接回车</li><li>接下来出现<br> <code>Your identification has been saved in /c/Users/you/.ssh/id_rsa.</code><br>  <code> Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.</code><br>  <code>The key fingerprint is:</code><br>   <code> The key&#39;s randomart image is:</code> </li></ul></li><li><p>在Github添加秘钥</p><ul><li>登录Github，右键头像，在下拉框选择Settings</li><li>在页面的左侧菜单选择SSH and GPG keys<br>   <img src="/2021/12/28/blogSetUp/4.png"></li><li>选择New SSH key<br>   <img src="/2021/12/28/blogSetUp/5.png"></li><li>粘贴你的秘钥，秘钥在C:\Users\你的电脑名字.ssh\id_rsa.pub，秘钥为该文件的全部内容。该文件是隐藏文件<br>  <img src="/2021/12/28/blogSetUp/6.png"></li><li>测试，输入<code>ssh -T git@github.com</code>之后若显示<br> <img src="/2021/12/28/blogSetUp/7.png"><br> 输入yes即可，若出现下图所示，表示配置成功<br>   <img src="/2021/12/28/blogSetUp/8.png"></li></ul></li></ol><h2 id="八、将Hexo文件更新到Github中"><a href="#八、将Hexo文件更新到Github中" class="headerlink" title="八、将Hexo文件更新到Github中"></a>八、将Hexo文件更新到Github中</h2><ol><li>登录自己的Github，打开自己刚才建立的仓库，复制地址如下图所示<br>   <img src="/2021/12/28/blogSetUp/15.png"></li><li>修改配置信息<ul><li>打开F:\Blog\Hexo文件的_config.xml</li><li>找到如下所示信息，进行修改<br>type: git          repository: 刚才复制的地址     branch: 见图<br><img src="/2021/12/28/blogSetUp/16.png"> <img src="/2021/12/28/blogSetUp/17.png"><br><font color="#F44336">踩过的坑：</font> branch的值与Github不一致，导致上传至Github失败</li></ul></li><li>测试是否可以部署<ul><li>右键F:\Blog\Hexo，点击Git Bash Here</li><li>输入<code>hexo g </code>，<code>hexo s </code>，<code>hexo g -d</code>，</li><li>若出现下面的情况说明deployer没有安装成功，那我们需要输入<code>npm install hexo-   deployer-git --save </code>再次安装，再输入<code>hexo g -d</code>，若没有则跳过此步骤</li><li>在浏览器输入https://你的用户名.github.io，就会出现创建仓库时的readme内容</li></ul></li></ol><hr><p>参考文章<a href="https://itrhx.blog.csdn.net/article/details/82121420">https://itrhx.blog.csdn.net/article/details/82121420</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github Pages </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
